var CS_CONF = {
    projectId: 1795,
    status: 1,
    hostnames: ["bestbuy.com"],
    crossDomainTracking: 0,
    crossDomainSingleIframeTracking: 0,
    consentRequired: 1,
    allowSubdomains: 1,
    visitorCookieTimeout: 34164000000,
    sampleRate: 100,
    replayRecordingRate: 0,
    validationRate: 10,
    lastTrackingDraw: 1645469968,
    trackerDomain: "c.contentsquare.net",
    recordingDomain: "r.contentsquare.net",
    useMalkaPipeline: 1,
    ed: "l.contentsquare.net/log/web",
    eMerchandisingEnabled: 1,
    mouseMoveHeatmapEnabled: 1,
    autoInsightsEnabled: 0,
    jsErrorsEnabled: 0,
    customErrorsEnabled: 0,
    jsCustomErrorsEnabled: 0,
    apiErrorsEnabled: 0,
    customHashIdEnabled: 0,
    recordingEncryptionEnabled: 0,
    recordingEncryptionPublicKey: null,
    recordingEncryptionPublicKeyId: 0,
    secureCookiesEnabled: 0,
    triggerSessionReplayEnabled: 0,
    triggerSessionReplayRegex:
        "(.*com\\/site\\/questions\\/.*|.*com\\/site\\/reviews\\/.*)",
    dynamicIdRegex: "^.+-\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}$",
    whitelistedAttributes: [],
    replayRecordingUnmaskedUrlRegex: null,
    replayRecordingUnmaskedUrlRegexRules: [],
    replayRecordingMaskedUrlRegexRules: [],
    replayRecordingMaskedUrlRegex: null,
    anonymisationMethod: "replayRecordingUnmaskedUrlRegex",
    tagDeploymentMode: "CONTENTSQUARE",
    experimental: null,
    iframesTracking: 0,
    textVisibilityEnabled: 0,
    cookielessTrackingEnabled: 0,
    malkaUrlEnabled: 1,
    malkaEtrEnabled: 0,
    pathComputationRules: {
        reliableSelectors: [],
        uniqueAttributes: [],
        uniqueCssSelectors: [],
    },
    asyncSerializerEnabled: 1,
    pendingInactivityTimeout: 5000,
    accessibilityEnabled: 0,
    uxaDomain: "app.contentsquare.com",
    webviewsTrackingEnabled: 0,
    useStaticResourceManager: 1,
    performanceTimingOptions: { withResource: false, withNavigation: false },
    replayConsentRequiredForSession: 0,
    displayAdOptions: null,
    taskSchedulerOptions: { enabled: 1 },
    malkaQuotaServiceDomain: "q-aeu1.contentsquare.net",
    malkaRecordingDomain: "k-aeu1.contentsquare.net",
    staticResourceManagerDomain: "srm.ba.contentsquare.net",
}
var CS_INTEGRATIONS_CONF = { "opinion-lab": {} }
/* integration-opinion-lab 2.10.4 */
!(function (e) {
    var t = {}
    function n(o) {
        if (t[o]) return t[o].exports
        var i = (t[o] = { i: o, l: !1, exports: {} })
        return e[o].call(i.exports, i, i.exports, n), (i.l = !0), i.exports
    }
    ;(n.m = e),
        (n.c = t),
        (n.d = function (e, t, o) {
            n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: o })
        }),
        (n.r = function (e) {
            "undefined" != typeof Symbol &&
                Symbol.toStringTag &&
                Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module",
                }),
                Object.defineProperty(e, "__esModule", { value: !0 })
        }),
        (n.t = function (e, t) {
            if ((1 & t && (e = n(e)), 8 & t)) return e
            if (4 & t && "object" == typeof e && e && e.__esModule) return e
            var o = Object.create(null)
            if (
                (n.r(o),
                Object.defineProperty(o, "default", {
                    enumerable: !0,
                    value: e,
                }),
                2 & t && "string" != typeof e)
            )
                for (var i in e)
                    n.d(
                        o,
                        i,
                        function (t) {
                            return e[t]
                        }.bind(null, i)
                    )
            return o
        }),
        (n.n = function (e) {
            var t =
                e && e.__esModule
                    ? function () {
                          return e.default
                      }
                    : function () {
                          return e
                      }
            return n.d(t, "a", t), t
        }),
        (n.o = function (e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }),
        (n.p = ""),
        n((n.s = 1))
})([
    function (e) {
        e.exports = JSON.parse(
            '{"name":"@contentsquare/integration-opinion-lab-contentsquare","version":"2.10.4","scripts":{"build:snippet":"webpack"}}'
        )
    },
    function (e, t, n) {
        "use strict"
        function o(e, t) {
            try {
                e()
            } catch (e) {
                ;(window._uxa = window._uxa || []),
                    _uxa.push(["logSnippetError", t, e.message])
            }
        }
        function i(e) {
            return "object" == typeof e && null !== e
        }
        function a(e, t) {
            if (
                i(window.CS_INTEGRATIONS_CONF) &&
                i(window.CS_INTEGRATIONS_CONF[e])
            )
                return window.CS_INTEGRATIONS_CONF[e][t]
        }
        n.r(t)
        var r,
            s = n(0),
            c = s.name,
            u = s.version,
            p = (function (e) {
                var t, n, i, a
                if (
                    (o(function () {
                        var o = e.name
                        i = e.version
                        var r = o.replace("@contentsquare/integration-", "")
                        t = r + "-" + i
                        var s = "-contentsquare"
                        ;(a = new RegExp(s + "$").test(r)),
                            (n = r.replace(
                                /-contentsquare([^-contentsquare]*)$/,
                                "$1"
                            )),
                            a ||
                                ((s = "-cap"),
                                (a = new RegExp(s + "$").test(r)),
                                (n = r.replace(/-cap([^-cap]*)$/, "$1")))
                    }, "Shared-Function-readPackageJSON"),
                    a)
                )
                    return {
                        snippetBuildName: t,
                        parameterName: n,
                        snippetVersion: i,
                    }
            })(s)
        p &&
            ((r = p.parameterName),
            (c = p.snippetBuildName),
            (u = p.snippetVersion)),
            o(function () {
                ;(window._uxa = window._uxa || []),
                    (CS_CONF.integrations = CS_CONF.integrations || []),
                    CS_CONF.integrations.push("Verint (OpinionLab) - v" + u)
                var e = !1
                window.self != window.top && (e = CS_CONF.iframesTracking)
                var t = ""
                "DUAL_COLLECTION" === CS_CONF.tagDeploymentMode &&
                CS_CONF.ptcPartition
                    ? (t = "M2PCT")
                    : "DUAL_COLLECTION" !== CS_CONF.tagDeploymentMode ||
                      CS_CONF.ptcPartition
                    ? "LOAD_CLICKTALE_PTC" === CS_CONF.tagDeploymentMode
                        ? (t = "M2")
                        : "CONTENTSQUARE" === CS_CONF.tagDeploymentMode &&
                          (t = "CS")
                    : (t = "M2PCS")
                var n = a(r, "settings"),
                    i = !1,
                    s = ""
                n &&
                    (n.indexOf("sendArtificialPageviews") > -1 && (i = !0),
                    n.indexOf("setReplayLinkToFirstPV") > -1 && (s = 0))
                var p = !1
                function d(e, t, n, o) {
                    ;(e = "FB_OL_" + e),
                        _uxa.push([
                            "trackDynamicVariable",
                            { key: e, value: t },
                        ]),
                        p &&
                            "etr" === n &&
                            _uxa.push([
                                "trackEventTriggerRecording",
                                "@ETS@" + e,
                            ]),
                        o &&
                            i &&
                            _uxa.push([
                                "trackPageview",
                                window.location.pathname + "?" + o,
                            ])
                }
                function l() {
                    for (
                        var e = 0,
                            t = document.domain,
                            n = t.split("."),
                            o = "_cs_tld" + new Date().getTime();
                        e < n.length - 1 &&
                        -1 == document.cookie.indexOf(o + "=" + o);

                    )
                        (t = n.slice(-1 - ++e).join(".")),
                            (document.cookie =
                                o +
                                "=" +
                                o +
                                ";domain=" +
                                t +
                                ";SameSite=None;Secure")
                    return (
                        (document.cookie =
                            o +
                            "=;expires=Thu, 01 Jan 1970 00:00:01 GMT;domain=" +
                            t +
                            ";"),
                        t
                    )
                }
                function g(e) {
                    for (
                        var t = e + "=", n = document.cookie.split(";"), o = 0;
                        o < n.length;
                        o++
                    ) {
                        for (var i = n[o]; " " == i.charAt(0); )
                            i = i.substring(1, i.length)
                        if (0 === i.indexOf(t))
                            return i.substring(t.length, i.length)
                    }
                    return ""
                }
                function m() {
                    var e = {
                        contentsquare_integration: g("_cs_s"),
                        vendor: "opinion-lab",
                    }
                    window.opener
                        ? window.opener.postMessage(e, "*")
                        : self != top && window.top.postMessage(e, "*")
                }
                function S(e) {
                    return e.toString().replace(/[^\w. ]/gi, function (e) {
                        return "&#" + e.charCodeAt(0) + ";"
                    })
                }
                if (document.location.host.indexOf("opinionlab.com") > -1) {
                    if (
                        !e &&
                        window.olData &&
                        (olData.clickTaleUID || olData.contentsquareIDs)
                    ) {
                        var f = ""
                        if (
                            (f =
                                "M2PCT" === t
                                    ? olData.clickTaleUID
                                    : olData.contentsquareIDs) &&
                            "null" != f
                        ) {
                            var _ = f.split("~"),
                                C = _[0],
                                v = _[1],
                                N = _[2],
                                O = _[3],
                                T = l()
                            C &&
                                v &&
                                N &&
                                (O
                                    ? (document.cookie =
                                          "_cs_optout=" +
                                          O +
                                          ";domain=" +
                                          T +
                                          ";path=/;SameSite=None;Secure")
                                    : ((document.cookie =
                                          "_cs_optout=;domain=" +
                                          T +
                                          ";path=/;expires=Thu, 01-Jan-1970 00:00:01 GMT;SameSite=None;Secure"),
                                      (document.cookie =
                                          "_cs_optout=;path=/;expires=Thu, 01-Jan-1970 00:00:01 GMT;SameSite=None;Secure"),
                                      (document.cookie =
                                          "_cs_optout=;domain=." +
                                          document.location.host +
                                          ";path=/;expires=Thu, 01-Jan-1970 00:00:01 GMT;SameSite=None;Secure")),
                                (document.cookie =
                                    "_cs_id=" +
                                    C +
                                    ";domain=" +
                                    T +
                                    ";path=/;SameSite=None;Secure"),
                                (document.cookie =
                                    "_cs_s=" +
                                    v +
                                    ";domain=" +
                                    T +
                                    ";path=/;SameSite=None;Secure"),
                                (document.cookie =
                                    "_cs_c=" +
                                    N +
                                    ";domain=" +
                                    T +
                                    ";path=/;SameSite=None;Secure"))
                        }
                    }
                    function w() {
                        if (!e) {
                            var t = g("_cs_s")
                            if (t && t.indexOf(".T.") > -1)
                                var n = setInterval(function () {
                                    ;(t = g("_cs_s")) &&
                                        -1 === t.indexOf(".T.") &&
                                        (clearInterval(n), m())
                                }, 500)
                            else m()
                        }
                        setTimeout(function () {
                            p = _uxa.push(["isRecording"])
                        }, 500)
                    }
                    d("Feedback Displayed (All Surveys)", "true"),
                        _uxa.push([
                            "afterPageView",
                            function (e) {
                                o(function () {
                                    w(e)
                                }, c)
                            },
                        ]),
                        window.addEventListener("message", function (e) {
                            "https://secure.opinionlab.com" == e.origin &&
                                o(function () {
                                    var t = e.data,
                                        n = JSON.parse(t)
                                    if (
                                        "ClicktaleOpinionLab_Submitted" ===
                                            n.message ||
                                        "ContentsquareOpinionLab_Submitted" ===
                                            n.message
                                    ) {
                                        var o = n.ccid || ""
                                        d(
                                            "Feedback Submitted",
                                            "Survey ID : " + o,
                                            "etr",
                                            "cs_opinionlab=feedback_submitted_" +
                                                o
                                        )
                                        var i = n.responseId
                                        i && d("Response ID (" + o + ")", i)
                                        var a = n.overallRating
                                        a &&
                                            d(
                                                "Overall Rating (" + o + ")",
                                                parseInt(a)
                                            )
                                        var r = n.usabilityRating
                                        r &&
                                            d(
                                                "Usability Rating (" + o + ")",
                                                parseInt(r)
                                            )
                                        var s = n.designRating
                                        s &&
                                            d(
                                                "Design Rating (" + o + ")",
                                                parseInt(s)
                                            )
                                        var c = n.contentRating
                                        c &&
                                            d(
                                                "Content Rating (" + o + ")",
                                                parseInt(c)
                                            )
                                        for (
                                            var u = Object.keys(n), p = 1;
                                            p < u.length;
                                            p++
                                        )
                                            if (u[p].indexOf("answer") > -1) {
                                                var l = n[u[p]],
                                                    g = ""
                                                l &&
                                                    "0" != l &&
                                                    (isNaN(l) ||
                                                        (g = " Rating"),
                                                    d(
                                                        "Custom Answer " +
                                                            [p] +
                                                            g +
                                                            " (" +
                                                            o +
                                                            ")",
                                                        l
                                                    ))
                                            }
                                    }
                                }, c)
                        })
                } else {
                    function I(n) {
                        if (!e) {
                            function i(e) {
                                var t = e.data
                                t &&
                                    t.contentsquare_integration &&
                                    "opinion-lab" === t.vendor &&
                                    o(function () {
                                        const e = t.contentsquare_integration,
                                            o = e.split("."),
                                            i = Number(o[o.length - 1]),
                                            a = new Date(i).toUTCString()
                                        if (
                                            window.CS_CONF &&
                                            CS_CONF.allowSubdomains
                                        ) {
                                            const t = l()
                                            document.cookie =
                                                "_cs_s=" +
                                                S(e) +
                                                ";expires=" +
                                                a +
                                                ";domain=" +
                                                t +
                                                ";path=/"
                                        } else document.cookie = "_cs_s=" + S(e) + ";expires=" + a + ";path=/"
                                        I(n)
                                    }, c)
                            }
                            window.removeEventListener("message", i),
                                window.addEventListener("message", i)
                        }
                        function u() {
                            var e = g("_cs_id"),
                                o = g("_cs_c"),
                                i = g("_cs_optout"),
                                c = e + "~" + d + "~" + o + "~" + i
                            if ("M2PCT" === t) {
                                var u = CS_CONF.ptcPartition,
                                    l = CS_CONF.ptcGuid
                                localStorage.setItem("CTuserID", c),
                                    localStorage.setItem("CTpartition", u),
                                    localStorage.setItem("CTguid", l),
                                    sessionStorage.setItem("CTuserID", c),
                                    sessionStorage.setItem("CTpartition", u),
                                    sessionStorage.setItem("CTguid", l)
                            } else {
                                var m = ""
                                "M2PCS" === t
                                    ? (m = CS_CONF.ptcGuid)
                                    : (m = a(r, "tagid")) && (m = m.trim()),
                                    localStorage.setItem("CSid", c),
                                    localStorage.setItem("CStagID", m),
                                    sessionStorage.setItem("CSid", c),
                                    sessionStorage.setItem("CStagID", m)
                            }
                            if ((p = _uxa.push(["isRecording"]))) {
                                var S = (function (e, t, n) {
                                    e || (e = "missingFromDynamicSnippet")
                                    var o = t
                                    if ((isNaN(o) && (t = 0), n)) {
                                        var i = n.sessionKey.split("."),
                                            a = n.projectId,
                                            r = i[0],
                                            s = i[1],
                                            c = n.pageNumber,
                                            u = c - t
                                        return (
                                            t >= c && (u = c),
                                            0 === o && (u = 1),
                                            "https://app.contentsquare.com/quick-playback/index.html?pid=" +
                                                a +
                                                "&uu=" +
                                                r +
                                                "&sn=" +
                                                s +
                                                "&pvid=" +
                                                u +
                                                "&recordingType=cs&vd=" +
                                                e
                                        )
                                    }
                                })("ol", s, n)
                                S &&
                                    ("M2PCT" === t
                                        ? (localStorage.setItem(
                                              "CTrecordingLink",
                                              S
                                          ),
                                          sessionStorage.setItem(
                                              "CTrecordingLink",
                                              S
                                          ))
                                        : (localStorage.setItem(
                                              "CSreplayLink",
                                              S
                                          ),
                                          sessionStorage.setItem(
                                              "CSreplayLink",
                                              S
                                          )))
                            } else
                                "M2PCT" === t
                                    ? (localStorage.setItem(
                                          "CTrecordingLink",
                                          "Contensquare Not Recording"
                                      ),
                                      sessionStorage.setItem(
                                          "CTrecordingLink",
                                          "Contensquare Not Recording"
                                      ))
                                    : (localStorage.setItem(
                                          "CSreplayLink",
                                          "Contensquare Not Recording"
                                      ),
                                      sessionStorage.setItem(
                                          "CSreplayLink",
                                          "Contensquare Not Recording"
                                      ))
                        }
                        var d = g("_cs_s")
                        if (d && d.indexOf(".T.") > -1)
                            var m = setInterval(function () {
                                ;(d = g("_cs_s")) &&
                                    -1 === d.indexOf(".T.") &&
                                    (clearInterval(m), u())
                            }, 500)
                        else u()
                    }
                    function w(e) {
                        I(e)
                    }
                    _uxa.push([
                        "afterPageView",
                        function (e) {
                            o(function () {
                                w(e)
                            }, c)
                        },
                    ])
                }
            }, c)
    },
])
;(() => {
    "use strict"
    var t = {
            d: (s, i) => {
                for (var e in i)
                    t.o(i, e) &&
                        !t.o(s, e) &&
                        Object.defineProperty(s, e, {
                            enumerable: !0,
                            get: i[e],
                        })
            },
            o: (t, s) => Object.prototype.hasOwnProperty.call(t, s),
            r: (t) => {
                "undefined" != typeof Symbol &&
                    Symbol.toStringTag &&
                    Object.defineProperty(t, Symbol.toStringTag, {
                        value: "Module",
                    }),
                    Object.defineProperty(t, "__esModule", { value: !0 })
            },
        },
        s = {}
    t.r(s), t.d(s, { getRequestParameters: () => bh })
    const i = "cs-native-frame",
        e = {
            navigatorProperties: [
                { propertyName: "sendBeacon", binding: navigator },
            ],
            nodeProperties: [
                "childNodes",
                "parentNode",
                "nextSibling",
                "firstChild",
            ],
            elementProperties: ["shadowRoot"],
            elementPropertiesValues: [
                "matches",
                "mozMatchesSelector",
                "msMatchesSelector",
                "oMatchesSelector",
                "webkitMatchesSelector",
            ],
            eventProperties: ["target"],
            imageProperties: ["src"],
            constructors: {
                Date: "csDate",
                JSON: "csJSON",
                Array: "csArray",
                String: "csString",
                URL: "csURL",
                MutationObserver: "csMutationObserver",
                screen: "csScreen",
            },
        }
    function n(t, s, i) {
        const e = (function (t, s) {
            let i,
                e = t
            for (; e && !(i = Object.getOwnPropertyDescriptor(e, s)); )
                e = Object.getPrototypeOf(e)
            return i
        })(t, s)
        if (!e)
            return function () {
                return this[s]
            }
        switch (i) {
            case "get":
                return e.get
            case "set":
                return e.set
            case "value":
                return e.value
        }
    }
    function r(t) {
        Object.keys(e.constructors).forEach((s) => {
            window[e.constructors[s]] =
                t[s] instanceof Function && null == t[s].prototype
                    ? t[s].bind(window)
                    : t[s]
        }),
            (function (t) {
                ;(window.csquerySelector = {
                    1: t.Element.prototype.querySelector,
                    9: t.Document.prototype.querySelector,
                    11: t.DocumentFragment.prototype.querySelector,
                }),
                    (window.csquerySelectorAll = {
                        1: t.Element.prototype.querySelectorAll,
                        9: t.Document.prototype.querySelectorAll,
                        11: t.DocumentFragment.prototype.querySelectorAll,
                    })
            })(t),
            ("Prototype" in window ||
                /^((?!chrome|android).)*safari/i.test(navigator.userAgent)) &&
                (window.csMutationObserver =
                    window.WebKitMutationObserver || window.MutationObserver),
            h("csNode", e.nodeProperties, t.Node.prototype, "get"),
            h("csElement", e.elementProperties, t.Element.prototype, "get"),
            h(
                "csElement",
                e.elementPropertiesValues,
                t.Element.prototype,
                "value",
                !1
            ),
            h(
                "csHTMLImageElement",
                e.imageProperties,
                t.HTMLImageElement.prototype,
                "set"
            ),
            h("csEvent", e.eventProperties, t.Event.prototype, "get"),
            h("csNavigator", e.navigatorProperties, t.navigator, "value")
    }
    function h(t, s, i, e, r = !0) {
        s.forEach((s) => {
            const h = "string" != typeof s && "binding" in s,
                o = h ? s.propertyName : s
            ;(r || o in i) &&
                ((window[`${t + o}`] = n(i, o, e)),
                h && (window[`${t + o}`] = window[`${t + o}`].bind(s.binding)))
        })
    }
    function o(t, s) {
        ;(window.CSProtectnativeFunctionsLogs =
            window.CSProtectnativeFunctionsLogs || {}),
            (window.CSProtectnativeFunctionsLogs[t] = s)
    }
    if (
        !(function () {
            try {
                const t = (function () {
                    const t = document.createElement("iframe")
                    ;(t.id = i),
                        t.setAttribute("hidden", ""),
                        t.setAttribute("title", "Intentionally blank"),
                        t.setAttribute("sandbox", "allow-same-origin")
                    const s = document.createElement("cs-native-frame-holder")
                    if (
                        (s.setAttribute("hidden", ""),
                        document.body.appendChild(s),
                        Boolean(Element.prototype.attachShadow))
                    ) {
                        const i = s.attachShadow({ mode: "closed" })
                        return (
                            (i.innerHTML = t.outerHTML),
                            i.firstElementChild.contentWindow
                        )
                    }
                    return (
                        (s.innerHTML = t.outerHTML),
                        s.firstElementChild.contentWindow
                    )
                })()
                return (
                    !!t &&
                    ((window.CSPureWindow = t), r(window.CSPureWindow), !0)
                )
            } catch (t) {
                return (
                    o(
                        "Warning",
                        `failed to copy references from pure iframe: ${t.message}`
                    ),
                    !1
                )
            }
        })()
    )
        try {
            r(window)
        } catch (Tr) {
            o(
                "Critical",
                `failed to copy references from window: ${Tr.message}`
            )
        }
    function c(t) {
        return a(csString.prototype.toLowerCase.call(t.localName))
    }
    function a(t) {
        return csString.prototype.replace.call(
            t,
            /([#;&,.+*~':"!^$[\]()<=>|/%?@`{}\\ ])/g,
            "\\$1"
        )
    }
    function u(t) {
        return 1 === t.nodeType
    }
    function l(t) {
        return 3 === t.nodeType
    }
    function d(t) {
        return u(t) && "source" === t.localName
    }
    function f(t) {
        return null !== t && u(t) && "picture" === t.localName
    }
    function w(t) {
        return u(t) && "a" === t.localName
    }
    function p(t) {
        return (
            (function (t) {
                return u(t) && "link" === t.localName
            })(t) && -1 !== csString.prototype.indexOf.call(t.rel, "stylesheet")
        )
    }
    function m(t) {
        return u(t) && "img" === t.localName
    }
    function E(t) {
        return u(t) && "style" === t.localName
    }
    function y(t) {
        return u(t) && "input" === t.localName
    }
    function A(t) {
        return u(t) && "textarea" === t.localName
    }
    function g(t) {
        return u(t) && "script" === t.localName
    }
    function v(t) {
        return u(t) && "ownerSVGElement" in t
    }
    function _(t) {
        return u(t) && "select" === t.localName
    }
    function R(t) {
        switch (t.nodeType) {
            case 9:
            case 11:
                return !0
            default:
                return !1
        }
    }
    function S(t) {
        return 9 === t.nodeType
    }
    function T(t) {
        return R(t) && "host" in t && "mode" in t
    }
    function I(t) {
        return (
            u(t) &&
            !!csElementshadowRoot.apply(t) &&
            T(csElementshadowRoot.apply(t))
        )
    }
    const P = [
        "annotation-xml",
        "color-profile",
        "font-face",
        "font-face-src",
        "font-face-uri",
        "font-face-format",
        "font-face-name",
        "missing-glyph",
    ]
    const b = "detached"
    function V(t) {
        let s = t
        const i = [s]
        for (; null !== csNodeparentNode.apply(s); )
            (s = csNodeparentNode.apply(s)), csArray.prototype.push.call(i, s)
        return (
            C(s) && csArray.prototype.push.call(i, b),
            { ancestors: i, selectionRoot: s }
        )
    }
    function C(t) {
        return j.isValidElement(t)
    }
    const N =
            window.csElementmatches ||
            window.csElementmatchesSelector ||
            window.csElementmozMatchesSelector ||
            window.csElementmsMatchesSelector ||
            window.csElementoMatchesSelector ||
            window.csElementwebkitMatchesSelector,
        O = 9
    function k(t, s) {
        return !!s && csArray.prototype.some.call(s, (s) => N.call(t, s))
    }
    const $ = [/\d{4}/, /^ember\d+$/],
        L = "@",
        x = "data-cs-override-id",
        M = "data-cs-dynamic-id"
    function D(t, s, i, e) {
        const n = e.dynamicIdRegex || null,
            r = e.dynamicElementNameRegex
        let h = c(t)
        if (r) {
            r.test(t.localName) &&
                (h = csString.prototype.replace.call(h, r, `$1${L}`))
        }
        if (
            (function (t, s) {
                const i = U(t)
                return (
                    i &&
                    csString.prototype.match.call(i, /^[\w-]+$/) &&
                    z(x, i, s)
                )
            })(t, i)
        ) {
            const s = U(t)
            return {
                hasUniqueIdentifier: !0,
                elementSelector: `${h}[${x}="${s}"]`,
            }
        }
        const o = (function (t, s, i) {
            if (!i.uniqueAttributes) return { success: !1 }
            for (const e of i.uniqueAttributes) {
                const i = t.getAttribute(e)
                if (null !== i) {
                    if (z(e, i, s))
                        return {
                            attributeName: e,
                            attributeValue: i,
                            success: !0,
                        }
                }
            }
            return { success: !1 }
        })(t, i, e)
        if (o.success)
            return {
                hasUniqueIdentifier: !0,
                elementSelector: `${h}#UA[${o.attributeName}="${o.attributeValue}"]`,
            }
        const u = (function (t, s, i) {
            if (!i.uniqueCssSelectors) return
            for (const e of i.uniqueCssSelectors)
                if (N.call(t, e) && F(e, s)) return e
            return
        })(t, i, e)
        if (u)
            return {
                hasUniqueIdentifier: !0,
                elementSelector: `${h}#UCS[${u}]`,
            }
        const l = (function (t) {
            const s = t.getAttribute("id")
            return s ? a(s) : s
        })(t)
        if (
            (function (t, s, i, e) {
                return (
                    s &&
                    !(function (t) {
                        return null !== U(t)
                    })(t) &&
                    !(function (t, s, i) {
                        return (
                            t.hasAttribute(M) ||
                            (function (t, s) {
                                let i = !1
                                t && s && (i = s.test(t))
                                return (
                                    t &&
                                    (csArray.prototype.some.call($, (s) =>
                                        s.test(t)
                                    ) ||
                                        i)
                                )
                            })(s, i)
                        )
                    })(t, s, e) &&
                    (function (t, s) {
                        return t && z("id", t, s)
                    })(s, i)
                )
            })(t, l, i, n)
        )
            return { hasUniqueIdentifier: !0, elementSelector: `${h}#${l}` }
        const d = (function (t, s) {
            if (!s.reliableSelectors) return
            for (const i of s.reliableSelectors) if (N.call(t, i)) return i
            return
        })(t, e)
        if (d) {
            const i = (function (t, s, i) {
                if (t === b || t.nodeType === O) return 0
                let e = 0,
                    n = s.previousElementSibling
                for (; n; )
                    N.call(n, i) && (e += 1), (n = n.previousElementSibling)
                return e
            })(s, t, d)
            return {
                hasUniqueIdentifier: !1,
                elementSelector: `${h}[${d}](${i})`,
            }
        }
        const f = (function (t, s, i) {
            if (t === b || t.nodeType === O) return 0
            const e = i.dynamicElementNameRegex,
                n = !!(null == e ? void 0 : e.test(s.localName)),
                r = c(s)
            let h = 0,
                o = s.previousElementSibling
            for (; o; )
                (c(o) === r ||
                    (n && (null == e ? void 0 : e.test(o.localName)))) &&
                    !k(o, i.reliableSelectors) &&
                    (h += 1),
                    (o = o.previousElementSibling)
            return h
        })(s, t, e)
        return { hasUniqueIdentifier: !1, elementSelector: `${h}:eq(${f})` }
    }
    function U(t) {
        return t.getAttribute(x)
    }
    function z(t, s, i) {
        try {
            return (
                1 ===
                window.csquerySelectorAll[i.nodeType].call(i, `[${t}="${s}"]`)
                    .length
            )
        } catch (t) {
            if ("SyntaxError" !== t.name) throw t
        }
        return !1
    }
    function F(t, s) {
        try {
            return 1 === window.csquerySelectorAll[s.nodeType].call(s, t).length
        } catch (t) {
            if ("SyntaxError" !== t.name) throw t
        }
        return !1
    }
    const B = 11
    function H(t, s, i) {
        const e = csArray.prototype.shift.call(t)
        if (0 === t.length) return q(e, i)
        const n = e,
            r = t[0],
            { elementSelector: h, hasUniqueIdentifier: o } = D(n, r, s, i)
        if (!i.fullPath && o) {
            return `${q(t[t.length - 1], i)}${h}`
        }
        const c = H(t, s, i)
        return `${c ? `${c}>` : ""}${h}`
    }
    function q(t, s) {
        if (t === b) return "|detached|"
        if (t.host) {
            const { ancestors: i, selectionRoot: e } = V(t.host)
            return `${H(i, e, s)}|shadow-root|`
        }
        return t.nodeType === B ? "|fragment|" : ""
    }
    var j
    !(function (t) {
        function s(t) {
            return (
                !!t &&
                "localName" in t &&
                "getAttribute" in t &&
                "hasAttribute" in t &&
                "parentNode" in t
            )
        }
        function i(t) {
            return t && "jquery" in t && 1 === t.length ? t[0] : t
        }
        ;(t.INVALID_ELEMENT = "INVALID_ELEMENT"),
            (t.isValidElement = s),
            (t.getElementPath = function (
                e,
                n = { fullPath: !1, dynamicIdRegex: null }
            ) {
                const r = i(e)
                if (r === document) return ""
                if (!s(r)) return t.INVALID_ELEMENT
                const { ancestors: h, selectionRoot: o } = V(r)
                return H(h, o, n)
            }),
            (t.getElementPathAndFirstAnchorParent = function (
                e,
                n = { fullPath: !1, dynamicIdRegex: null }
            ) {
                const r = i(e)
                if (r === document) return { path: "", firstAnchorParent: null }
                if (!s(r))
                    return { path: t.INVALID_ELEMENT, firstAnchorParent: null }
                const {
                    firstAnchorParent: h,
                    ancestors: o,
                    selectionRoot: c,
                } = (function (t) {
                    let s = t
                    const i = [s]
                    let e = null
                    for (; null !== csNodeparentNode.apply(s); )
                        null === e && w(s) && (e = s),
                            csArray.prototype.push.call(
                                i,
                                csNodeparentNode.apply(s)
                            ),
                            (s = csNodeparentNode.apply(s))
                    return (
                        C(s) && csArray.prototype.push.call(i, b),
                        { firstAnchorParent: e, ancestors: i, selectionRoot: s }
                    )
                })(r)
                return { path: H(o, c, n), firstAnchorParent: h }
            })
    })(j || (j = {})),
        (window.CSPathComputation = window.CSPathComputation || j)
    const G = Number.MAX_SAFE_INTEGER || 9007199254740991
    function Z() {}
    function W(t, s) {
        return 0 === csString.prototype.lastIndexOf.call(t, s, 0)
    }
    const K = 34164e6,
        Y = {
            percentage: () => Math.floor(1e4 * Math.random()) / 100,
            boolean(t) {
                return this.percentage() < t
            },
            integer: (t = G) => Math.floor(Math.random() * t),
        },
        Q = "function" == typeof Symbol ? Symbol("json") : null
    const J = Q
        ? function (t) {
              if (t[Q]) return t[Q]
              if (csArray.isArray(t)) {
                  if (0 === t.length) return "[]"
                  let s = "[" + J(t[0])
                  for (let i = 1; i < t.length; i++) s += "," + J(t[i])
                  return (s += "]")
              }
              return (t[Q] = csJSON.stringify(t))
          }
        : csJSON.stringify
    class X {
        constructor(t) {
            var s, i
            ;(this.trackerDomain = t.trackerDomain),
                (this.loggerDomain = t.ed),
                (this.minLogLevel = t.logLevel),
                (this.projectId = t.projectId),
                (this.status = t.status),
                (this.hostnames = t.hostnames),
                (this.iframesTracking = !!t.iframesTracking),
                (this.crossDomainTracking = !!t.crossDomainTracking),
                (this.crossDomainSingleIframeTracking = !!t.crossDomainSingleIframeTracking),
                (this.consentRequired = !!t.consentRequired),
                (this.allowSubdomains = !!t.allowSubdomains),
                (this.visitorCookieTimeout = t.visitorCookieTimeout || K),
                (this.sampleRate = t.sampleRate),
                (this.replayRecordingRate = t.replayRecordingRate),
                (this.validationRate = t.validationRate),
                (this.lastTrackingDraw = t.lastTrackingDraw || 1),
                (this.useHttps = !0),
                (this.eMerchandisingEnabled = t.eMerchandisingEnabled),
                (this.mouseMoveHeatmapEnabled = t.mouseMoveHeatmapEnabled),
                (this.jsErrorsEnabled = t.jsErrorsEnabled),
                (this.apiErrors = {
                    enabled:
                        null !== (s = t.apiErrorsEnabled) && void 0 !== s
                            ? s
                            : 0,
                    ...t.apiErrors,
                }),
                (this.customErrors = {
                    enabled:
                        null !== (i = t.customErrorsEnabled) && void 0 !== i
                            ? i
                            : 0,
                    ...t.customErrors,
                }),
                (this.jsCustomErrorsEnabled = t.jsCustomErrorsEnabled),
                (this.triggerSessionReplayEnabled =
                    t.triggerSessionReplayEnabled),
                (this.triggerSessionReplayRegex = this.t(
                    t.triggerSessionReplayRegex
                )),
                (this.dynamicIdRegex = t.dynamicIdRegex
                    ? new RegExp(t.dynamicIdRegex)
                    : null),
                (this.whitelistedAttributes = t.whitelistedAttributes || []),
                (this.replayRecordingUnmaskedUrlRegex = this.t(
                    t.replayRecordingUnmaskedUrlRegex
                )),
                (this.replayRecordingMaskedUrlRegex = this.t(
                    t.replayRecordingMaskedUrlRegex
                )),
                (this.replayRecordingMaskedUrlRegexRules =
                    t.replayRecordingMaskedUrlRegexRules || null),
                (this.replayRecordingUnmaskedUrlRegexRules =
                    t.replayRecordingUnmaskedUrlRegexRules || null),
                (this.anonymisationMethod = t.anonymisationMethod || null),
                (this.tagDeploymentMode = t.tagDeploymentMode),
                (this.dualCollectionTagDomain =
                    t.dualCollectionTagDomain || null),
                (this.ptcDomain = t.ptcDomain || null),
                (this.ptcGuid = t.ptcGuid || null),
                (this.secureCookiesEnabled = !!t.secureCookiesEnabled),
                (this.ptcSha512 = t.ptcSha512 || null),
                (this.ptcSnapshotPath = t.ptcSnapshotPath || null),
                (this.emitDebugEvents = !1),
                (this.malkaQuotaServiceDomain =
                    t.malkaQuotaServiceDomain || null),
                (this.staticResourceManagerDomain =
                    t.staticResourceManagerDomain || null),
                (this.malkaRecordingDomain = t.malkaRecordingDomain || null),
                (this.textVisibilityEnabled = t.textVisibilityEnabled),
                (this.experimental = t.experimental || {}),
                (this.malkaEtrEnabled = !!t.malkaEtrEnabled),
                (this.malkaUrlEnabled = !!t.malkaUrlEnabled),
                (this.cookielessTrackingEnabled = t.cookielessTrackingEnabled),
                (this.customHashIdEnabled = !!t.customHashIdEnabled),
                (this.encryptionEnabled = !!t.recordingEncryptionEnabled),
                (this.encryptionPublicKey =
                    t.recordingEncryptionPublicKey || null),
                (this.pathComputationRules = t.pathComputationRules || {}),
                t.pathComputationRules &&
                    "" === t.pathComputationRules.dynamicElementNameRegex &&
                    (this.pathComputationRules.dynamicElementNameRegex = null),
                t.pathComputationRules &&
                    t.pathComputationRules.dynamicElementNameRegex &&
                    (this.pathComputationRules.dynamicElementNameRegex = new RegExp(
                        t.pathComputationRules.dynamicElementNameRegex
                    )),
                (this.asyncSerializerEnabled = !!t.asyncSerializerEnabled),
                (this.encryptionPublicKeyId = t.recordingEncryptionPublicKeyId),
                (this.pendingInactivityTimeout =
                    t.pendingInactivityTimeout || 5e3),
                (this.accessibilityEnabled = !!t.accessibilityEnabled),
                (this.useStaticResourceManager = !!t.useStaticResourceManager),
                t.taskSchedulerOptions &&
                    (this.taskSchedulerOptions = {
                        ...t.taskSchedulerOptions,
                        enabled: !!t.taskSchedulerOptions.enabled,
                    }),
                (this.uxaDomain = t.uxaDomain),
                (this.performanceTimingOptions = t.performanceTimingOptions),
                (this.replayConsentRequiredForSession = !!t.replayConsentRequiredForSession),
                (this.isWebView = !1),
                t.displayAdOptions &&
                    t.displayAdOptions.length &&
                    (this.displayAdOptions = t.displayAdOptions)
        }
        getTrackerUri() {
            return `${this.i()}://${this.trackerDomain}`
        }
        getRecordingUri() {
            return `${this.i()}://${this.malkaRecordingDomain}`
        }
        getQuotaServiceUri() {
            return `${this.i()}://${this.malkaQuotaServiceDomain}`
        }
        getLoggerUri() {
            return `${this.i()}://${this.loggerDomain}`
        }
        getStaticResourceManagerUri() {
            return `${this.i()}://${this.staticResourceManagerDomain}`
        }
        i() {
            return this.useHttps ? "https" : "http"
        }
        isProjectActive() {
            return 1 === this.status
        }
        processOptionOverrides(t) {
            t &&
                t.forEach &&
                t.forEach(([t, ...s]) => {
                    if ("setOption" === t) {
                        const [t, i] = s
                        this.h(t, i)
                    }
                })
        }
        h(t, s) {
            "trackerDomain" === t && (this.trackerDomain = s),
                "loggerDomain" === t && (this.loggerDomain = s),
                "malkaRecordingDomain" === t && (this.malkaRecordingDomain = s),
                "malkaQuotaServiceDomain" === t &&
                    (this.malkaQuotaServiceDomain = s),
                "staticResourceManagerDomain" === t &&
                    (this.staticResourceManagerDomain = s),
                "minLogLevel" === t && (this.minLogLevel = s),
                "useHttps" === t && (this.useHttps = !!s),
                "isWebView" === t && (this.isWebView = s)
        }
        t(t) {
            return t ? this.u(t) : null
        }
        getRequestParameters() {
            return { pid: `${this.projectId}` }
        }
        updateDynamicFields(t, s) {
            "emitDebugEvents" === t && (this.emitDebugEvents = s),
                "minLogLevel" === t && (this.minLogLevel = s)
        }
        u(t) {
            try {
                const s = /^\/(.*)\/([gim]*)$/.exec(t)
                if (s) {
                    const [, t, i] = s
                    return new RegExp(`^${t}$`, i)
                }
                return new RegExp(`^${t}$`)
            } catch (t) {
                return null
            }
        }
        isHeaderCollectionActive() {
            var t, s
            return (
                this.apiErrors.collectStandardHeaders ||
                !!(null === (t = this.apiErrors.validCustomHeaders) ||
                void 0 === t
                    ? void 0
                    : t.length) ||
                !!(null === (s = this.apiErrors.plainCustomHeaders) ||
                void 0 === s
                    ? void 0
                    : s.length)
            )
        }
    }
    class tt {
        constructor(t, s) {
            ;(this.A = t), (this._ = s)
        }
        init() {
            ;(this.R = this.A !== this.A.top),
                (this.S = this._.isWebView && this.A === this.A.top),
                (this._.iframesTracking && this.R) || this.S
                    ? (this.T = !1)
                    : (this.T = !0)
        }
        isInIframeContext() {
            return this.R
        }
        isTopWindowTracker() {
            return this.T
        }
        isInWebViewContext() {
            return this.S
        }
    }
    var st, it
    !(function (t) {
        ;(t.debug = "debug"),
            (t.warn = "warn"),
            (t.error = "error"),
            (t.critical = "critical")
    })(st || (st = {})),
        (function (t) {
            t.toQuery = function (t) {
                return csArray.prototype.join.call(
                    csArray.prototype.map.call(
                        Object.keys(t),
                        (s) =>
                            `${encodeURIComponent(s)}=${encodeURIComponent(
                                t[s]
                            )}`
                    ),
                    "&"
                )
            }
        })(it || (it = {}))
    class et {
        constructor(t, s) {
            ;(this.domainUri = t),
                (this.path = s),
                (this.beforeRequestCallbacks = []),
                (this.afterRequestCallbacks = [])
        }
        setRequestParametersProviders(...t) {
            this.requestParametersProviders = t
        }
        before(t) {
            csArray.prototype.push.call(this.beforeRequestCallbacks, t)
        }
        after(t) {
            csArray.prototype.push.call(this.afterRequestCallbacks, t)
        }
        retrieveParameters() {
            return this.requestParametersProviders
                ? csArray.prototype.reduce.call(
                      csArray.prototype.map.call(
                          this.requestParametersProviders,
                          (t) => t.getRequestParameters()
                      ),
                      (t, s) => ({ ...t, ...s })
                  )
                : {}
        }
    }
    class nt extends et {
        constructor(t, s) {
            super(t, s)
        }
        send() {
            csArray.prototype.forEach.call(this.beforeRequestCallbacks, (t) =>
                t()
            )
            const t = this.retrieveParameters()
            this.I(t)
            const s = it.toQuery(t)
            this.P(s),
                csArray.prototype.forEach.call(
                    this.afterRequestCallbacks,
                    (t) => t()
                )
        }
        P(t) {
            const s = new window.Image(1, 1)
            ;(s.onload = Z),
                (s.onerror = Z),
                csHTMLImageElementsrc.call(
                    s,
                    `${this.domainUri}${this.path ? `/${this.path}` : ""}?${t}`
                )
        }
        I(t) {
            t.r = csString.prototype.slice.call(`${Math.random()}`, 2, 8)
        }
    }
    class rt {
        constructor(t, s) {
            ;(this.V = t), (this.C = s)
        }
        init() {
            ;(this.N = new nt(this.V.getLoggerUri())),
                this.N.setRequestParametersProviders(this, this.C)
        }
        send(t) {
            ;(this.O = t), this.N.send()
        }
        getRequestParameters() {
            return {
                a: this.O.app,
                l: this.O.level,
                m: this.O.message,
                s: this.O.stacktrace,
            }
        }
    }
    const ht = /[a-zA-Z0-9._%+-]+(?:@|%40|%2540)[a-zA-Z0-9.%-_]+((?:\.|%2[eE])[a-zA-Z0-9-]+)+/g,
        ot = /[a-zA-Z0-9+_-](?:@|%40|%2540)/,
        ct = "([-A-Za-z0-9+/=_]|=[^=]|={3,})+",
        at = new RegExp(`(ey${ct}\\.ey${ct}\\.${ct})`, "g"),
        ut = /[0-9]{4}/,
        lt = /(^|[^a-zA-Z0-9*.,-])([45*][0-9*]{3}([ -]?)[0-9*]{4}\3[0-9*]{4}\3[0-9*]{4})($|[^a-zA-Z0-9*.,-])/g
    class dt {
        anonymizePII(t) {
            return "string" == typeof t && (t = this.anonymizeEmail(t)), t
        }
        anonymizeEmail(t) {
            return ot.test(t)
                ? csString.prototype.replace.call(t, ht, "CS_ANONYMIZED_EMAIL")
                : t
        }
        anonymizeCreditCard(t) {
            return ut.test(t)
                ? csString.prototype.replace.call(t, lt, (t, s, i, e, n) => {
                      if (-1 === csString.prototype.indexOf.call(i, "*")) {
                          const s = e.length
                              ? csArray.prototype.join.call(
                                    csString.prototype.split.call(i, e),
                                    ""
                                )
                              : i
                          if (!this.k(s)) return t
                      }
                      return `${s}CS_ANONYMIZED_PII${n}`
                  })
                : t
        }
        k(t) {
            const s = parseInt(t[t.length - 1])
            let i = 0
            for (let s = t.length - 2; s >= 0; s--) {
                let e = parseInt(t[s])
                s % 2 == 0 && (e *= 2), (i += Math.floor(e / 10) + (e % 10))
            }
            return 10 - (i % 10) === s
        }
        anonymizeJwt(t) {
            return csString.prototype.replace.call(t, at, "CS_ANONYMIZED_JWT")
        }
        anonymizeFields(t, s) {
            return (
                csArray.prototype.forEach.call(s, (s) => {
                    t[s] = this.anonymizeEmail(t[s])
                }),
                t
            )
        }
    }
    const ft = "13.89.2"
    function wt() {
        return { v: ft }
    }
    const pt = {
        now: () =>
            void 0 !== window.performance && window.performance.now
                ? window.performance.timing.navigationStart +
                  Math.round(window.performance.now())
                : csDate.now(),
    }
    function mt() {
        return Math.floor(pt.now() / 1e3)
    }
    function Et(t, s) {
        return 0 === csString.prototype.lastIndexOf.call(t, s, 0)
    }
    function yt(t, s) {
        return -1 !== csString.prototype.indexOf.call(t, s, t.length - s.length)
    }
    class At {
        constructor(t, s) {
            ;(this.$ = t), (this.L = s)
        }
        getRequestParameters() {
            return {
                d: `${pt.now()}`,
                p: this.L.anonymizePII(window.location.href),
                ...this.$.getRequestParameters(),
                ...wt(),
            }
        }
    }
    function gt(t) {
        return (
            St(t) && ("number" == typeof t || t instanceof Number) && !isNaN(t)
        )
    }
    function vt(t) {
        return t === parseInt(t, 10)
    }
    function _t(t) {
        return St(t) && ("string" == typeof t || t instanceof csString)
    }
    function Rt(t) {
        return "object" == typeof t
    }
    function St(t) {
        return void 0 !== t
    }
    function Tt(t) {
        return St(t) && null !== t
    }
    function It(t) {
        return "function" == typeof t
    }
    function Pt(t) {
        return t instanceof Element
    }
    function bt(t) {
        return t instanceof Error
    }
    const Vt = "snippet-",
        Ct = "implementation-snippet-"
    var Nt, Ot
    !(function (t) {
        ;(t.IMPLEMENTATION = "implementation"), (t.DYNAMIC = "dynamic")
    })(Nt || (Nt = {})),
        (function (t) {
            ;(t[(t.debug = 0)] = "debug"),
                (t[(t.warn = 1)] = "warn"),
                (t[(t.error = 2)] = "error"),
                (t[(t.critical = 3)] = "critical")
        })(Ot || (Ot = {}))
    class kt {
        constructor(t, s, i) {
            ;(this.M = s),
                (this.L = new dt()),
                (this.D = Ot[st.warn]),
                (this.D = Ot[t.minLogLevel || st.warn]),
                (this.N = i || new rt(t, new At(t, this.L))),
                (this.U = {
                    [st.debug]: [],
                    [st.warn]: [],
                    [st.error]: [],
                    [st.critical]: [],
                }),
                (this.F = { implementation: {}, dynamic: {} }),
                this.N.init()
        }
        send(t, s = "", i = st.warn) {
            if (!this.B(i, s)) return
            csArray.prototype.push.call(this.U[i], s || "")
            const e = {
                message: this.H(t, s),
                stacktrace: this.q(t),
                app: "uxa",
                level: i,
            }
            this.N.send(e)
        }
        H(t, s) {
            let i = bt(t) ? this.L.anonymizePII(t.message || t.toString()) : t
            return s && (i += ` ErrorCode: ${s}`), i
        }
        q(t) {
            return bt(t)
                ? `${t.stack || "No stacktrace"} ${this.j()}`
                : this.j()
        }
        j() {
            const t = this.M.getVisitorService(),
                s = null == t ? void 0 : t.getVisitor()
            if (!s) return "No context"
            const i = this.M.getSessionService(),
                e = i && i.getSession(),
                n = {
                    userId: s.id,
                    sessionNumber: s.visitsCount,
                    pageNumber: e && e.pageNumber,
                }
            return csJSON.stringify(n)
        }
        B(t, s) {
            if (Ot[t] < this.D) return !1
            if (
                0 ===
                (null == s ? void 0 : csString.prototype.indexOf.call(s, Ct, 0))
            )
                return this.G(s, Nt.IMPLEMENTATION)
            if (
                0 ===
                (null == s ? void 0 : csString.prototype.indexOf.call(s, Vt, 0))
            )
                return this.G(s, Nt.DYNAMIC)
            const i = this.U[t]
            return (
                !(i.length >= 5) &&
                (!s || !csArray.prototype.some.call(i, (t) => t === s))
            )
        }
        G(t, s) {
            return t in this.F[s]
                ? !(this.F[s][t] >= 5) && ((this.F[s][t] += 1), !0)
                : ((this.F[s][t] = 1), !0)
        }
    }
    const $t = "undefined" == typeof window,
        Lt =
            "undefined" != typeof globalThis
                ? globalThis
                : "undefined" != typeof window
                ? window
                : process
    function xt(t, s) {
        return void 0 !== Lt[t] ? Lt[t] : s
    }
    const Mt = !$t && document.createElement("a"),
        Dt = /(:443|:80)$/
    function Ut(t) {
        return Mt ? ((Mt.href = t), Mt.href) : ""
    }
    function zt(t) {
        const s = Ht(t)
        return null === s ? "" : decodeURIComponent(s.hostname)
    }
    function Ft(t, s) {
        return csArray.prototype.some.call(
            s,
            (s) => yt(t, `.${s}`) || t === s || "" === s
        )
    }
    function Bt(t) {
        return csString.prototype.replace.call(t, Dt, "")
    }
    function Ht(t) {
        return Mt && (Et(t, "http://") || Et(t, "https://"))
            ? ((Mt.href = t),
              {
                  hash: Mt.hash,
                  host: Bt(Mt.host),
                  hostname: Mt.hostname,
                  href: Mt.href,
                  origin: Mt.origin
                      ? Mt.origin
                      : Bt(`${Mt.protocol}//${Mt.host}`),
                  pathname: ((s = Mt.pathname), "/" === s[0] ? s : `/${s}`),
                  port: Mt.port,
                  protocol: Mt.protocol,
                  search: Mt.search,
              })
            : null
        var s
    }
    const qt = "CS_IFRAME_MESSAGE"
    var jt, Gt, Zt, Wt
    !(function (t) {
        ;(t.AfterPageView = "afterPageView"),
            (t.GetSessionKey = "getSessionKey")
    })(jt || (jt = {})),
        (function (t) {
            ;(t.Parent = "parent"), (t.Child = "child")
        })(Gt || (Gt = {})),
        (function (t) {
            ;(t.Discovery = "discovery"),
                (t.Stop = "stop"),
                (t.RecordingStatus = "recordingStatus"),
                (t.RecordingEvent = "recordingEvent"),
                (t.EndOfBufferedMessages = "endOfBufferedMessages"),
                (t.ChildLogMessage = "childLogMessage"),
                (t.AnalysisEvent = "analysisEvent"),
                (t.JavascriptError = "javascriptError"),
                (t.ApiError = "apiError"),
                (t.Assets = "assets"),
                (t.DetailedApiError = "detailedApiError"),
                (t.EmerchandisingMessage = "emerchandisingMessage"),
                (t.Commands = "commands"),
                (t.IntegrationCallback = "integrationCallback"),
                (t.StaticResource = "staticResource"),
                (t.TrackingContextResultMessage =
                    "trackingContextResultMessage"),
                (t.TrackingContextRequestMessage =
                    "trackingContextRequestMessage"),
                (t.CustomError = "customError")
        })(Zt || (Zt = {})),
        (function (t) {
            ;(t.buildBaseMessage = function (t, s, i, e) {
                const n = { type: t, from: s, pid: i, signature: qt }
                return void 0 !== e && e >= 0 && (n.id = e), n
            }),
                (t.isMessageValid = function (t, s, i, e) {
                    const n = zt(t.origin)
                    return (
                        !!t.data &&
                        !!t.data.type &&
                        t.data.signature === qt &&
                        t.data.from === s &&
                        t.data.pid === i &&
                        Ft(n, e)
                    )
                }),
                (t.sendPostMessage = function (t, s, i, e) {
                    e ? t.postMessage(i, s, e) : t.postMessage(i, s)
                }),
                (t.getNewChannelMessage = function () {
                    return new MessageChannel()
                }),
                (t.sendChannelMessage = function (t, s) {
                    t.postMessage(s)
                }),
                (t.closeChannelPort = function (t) {
                    t.close()
                })
        })(Wt || (Wt = {}))
    class Kt {
        constructor(t) {
            this.$ = t
        }
        send(t, s = "", i = st.warn) {
            const e = { message: t, errorCode: s, level: i },
                n = Wt.buildBaseMessage(
                    Zt.ChildLogMessage,
                    Gt.Child,
                    this.$.projectId
                )
            ;(n.content = e), Wt.sendPostMessage(window.parent, "*", n)
        }
    }
    class Yt {
        setContext(t, s) {
            ;(this.Z = t), (this.W = s)
        }
        getVisitorService() {
            return this.Z
        }
        getSessionService() {
            return this.W
        }
    }
    const Qt = ["t.contentsquare.net", "clicktale"]
    window.addEventListener("error", (t) => {
        "string" != typeof t.filename ||
            !csArray.prototype.some.call(
                Qt,
                (s) => csString.prototype.indexOf.call(t.filename, s) > -1
            ) ||
            (csString.prototype.indexOf.call(t.filename, "blob") > -1 &&
                (null == t.message
                    ? void 0
                    : csString.prototype.indexOf.call(
                          t.message,
                          "importScripts"
                      )) > -1) ||
            Jt.error(
                `Uncaught jsError: filename: ${t.filename} - lineno: ${t.lineno} - colno: ${t.colno} - message: ${t.message} `
            )
    })
    class Jt {
        constructor() {}
        static whiteListFilename(t) {
            csArray.prototype.push.call(Qt, t)
        }
        static setStrategy(t) {
            Jt.K = t
        }
        static computeIsActive(t) {
            ;(Jt.Y = Y.boolean(t)), Jt.Y ? (Jt.J = Y.boolean(10)) : (Jt.J = !1)
        }
        static isLoggingActive() {
            return Jt.Y
        }
        static getStrategy() {
            return Jt.K
        }
        static debug(t, s = "") {
            Jt.Y && this.K.send(t, s, st.debug)
        }
        static warn(t, s = "") {
            Jt.Y && this.K.send(t, s, st.warn)
        }
        static error(t, s = "") {
            Jt.Y && this.K.send(t, s, st.error)
        }
        static critical(t, s = "") {
            Jt.Y && this.K.send(t, s, st.critical)
        }
        static tryToExecute(t, s) {
            return (...i) => {
                try {
                    const e = s(...i)
                    return St(window.Promise) && e instanceof window.Promise
                        ? e.then(
                              (t) => t,
                              (s) => this.error(s, t)
                          )
                        : e
                } catch (s) {
                    try {
                        this.error(s, t)
                    } catch {}
                }
            }
        }
        static isPerfLoggingActive() {
            return Jt.J
        }
    }
    ;(Jt.Y = !1), (Jt.J = !1)
    let Xt = {
        debug(...t) {},
        warn(...t) {},
        error(...t) {},
        critical(...t) {},
    }
    const ts = (t) => (s, i, e) => {
        const n = (null == i ? void 0 : i.toString()) || "",
            r = t || `${s.constructor && s.constructor.name}.${n}`
        if (e) {
            const t = e.value
            e.value = function (...s) {
                return (function (t, s) {
                    return (...i) => {
                        try {
                            const e = s(...i)
                            return St(window.Promise) &&
                                e instanceof window.Promise
                                ? e.then(
                                      (t) => t,
                                      (s) => Xt.error(s, t)
                                  )
                                : e
                        } catch (s) {
                            try {
                                Xt.error(s, t)
                            } catch {}
                        }
                    }
                })(
                    r,
                    t.bind(this)
                )(...s)
            }
        }
    }
    function ss(t, s, i, e) {
        var n,
            r = arguments.length,
            h =
                r < 3
                    ? s
                    : null === e
                    ? (e = Object.getOwnPropertyDescriptor(s, i))
                    : e
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            h = Reflect.decorate(t, s, i, e)
        else
            for (var o = t.length - 1; o >= 0; o--)
                (n = t[o]) &&
                    (h = (r < 3 ? n(h) : r > 3 ? n(s, i, h) : n(s, i)) || h)
        return r > 3 && h && Object.defineProperty(s, i, h), h
    }
    Object.create
    var is, es, ns, rs
    Object.create
    !(function (t) {
        function s(t) {
            const s = new RegExp(`(^|;)[ ]*${t}=([^;]*)`).exec(document.cookie)
            return s ? decodeURIComponent(s[2]) : null
        }
        function i(s, i, n, r, h, o) {
            const c = encodeURIComponent(`${i}`),
                a = n === t.CURRENT_DOMAIN ? void 0 : n,
                u = e(r)
            let l = `${s}=${c}${u ? `;expires=${u.toUTCString()}` : ""};path=/${
                Tt(a) ? `;domain=${a}` : ""
            }`
            return (
                St(h) && h !== ns.NotSet && (l = `${l};SameSite=${h}`),
                St(o) && o === rs.Yes && (l = `${l};Secure`),
                (document.cookie = l),
                !0
            )
        }
        function e(t) {
            return gt(t) ? new csDate(pt.now() + t) : t
        }
        function n(t, e) {
            s(t) && i(t, "", e, new csDate(0)),
                s(t) && i(t, "", e, new csDate(0), ns.None, rs.Yes)
        }
        ;(t.CURRENT_DOMAIN = "CURRENT_DOMAIN"),
            (t.get = s),
            (t.set = i),
            (t.toExpireDate = e),
            (t.remove = n),
            (t.isCookiePresent = function () {
                return document.cookie.length > 0
            }),
            (t.getRootDomain = function (t, e) {
                const r = "_cs_root-domain"
                let h = s(r)
                if (null !== h && "1" !== h) return h
                const o = csString.prototype.split.call(
                    window.location.hostname,
                    "."
                )
                let c = csArray.prototype.pop.call(o)
                for (; o.length && (null === h || "1" === h); )
                    (c = csArray.prototype.join.call(
                        [csArray.prototype.pop.call(o), c],
                        "."
                    )),
                        i(r, c, c, void 0, t, e),
                        (h = s(r))
                return n(r, c), c
            })
    })(is || (is = {})),
        (function (t) {
            t.browserIsSafariV12 = function () {
                return (
                    window.navigator.vendor &&
                    csString.prototype.indexOf.call(
                        window.navigator.vendor,
                        "Apple"
                    ) > -1 &&
                    window.navigator.appVersion &&
                    csString.prototype.indexOf.call(
                        window.navigator.appVersion,
                        "Version/12."
                    ) > -1
                )
            }
        })(es || (es = {})),
        (function (t) {
            ;(t.None = "None"), (t.Lax = "Lax"), (t.NotSet = "X")
        })(ns || (ns = {})),
        (function (t) {
            ;(t[(t.Yes = 1)] = "Yes"), (t[(t.No = 0)] = "No")
        })(rs || (rs = {}))
    class hs {
        constructor(t, s, i) {
            ;(this.$ = t),
                (this.X = s),
                (this.tt = i),
                (this.st = !1),
                (this.it = ns.NotSet),
                (this.et = rs.No)
        }
        getSameSiteFlag() {
            return this.it
        }
        getSecureFlag() {
            return this.et
        }
        getDomain() {
            return this.nt
        }
        getRootDomain() {
            return this.ht
        }
        init() {
            if (this.$.cookielessTrackingEnabled) return
            const t = this.ot(),
                s = this.ut()
            ;(this.st = this.lt(t, s)),
                this.st
                    ? ((this.it = t), (this.et = s))
                    : this.$.secureCookiesEnabled &&
                      "https:" === this.X.getUrlProtocol() &&
                      (this.et = rs.Yes),
                (this.ht = this.ft()),
                (this.nt = this.wt(this.ht))
        }
        lt(t, s) {
            return (
                !es.browserIsSafariV12() &&
                (is.set(
                    hs.COOKIE_TEST_FOR_SAME_SITE,
                    "Test same site",
                    hs.CURRENT_DOMAIN,
                    void 0,
                    t,
                    s
                ),
                !!is.get(hs.COOKIE_TEST_FOR_SAME_SITE) &&
                    (is.remove(hs.COOKIE_TEST_FOR_SAME_SITE, hs.CURRENT_DOMAIN),
                    !0))
            )
        }
        ot() {
            return "http:" === this.X.getUrlProtocol()
                ? ns.Lax
                : this.tt.isSameSiteNoneSecureNeeded() ||
                  this.$.crossDomainTracking
                ? ns.None
                : ns.Lax
        }
        ut() {
            return "http:" === this.X.getUrlProtocol()
                ? rs.No
                : this.$.secureCookiesEnabled ||
                  this.$.crossDomainTracking ||
                  this.tt.isSameSiteNoneSecureNeeded()
                ? rs.Yes
                : rs.No
        }
        isSameSiteSupported() {
            return this.st
        }
        set(t, s, i) {
            const e = is.toExpireDate(i)
            is.set(
                t,
                s,
                this.nt,
                e,
                this.getSameSiteFlag(),
                this.getSecureFlag()
            )
        }
        get(t) {
            const s = new RegExp(`(^|;)[ ]*${t}=([^;]*)`).exec(document.cookie)
            return s ? decodeURIComponent(s[2]) : null
        }
        delete(t, s) {
            const i = s || this.nt
            is.remove(t, i)
        }
        ft() {
            const t =
                    this.tt.isSameSiteNoneSecureNeeded() &&
                    this.isSameSiteSupported(),
                s = t ? ns.None : void 0,
                i = t ? rs.Yes : void 0
            return is.getRootDomain(s, i)
        }
        wt(t) {
            return this.$.allowSubdomains ? t : is.CURRENT_DOMAIN
        }
    }
    ;(hs.CURRENT_DOMAIN = "CURRENT_DOMAIN"),
        (hs.COOKIE_TEST_FOR_SAME_SITE = "_cs_same_site")
    const os = "_cs_t"
    class cs {
        constructor(t, s) {
            ;(this.Et = t), (this.$ = s), (this.yt = !1), (this.At = !1)
        }
        init() {
            if (
                !this.$.cookielessTrackingEnabled &&
                this.Et.isTopWindowTracker() &&
                "cookie" in document
            ) {
                if (!this.Et.isInIframeContext() && is.isCookiePresent())
                    return (this.yt = !0), void (this.At = !1)
                if ((is.set(os, "1", is.CURRENT_DOMAIN), null !== is.get(os)))
                    return (
                        (this.yt = !0),
                        (this.At = !1),
                        void is.remove(os, is.CURRENT_DOMAIN)
                    )
                is.set(os, "1", is.CURRENT_DOMAIN, void 0, ns.None, rs.Yes),
                    null !== is.get(os) &&
                        ((this.yt = !0),
                        (this.At = !0),
                        is.remove(os, is.CURRENT_DOMAIN))
            }
        }
        areCookiesEnabled() {
            return this.yt
        }
        isSameSiteNoneSecureNeeded() {
            return this.At
        }
    }
    class as {
        constructor(t, s) {
            ;(this.$ = t), (this.tt = s)
        }
        canTrack() {
            return (
                this.$.isProjectActive() && this.gt() && this.vt() && this._t()
            )
        }
        canTrackInChild() {
            return (
                this.$.isProjectActive() &&
                this.Rt() &&
                (this.vt() || this.St())
            )
        }
        _t() {
            return this.$.cookielessTrackingEnabled
                ? (function () {
                      const t = "CSSessionStorageTest"
                      try {
                          return (
                              sessionStorage.setItem(t, t),
                              sessionStorage.getItem(t) === t &&
                                  (sessionStorage.removeItem(t), !0)
                          )
                      } catch {
                          return !1
                      }
                  })()
                : this.tt.areCookiesEnabled()
        }
        vt() {
            return Ft(window.location.hostname, this.$.hostnames)
        }
        gt() {
            return !this.Tt() && this.It()
        }
        Rt() {
            return !this.Tt() && this.Pt()
        }
        St() {
            return (
                W(window.location.href, "about:srcdoc") &&
                "about:" === window.location.protocol &&
                "" === window.location.hostname
            )
        }
        Tt() {
            return (
                "visibilityState" in document &&
                "prerender" === document.visibilityState
            )
        }
        It() {
            return this.bt() && !!window.localStorage
        }
        Pt() {
            return this.bt()
        }
        bt() {
            return (
                "pageXOffset" in window &&
                "pageYOffset" in window &&
                "onpagehide" in window &&
                "JSON" in window &&
                "parse" in window.csJSON &&
                "stringify" in window.csJSON &&
                "addEventListener" in window &&
                "removeEventListener" in window &&
                "Node" in window &&
                "filter" in csArray.prototype &&
                "forEach" in csArray.prototype &&
                "querySelectorAll" in document &&
                "now" in csDate &&
                "keys" in Object &&
                "performance" in window &&
                "Map" in window &&
                "Set" in window
            )
        }
    }
    class us {
        constructor(t) {
            ;(this.Vt = !1),
                (this.Ct = new Map()),
                (this.Nt = new Map()),
                (this.Ot = new Map()),
                (this.kt = "CS_WORKER_SIGNATURE")
            const s = `\n    const algorithm = ${
                t.algorithm
            };\n    const compressor = (${t.getCompressorSourceCode()})();\n    (()=>{"use strict";var e,t;!function(e){e.UNCOMPRESSED="0",e.GZIP="2"}(e||(e={}));class s{constructor(e){this.queryParams={},this.headers={},this.handleRecoveredRequests=e=>{for(const t of e){const{metadata:e,events:s}=t;this.send(s,e)}},this.endpoint=e.endpoint,this.compressionOpts=e.compressionOpts,this.recoveryStorage=e.recoveryStorage,this.recoveryStorage&&this.recoveryStorage.recover(this.handleRecoveredRequests)}setQueryParams(e){Object.keys(e).forEach((t=>{this.queryParams[t]=e[t]}))}removeQueryParams(e){e?e.forEach((e=>{delete this.queryParams[e]})):this.queryParams={}}send(t,s){const r=s||{...this.queryParams},a=!("ct"in r),o="string"!=typeof t&&!this.isArrayBuffer(t);"ct"in r||(this.compressionOpts&&a?r.ct=this.compressionOpts.compressionType:r.ct=e.UNCOMPRESSED);const i=o?JSON.stringify(t):t,n=Object.keys(r).map((e=>\`\${encodeURIComponent(e)}=\${encodeURIComponent(r[e])}\`)).join("&"),h=\`\${this.endpoint}?\${n}\`;this.compressionOpts&&a&&"string"==typeof i?this.compressionOpts.compressor(i,this.compressionOpts.compressionOutputType,(e=>this.doSend(h,r,e))):this.doSend(h,r,i)}onLoad(e){this.onLoadCallback=e}onError(e){this.onErrorCallback=e}onTimeout(e,t){this.onTimeoutCallback=e,this.timeout=t}abort(){this.abortCurrentXhrCall&&this.abortCurrentXhrCall()}setRequestHeader(e,t){this.headers[e]=t}getQueryParams(){return this.queryParams}isArrayBuffer(e){return e&&void 0!==e.byteLength}doSend(e,t,s){const r=new XMLHttpRequest,a=Object.keys(t).map((e=>\`\${encodeURIComponent(e)}=\${encodeURIComponent(t[e])}\`)).join("&");r.open("POST",e),r.onload=()=>{if(this.recoveryStorage&&this.recoveryStorage.recover(this.handleRecoveredRequests),this.onLoadCallback){const e={params:t,responseText:r.responseText,status:r.status};this.onLoadCallback(e)}},r.onerror=()=>{this.recoveryStorage&&this.recoveryStorage.save({key:a,metadata:t,events:s}),this.onErrorCallback&&this.onErrorCallback({params:t})},this.timeout&&this.onTimeoutCallback&&(r.timeout=this.timeout,r.ontimeout=()=>{this.onTimeoutCallback()}),this.abortCurrentXhrCall=()=>r.abort(),Object.keys(this.headers).forEach((e=>{r.setRequestHeader(e,this.headers[e])})),r.send(s)}}class r{constructor(e){this.maxStoredBytes=e,this.storageBytesUsed=0}addString(e){this.storageBytesUsed+=2*e.length}addArrayBuffer(e){this.storageBytesUsed+=e.byteLength}isThresholdReached(){return this.storageBytesUsed>this.maxStoredBytes}reset(){this.storageBytesUsed=0}}class a{constructor(e){this.ramStorage={},this.byteSizeCounter=new r(e)}save({key:e,metadata:t,events:s}){this.byteSizeCounter.isThresholdReached()||(this.byteSizeCounter.addString(e),"string"==typeof s?this.byteSizeCounter.addString(s):this.byteSizeCounter.addArrayBuffer(s),this.byteSizeCounter.isThresholdReached()||(this.ramStorage[e]={metadata:t,events:s}))}recover(e){const t=[];this.getStorageKeys().forEach((e=>{const s=this.ramStorage[e];void 0!==s&&(delete s.metadata.datatype,t.push(s),this.removeItem(e))})),0!==t.length&&(e(t),this.byteSizeCounter.reset())}getStorageKeys(){return Object.keys(this.ramStorage)}removeItem(e){delete this.ramStorage[e]}}!function(e){e[e.NOT_STARTED=0]="NOT_STARTED",e[e.OPEN_IN_PROGRESS=1]="OPEN_IN_PROGRESS",e[e.OPEN_FAILED=2]="OPEN_FAILED",e[e.READY=3]="READY"}(t||(t={}));class o{constructor(e,s,a){this.storageName=e,this.onOpenError=a,this.cacheState=t.NOT_STARTED,this.toBeSavedBuffer=[],this.recoveryInProgress=0,this.origin=self.origin,this.context="object"==typeof window?"":"worker-",this.byteSizeCounter=new r(s),this.init()}async init(){await this.openCache(),this.cacheState===t.READY?this.flushToBeSavedBuffer():this.onOpenError(this.toBeSavedBuffer)}flushToBeSavedBuffer(){this.toBeSavedBuffer.forEach((e=>{this.save(e)})),this.toBeSavedBuffer=[]}async save(e){try{if(this.cacheState===t.OPEN_IN_PROGRESS)return void this.toBeSavedBuffer.push(e);if(this.cacheState!==t.READY)return;if(this.byteSizeCounter.isThresholdReached())return;const{key:s,metadata:r,events:a}=e;if(this.byteSizeCounter.addString(s),"string"==typeof a?this.byteSizeCounter.addString(a):this.byteSizeCounter.addArrayBuffer(a),this.byteSizeCounter.isThresholdReached())return;await this.cache.put(\`\${this.origin}/\${s}\`,new Response(a,{headers:r}))}catch{}}async recover(e){(this.cache||(await this.openCache(),this.cacheState===t.READY))&&this.doRecover(e)}async openCache(){try{this.cacheState=t.OPEN_IN_PROGRESS,this.cache=await self.caches.open(\`\${this.context}\${this.storageName}\`),this.cacheState=t.READY}catch{this.cacheState=t.OPEN_FAILED}}async doRecover(e){try{if(this.recoveryInProgress++,this.recoveryInProgress>1)return;const t=await this.cache.keys();if(0===t.length)return;const s=(await this.cache.matchAll()).map((e=>{const t={};e.headers.forEach(((e,s)=>{t[s]=e})),delete t["content-type"];const s=t.datatype;return delete t.datatype,"json"===s||"base64"===s?e.text().then((e=>({metadata:t,events:e}))):e.arrayBuffer().then((e=>({metadata:t,events:e})))})),r=await Promise.all(s);await Promise.all(t.map((e=>this.cache.delete(e)))),e(r),this.byteSizeCounter.reset()}catch{}finally{this.recoveryInProgress--}}}class i{constructor(e){self.caches?this.setCachesStrategy(e):this.setRamStorageStrategy()}save(e){this.storageStrategy.save(e)}recover(e){this.storageStrategy.recover(e)}setCachesStrategy(e){this.storageStrategy=new o(e,i.MAX_SIZE,(e=>{this.setRamStorageStrategy(e)}))}setRamStorageStrategy(e){this.storageStrategy=new a(i.MAX_SIZE),e&&e.forEach((e=>{this.storageStrategy.save(e)}))}}i.MAX_SIZE=16777216,function(){const e="CS_WORKER_SIGNATURE",t=new Map,r=new i("csPersisted");function a(a){var o;if((o=a)&&o.WORKER_SIGNATURE===e)switch(a.type){case"CreatePostRequest":{const{endpoint:o,compressionOutputType:i,useRetry:n}=a,h={endpoint:o};i&&(h.compressionOpts={compressor,compressionOutputType:i,compressionType:algorithm}),n&&(h.recoveryStorage=r);const c=new s(h);t.set(o,c),c.onLoad((t=>{const s={type:"onLoad",endpoint:o,response:t,WORKER_SIGNATURE:e};self.postMessage(s)})),c.onError((t=>{const s={type:"onError",endpoint:o,response:t,WORKER_SIGNATURE:e};self.postMessage(s)}))}break;case"SetQueryParams":{const{endpoint:e,queryParams:s}=a,r=t.get(e);r&&r.setQueryParams(s)}break;case"RemoveQueryParams":{const{endpoint:e,queryParams:s}=a,r=t.get(e);r&&r.removeQueryParams(s)}break;case"Send":{const{endpoint:e,payload:s,queryParams:r}=a,o=t.get(e);o&&o.send(s,r)}break;case"Abort":{const{endpoint:e}=a,s=t.get(e);s&&s.abort()}break;case"SetHeader":{const{endpoint:e,headerName:s,headerValue:r}=a,o=t.get(e);o&&o.setRequestHeader(s,r)}break;case"SetTimeout":{const{endpoint:s,timeout:r}=a,o=t.get(s);o&&o.onTimeout((()=>{const t={type:"onTimeout",endpoint:s,WORKER_SIGNATURE:e};self.postMessage(t)}),r)}break;default:throw new Error(JSON.stringify(a))}}self.addEventListener("message",(function(e){e.data.getReader?async function(e,t){const s=e.getReader();for(;;){const{done:e,value:r}=await s.read();if(e)break;t(r)}}(e.data,a):a(e.data)}))}()})();`
            try {
                ;(this.$t = this.Lt(s)),
                    (this.Vt = !0),
                    this.xt() &&
                        ((this.Mt = new ReadableStream({
                            start: (t) => {
                                this.Dt = t
                            },
                        })),
                        this.$t.postMessage(this.Mt, [this.Mt]),
                        (this.postMessage = this.postMessageAsTransferable))
            } catch (t) {
                this.Vt = !1
            }
        }
        postMessage(t) {
            ;(t.WORKER_SIGNATURE = this.kt), this.$t.postMessage(t)
        }
        postMessageAsTransferable(t) {
            ;(t.WORKER_SIGNATURE = this.kt), this.Dt.enqueue(t)
        }
        Lt(t) {
            const s = window.csURL || window.webkitURL,
                i = window.Blob,
                e = window.Worker,
                n = new i([t], { type: "application/javascript" }),
                r = s.createObjectURL(n)
            Jt.whiteListFilename(r)
            const h = new e(r)
            return (
                (h.onmessage = (t) => {
                    const { type: s, endpoint: i, WORKER_SIGNATURE: e } = t.data
                    if (e === this.kt)
                        if ("onLoad" === s) {
                            const { response: s } = t.data,
                                e = this.Ct.get(i)
                            e && e(s)
                        } else if ("onError" === s) {
                            const { response: s } = t.data,
                                e = this.Nt.get(i)
                            e && e(s)
                        } else if ("onTimeout" === s) {
                            const t = this.Ot.get(i)
                            t && t()
                        }
                }),
                h
            )
        }
        registerOnLoadCallback(t, s) {
            this.Ct.set(t, s)
        }
        registerOnErrorCallback(t, s) {
            this.Nt.set(t, s)
        }
        registerOnTimeoutCallback(t, s) {
            this.Ot.set(t, s)
        }
        isSupported() {
            return this.Vt
        }
        xt() {
            try {
                const t = new ReadableStream()
                return structuredClone(t, { transfer: [t] }), !0
            } catch {
                return !1
            }
        }
    }
    class ls {
        constructor(t) {
            ;(this.Ut = {}),
                (this.zt = t.endpoint),
                (this.Ft = t.networkWorker),
                (this.Bt = t.compressionOutputType),
                (this.Ht = t.useRetry),
                this.Ft.postMessage({
                    type: "CreatePostRequest",
                    endpoint: this.zt,
                    compressionOutputType: this.Bt,
                    useRetry: this.Ht,
                })
        }
        setQueryParams(t) {
            this.Ft.postMessage({
                type: "SetQueryParams",
                endpoint: this.zt,
                queryParams: t,
            }),
                csArray.prototype.forEach.call(Object.keys(t), (s) => {
                    this.Ut[s] = t[s]
                })
        }
        getQueryParams() {
            return this.Ut
        }
        removeQueryParams(t) {
            this.Ft.postMessage({
                type: "RemoveQueryParams",
                endpoint: this.zt,
                queryParams: t,
            }),
                t &&
                    csArray.prototype.forEach.call(t, (t) => {
                        delete this.Ut[t]
                    })
        }
        send(t, s) {
            this.Ft.postMessage({
                type: "Send",
                endpoint: this.zt,
                payload: t,
                queryParams: s,
            })
        }
        abort() {
            this.Ft.postMessage({ type: "Abort", endpoint: this.zt })
        }
        onLoad(t) {
            this.Ft.registerOnLoadCallback(this.zt, t)
        }
        onError(t) {
            this.Ft.registerOnErrorCallback(this.zt, t)
        }
        setRequestHeader(t, s) {
            this.Ft.postMessage({
                type: "SetHeader",
                endpoint: this.zt,
                headerName: t,
                headerValue: s,
            })
        }
        onTimeout(t, s) {
            this.Ft.registerOnTimeoutCallback(this.zt, t),
                this.Ft.postMessage({
                    type: "SetTimeout",
                    endpoint: this.zt,
                    timeout: s,
                })
        }
    }
    var ds, fs, ws, ps, ms
    !(function (t) {
        ;(t.UNCOMPRESSED = "0"), (t.GZIP = "2")
    })(ds || (ds = {}))
    class Es {
        constructor(t) {
            this.onError = t
        }
    }
    class ys {
        constructor(t) {
            ;(this.Ut = {}),
                (this.qt = {}),
                (this.jt = (t) => {
                    for (const s of t) {
                        const { metadata: t, events: i } = s
                        this.send(i, t)
                    }
                }),
                (this.zt = t.endpoint),
                (this.Gt = t.compressionOpts),
                (this.Zt = t.recoveryStorage),
                this.Zt && this.Zt.recover(this.jt)
        }
        setQueryParams(t) {
            Object.keys(t).forEach((s) => {
                this.Ut[s] = t[s]
            })
        }
        removeQueryParams(t) {
            t
                ? t.forEach((t) => {
                      delete this.Ut[t]
                  })
                : (this.Ut = {})
        }
        send(t, s) {
            const i = s || { ...this.Ut },
                e = !("ct" in i),
                n = "string" != typeof t && !this.Wt(t)
            "ct" in i ||
                (this.Gt && e
                    ? (i.ct = this.Gt.compressionType)
                    : (i.ct = ds.UNCOMPRESSED))
            const r = n ? JSON.stringify(t) : t,
                h = Object.keys(i)
                    .map(
                        (t) =>
                            `${encodeURIComponent(t)}=${encodeURIComponent(
                                i[t]
                            )}`
                    )
                    .join("&"),
                o = `${this.zt}?${h}`
            this.Gt && e && "string" == typeof r
                ? this.Gt.compressor(r, this.Gt.compressionOutputType, (t) =>
                      this.Kt(o, i, t)
                  )
                : this.Kt(o, i, r)
        }
        onLoad(t) {
            this.Yt = t
        }
        onError(t) {
            this.Qt = t
        }
        onTimeout(t, s) {
            ;(this.Jt = t), (this.Xt = s)
        }
        abort() {
            this.ss && this.ss()
        }
        setRequestHeader(t, s) {
            this.qt[t] = s
        }
        getQueryParams() {
            return this.Ut
        }
        Wt(t) {
            return t && void 0 !== t.byteLength
        }
        Kt(t, s, i) {
            const e = new XMLHttpRequest(),
                n = Object.keys(s)
                    .map(
                        (t) =>
                            `${encodeURIComponent(t)}=${encodeURIComponent(
                                s[t]
                            )}`
                    )
                    .join("&")
            e.open("POST", t),
                (e.onload = () => {
                    if ((this.Zt && this.Zt.recover(this.jt), this.Yt)) {
                        const t = {
                            params: s,
                            responseText: e.responseText,
                            status: e.status,
                        }
                        this.Yt(t)
                    }
                }),
                (e.onerror = () => {
                    this.Zt && this.Zt.save({ key: n, metadata: s, events: i }),
                        this.Qt && this.Qt({ params: s })
                }),
                this.Xt &&
                    this.Jt &&
                    ((e.timeout = this.Xt),
                    (e.ontimeout = () => {
                        this.Jt()
                    })),
                (this.ss = () => e.abort()),
                Object.keys(this.qt).forEach((t) => {
                    e.setRequestHeader(t, this.qt[t])
                }),
                e.send(i)
        }
    }
    class As {
        constructor(t) {
            ;(this.es = t), (this.Ft = new us(this.es))
        }
        create(t, s, i, e) {
            if (this.Ft.isSupported() && s)
                return new ls({
                    networkWorker: this.Ft,
                    endpoint: t,
                    compressionOutputType: i,
                    useRetry: !!e,
                })
            {
                const s = i
                    ? {
                          compressor: this.es.compress,
                          compressionOutputType: i,
                          compressionType: this.es.algorithm,
                      }
                    : void 0
                return new ys({
                    endpoint: t,
                    compressionOpts: s,
                    recoveryStorage: e,
                })
            }
        }
    }
    class gs {
        constructor(t, s, i, e, n) {
            ;(this.Z = t),
                (this.W = s),
                (this.ns = i),
                (this.rs = e),
                (this.$ = n)
        }
        get() {
            return {
                exclusion: this.ns.getAppliedTrackingDraw(),
                visitor: this.Z.getVisitor(),
                session: this.W.getSession(),
                cvars: this.rs.getCustomVariablesSession(),
            }
        }
        apply(t) {
            t && (t.exclusion ? this.exclude() : this.include(t))
        }
        exclude() {
            this.ns.exclude(this.$),
                this.Z.removeVisitor(),
                this.W.removeSession(),
                this.rs.removeCustomVariablesSession()
        }
        include(t) {
            this.ns.removeExclusion(),
                this.Z.setVisitor(t.visitor),
                t.session
                    ? this.W.setSession(t.session)
                    : this.W.removeSession(),
                t.cvars
                    ? this.rs.setCustomVariableSession(t.cvars)
                    : this.rs.removeCustomVariablesSession()
        }
    }
    !(function (t) {
        ;(t[(t.MUTATION_INSERT = 1)] = "MUTATION_INSERT"),
            (t[(t.MUTATION_REMOVE = 2)] = "MUTATION_REMOVE"),
            (t[(t.MUTATION_ATTRIBUTE = 3)] = "MUTATION_ATTRIBUTE"),
            (t[(t.MUTATION_CHARACTER_DATA = 4)] = "MUTATION_CHARACTER_DATA"),
            (t[(t.INITIAL_DOM = 5)] = "INITIAL_DOM"),
            (t[(t.SCROLL = 6)] = "SCROLL"),
            (t[(t.CLICK = 8)] = "CLICK"),
            (t[(t.RESIZE = 9)] = "RESIZE"),
            (t[(t.INPUT_CHECKABLE = 10)] = "INPUT_CHECKABLE"),
            (t[(t.INPUT_SELECT = 11)] = "INPUT_SELECT"),
            (t[(t.INPUT_TEXT = 12)] = "INPUT_TEXT"),
            (t[(t.HASH_CHANGE = 13)] = "HASH_CHANGE"),
            (t[(t.UNANONYMIZED_CONSENT_GRANTED = 14)] =
                "UNANONYMIZED_CONSENT_GRANTED"),
            (t[(t.UNANONYMIZED_CONSENT_WITHDRAWN = 15)] =
                "UNANONYMIZED_CONSENT_WITHDRAWN"),
            (t[(t.MOUSE_OVER = 16)] = "MOUSE_OVER"),
            (t[(t.VISIBILITY_CHANGE = 17)] = "VISIBILITY_CHANGE"),
            (t[(t.STYLESHEET_RULE_INSERT = 18)] = "STYLESHEET_RULE_INSERT"),
            (t[(t.STATIC_RESOURCE_URL = 19)] = "STATIC_RESOURCE_URL"),
            (t[(t.PERFORMANCE_TIMINGS = 20)] = "PERFORMANCE_TIMINGS"),
            (t[(t.ATTACH_SHADOW = 22)] = "ATTACH_SHADOW"),
            (t[(t.STYLESHEET_CSS_TEXT_UPDATE = 23)] =
                "STYLESHEET_CSS_TEXT_UPDATE"),
            (t[(t.JAVASCRIPT_ERROR = 26)] = "JAVASCRIPT_ERROR"),
            (t[(t.PAGE_EVENT = 27)] = "PAGE_EVENT"),
            (t[(t.API_ERROR = 28)] = "API_ERROR"),
            (t[(t.TEXT_VISIBILITY = 29)] = "TEXT_VISIBILITY"),
            (t[(t.MUTATION_ENCRYPTED_CHARACTER_DATA = 30)] =
                "MUTATION_ENCRYPTED_CHARACTER_DATA"),
            (t[(t.INPUT_ENCRYPTED_TEXT = 31)] = "INPUT_ENCRYPTED_TEXT"),
            (t[(t.KEY_DOWN = 32)] = "KEY_DOWN"),
            (t[(t.KEY_UP = 33)] = "KEY_UP"),
            (t[(t.CLIPBOARD_COMMAND = 34)] = "CLIPBOARD_COMMAND"),
            (t[(t.STYLESHEET_RULE_DELETE = 37)] = "STYLESHEET_RULE_DELETE"),
            (t[(t.USER_IDENTIFIER = 38)] = "USER_IDENTIFIER"),
            (t[(t.TOUCH_START = 41)] = "TOUCH_START"),
            (t[(t.TOUCH_MOVE = 42)] = "TOUCH_MOVE"),
            (t[(t.TOUCH_END = 43)] = "TOUCH_END"),
            (t[(t.GESTURE_RECOGNITION = 44)] = "GESTURE_RECOGNITION"),
            (t[(t.POINTER_DOWN = 47)] = "POINTER_DOWN"),
            (t[(t.POINTER_MOVE = 48)] = "POINTER_MOVE"),
            (t[(t.POINTER_UP = 49)] = "POINTER_UP"),
            (t[(t.CUSTOM_ERROR = 50)] = "CUSTOM_ERROR"),
            (t[(t.CUSTOM_ELEMENT_REGISTRATION = 54)] =
                "CUSTOM_ELEMENT_REGISTRATION"),
            (t[(t.REGISTER_ADOPTED_STYLE_SHEET = 60)] =
                "REGISTER_ADOPTED_STYLE_SHEET"),
            (t[(t.SET_ADOPTED_STYLE_SHEETS = 61)] = "SET_ADOPTED_STYLE_SHEETS"),
            (t[(t.ADOPTED_STYLESHEET_RULE_INSERT = 62)] =
                "ADOPTED_STYLESHEET_RULE_INSERT"),
            (t[(t.ADOPTED_STYLESHEET_RULE_DELETE = 63)] =
                "ADOPTED_STYLESHEET_RULE_DELETE"),
            (t[(t.SCREEN_RESIZE = 65)] = "SCREEN_RESIZE"),
            (t[(t.RESOURCE_HASHES = 66)] = "RESOURCE_HASHES"),
            (t[(t.PERFORMANCE_NAVIGATION_TIMING = 67)] =
                "PERFORMANCE_NAVIGATION_TIMING"),
            (t[(t.PERFORMANCE_RESOURCE_TIMING = 68)] =
                "PERFORMANCE_RESOURCE_TIMING"),
            (t[(t.RECORDING_INFO_EVENT = 72)] = "RECORDING_INFO_EVENT"),
            (t[(t.TEXT_REF = 73)] = "TEXT_REF"),
            (t[(t.TOUCH_CANCEL = 74)] = "TOUCH_CANCEL"),
            (t[(t.MUTATION_MOVE = 75)] = "MUTATION_MOVE")
    })(fs || (fs = {})),
        (function (t) {
            ;(t[(t.RECORDING_CONSENT_FOR_SESSION_GRANTED = 1)] =
                "RECORDING_CONSENT_FOR_SESSION_GRANTED"),
                (t[(t.RECORDING_CONSENT_FOR_SESSION_WITHDRAWN = 2)] =
                    "RECORDING_CONSENT_FOR_SESSION_WITHDRAWN")
        })(ws || (ws = {})),
        (function (t) {
            ;(t[(t.Left = 0)] = "Left"),
                (t[(t.Middle = 1)] = "Middle"),
                (t[(t.Right = 2)] = "Right"),
                (t[(t.Fourth = 3)] = "Fourth"),
                (t[(t.Fifth = 4)] = "Fifth")
        })(ps || (ps = {})),
        (function (t) {
            ;(t[(t.SWIPE = 0)] = "SWIPE"),
                (t[(t.PINCH_IN = 1)] = "PINCH_IN"),
                (t[(t.PINCH_OUT = 2)] = "PINCH_OUT"),
                (t[(t.LONG_PRESS = 3)] = "LONG_PRESS"),
                (t[(t.TAP = 4)] = "TAP"),
                (t[(t.DOUBLE_TAP = 5)] = "DOUBLE_TAP")
        })(ms || (ms = {}))
    function vs(t, s = true) {
        t.boundElement.addEventListener(t.type, t.listener, s)
    }
    function _s(t, s = true) {
        t.boundElement.removeEventListener(t.type, t.listener, s)
    }
    function Rs(t, s = 0) {
        const i = Math.pow(10, s)
        return Math.round(t * i) / i
    }
    function Ss(t, s) {
        "number" == typeof s && (s = { wait: s })
        const i = s.wait
        if (s.ignoreThrottledCalls) {
            let s = 0
            return function (...e) {
                const n = pt.now()
                if (n - s > i) return (s = n), t.apply(this, e)
            }
        }
        let e,
            n,
            r = [],
            h = null,
            o = 0
        const c = () => {
                ;(o = pt.now()), (h = null), (n = t.apply(e, r))
            },
            a = function (...s) {
                const a = pt.now(),
                    u = i - (a - o)
                return (
                    (e = null != this ? this : window),
                    (r = [...s]),
                    u <= 0 || u > i
                        ? ((o = a),
                          (n = t.apply(e, r)),
                          h ? (window.clearTimeout(h), (h = null)) : (r = []))
                        : h || (h = window.setTimeout(c, u)),
                    n
                )
            }
        return (
            (a.cancel = () => {
                h && (window.clearTimeout(h), (o = 0), (h = null), (r = []))
            }),
            (a.flushPending = () => {
                h && (window.clearTimeout(h), c())
            }),
            a
        )
    }
    const Ts = (t) => (s, i, e) => {
        e.value = Ss(e.value, t)
    }
    var Is, Ps
    !(function (t) {
        ;(t[(t.SPACE = 0)] = "SPACE"),
            (t[(t.ENTER = 1)] = "ENTER"),
            (t[(t.BACKSPACE = 2)] = "BACKSPACE"),
            (t[(t.DELETE = 3)] = "DELETE"),
            (t[(t.ARROWUP = 4)] = "ARROWUP"),
            (t[(t.ARROWDOWN = 5)] = "ARROWDOWN"),
            (t[(t.ARROWLEFT = 6)] = "ARROWLEFT"),
            (t[(t.ARROWRIGHT = 7)] = "ARROWRIGHT"),
            (t[(t.CAPSLOCK = 8)] = "CAPSLOCK"),
            (t[(t.SHIFT = 9)] = "SHIFT"),
            (t[(t.TAB = 10)] = "TAB"),
            (t[(t.ALPHANUMERICAL = 11)] = "ALPHANUMERICAL"),
            (t[(t.ESCAPE = 12)] = "ESCAPE"),
            (t[(t.END = 13)] = "END"),
            (t[(t.ALT = 14)] = "ALT"),
            (t[(t.CTRL = 15)] = "CTRL"),
            (t[(t.META = 16)] = "META")
    })(Is || (Is = {})),
        (function (t) {
            ;(t[(t.COPY = 0)] = "COPY"),
                (t[(t.CUT = 1)] = "CUT"),
                (t[(t.PASTE = 2)] = "PASTE")
        })(Ps || (Ps = {}))
    class bs {
        static isEmpty() {
            return 0 === bs.hs.length
        }
        static add(t) {
            csArray.prototype.push.call(bs.hs, ...t)
        }
        static getAll() {
            return bs.hs
        }
        static clear() {
            bs.hs = []
        }
    }
    bs.hs = []
    let Vs = 50,
        Cs = 0.1
    let Ns = !1
    const Os = []
    let ks = []
    const $s = function (t) {
        return function (s, i, e) {
            const n = e.value
            e.value = function () {
                if (!Ns) return (e.value = n), n.apply(this, arguments)
                !(function (t) {
                    csArray.prototype.push.call(Os, t),
                        performance.mark(`${t}-start`)
                })(t)
                const s = n.apply(this, arguments)
                return (
                    (function (t) {
                        const s = performance.measure(t, `${t}-start`)
                        if (!s) return
                        const i = s.duration
                        i >= Cs &&
                            csArray.prototype.push.call(ks, {
                                mName: t,
                                mDuration: +i.toFixed(2),
                            }),
                            csArray.prototype.pop.call(Os),
                            0 === Os.length && (i > Vs && bs.add(ks), (ks = []))
                    })(t),
                    s
                )
            }
        }
    }
    function Ls(t) {
        const s = csEventtarget.apply(t)
        return s && u(s) && csElementshadowRoot.apply(s) && t.composedPath
            ? t.__csOriginalTarget || t.composedPath()[0]
            : s
    }
    function xs() {
        return (t, s, i) => {
            const e = i.value
            i.value = function (t, s) {
                ;(!1 === (null == t ? void 0 : t.isTrusted) && xs.enabled) ||
                    e.call(this, t, s)
            }
        }
    }
    xs.enabled = !0
    const Ms = !!window.chrome,
        Ds = "data-cs-scroll-container"
    var Us
    !(function (t) {
        ;(t.isEventOnScrollContainer = function (t) {
            return !!(
                Tt(t) &&
                (function (t) {
                    try {
                        if (Tt(csEventtarget.apply(t))) return !0
                    } catch {}
                    return !1
                })(t) &&
                Pt(csEventtarget.apply(t)) &&
                null !== csEventtarget.apply(t).getAttribute(Ds)
            )
        }),
            (t.getScrollContainer = function () {
                return window.csquerySelector[document.nodeType].call(
                    document,
                    `[${Ds}]`
                )
            })
    })(Us || (Us = {}))
    class zs {
        constructor(t, s) {
            ;(this.cs = t),
                (this.us = s),
                (this.ls = new Set()),
                (this.ds = []),
                (this.fs = [
                    {
                        type: "pointerup",
                        listener: (t) => this.pointerUpListener(t),
                        boundElement: document,
                    },
                    {
                        type: "pointermove",
                        listener: (t) => this.pointerMoveListener(t),
                        boundElement: document,
                    },
                    {
                        type: "pointerdown",
                        listener: (t) => this.pointerDownListener(t),
                        boundElement: document,
                    },
                ]),
                (this.ws = [
                    {
                        type: "touchstart",
                        listener: (t) => this.touchStartListener(t),
                        boundElement: document,
                    },
                    {
                        type: "touchmove",
                        listener: (t) => this.touchMoveListener(t),
                        boundElement: document,
                    },
                    {
                        type: "touchend",
                        listener: (t) => this.touchEndCancelListener(t),
                        boundElement: document,
                    },
                    {
                        type: "touchcancel",
                        listener: (t) => this.touchEndCancelListener(t),
                        boundElement: document,
                    },
                ]),
                (this.ps = [
                    {
                        type: "click",
                        listener: (t) => this.clickListener(t),
                        boundElement: document,
                    },
                    {
                        type: "keyup",
                        listener: (t) => this.keyUpListener(t),
                        boundElement: document,
                    },
                    {
                        type: "keydown",
                        listener: (t) => this.keyDownListener(t),
                        boundElement: document,
                    },
                    {
                        type: "copy",
                        listener: (t) => this.copyListener(t),
                        boundElement: document,
                    },
                    {
                        type: "cut",
                        listener: (t) => this.cutListener(t),
                        boundElement: document,
                    },
                    {
                        type: "paste",
                        listener: (t) => this.pasteListener(t),
                        boundElement: document,
                    },
                    {
                        type: "scroll",
                        listener: (t) =>
                            this.scrollListener(csEventtarget.apply(t)),
                        boundElement: document,
                    },
                    {
                        type: "mouseover",
                        listener: (t) => this.mouseOverListener(t),
                        boundElement: document,
                    },
                ]),
                (this.Es = [
                    {
                        type: "scroll",
                        listener: (t) =>
                            this.scrollListener(csEventtarget.apply(t)),
                    },
                ])
            const i = (function (t) {
                if (!_t(t)) return null
                const s = /iP(ad|hone|od).+Version\/(\d+)\..*Safari/i.exec(t)
                return s ? Number(s[2]) : null
            })(window.navigator.userAgent)
            ;(null === i || (i && i >= 16)) &&
                csArray.prototype.push.call(this.Es, {
                    type: "mouseover",
                    listener: (t) => this.mouseOverListener(t),
                })
        }
        init() {
            this.ys(), this.As(), this.gs(), this.vs()
        }
        vs() {
            this.cs.onDocumentIdentified((t) => {
                this._s(t)
            })
        }
        onEvent(t) {
            csArray.prototype.push.call(this.ds, t)
        }
        Rs(t, s = !1) {
            csArray.prototype.forEach.call(this.ds, (i) => i(t, s))
        }
        start() {
            this.Ss()
        }
        stop() {
            this.Ts()
        }
        As() {
            this.Is() && csArray.prototype.push.call(this.ps, ...this.fs)
        }
        ys() {
            this.Ps() && csArray.prototype.push.call(this.ps, ...this.ws)
        }
        _s(t) {
            S(t)
                ? csArray.prototype.forEach.call(this.ps, (t) => vs(t))
                : this.ls.has(t) ||
                  (this.ls.add(t),
                  csArray.prototype.forEach.call(this.Es, (s) => {
                      const i = s
                      ;(i.boundElement = t), vs(i)
                  }))
        }
        bs(t) {
            S(t)
                ? csArray.prototype.forEach.call(this.ps, (t) => _s(t))
                : (this.ls.delete(t),
                  csArray.prototype.forEach.call(this.Es, (s) => {
                      const i = s
                      ;(i.boundElement = t), _s(i)
                  }))
        }
        Is() {
            return (
                "PointerEvent" in window &&
                "function" == typeof window.PointerEvent
            )
        }
        Ps() {
            return (
                "TouchEvent" in window && "function" == typeof window.TouchEvent
            )
        }
        Ts() {
            this.bs(document), this.ls.forEach((t) => this.bs(t))
        }
        Ss() {
            this.Vs()
        }
        Vs() {
            const t = Us.getScrollContainer() || document,
                s = this.cs.getId(t)
            if (!s) return
            const i = this.Cs(t)
            if (0 !== i.top || 0 !== i.left) {
                const t = {
                    type: fs.SCROLL,
                    args: [s, i.left, i.top],
                    date: pt.now(),
                }
                this.Rs(t, !0)
            }
        }
        Cs(t) {
            return t === document
                ? { top: window.pageYOffset, left: window.pageXOffset }
                : { top: t.scrollTop, left: t.scrollLeft }
        }
        scrollListener(t) {
            if (this.us.isSensitive(t) || this.us.isSensitiveChild(t)) return
            const s = this.cs.getId(t)
            if (!s) return
            const i = this.Cs(t),
                e = {
                    type: fs.SCROLL,
                    args: [s, i.left, i.top],
                    date: pt.now(),
                }
            this.Rs(e)
        }
        mouseOverListener(t) {
            if (this.us.isSensitiveChild(t.target)) return
            const s = this.cs.getId(t.target)
            if (!s) return
            const i = { type: fs.MOUSE_OVER, args: [s], date: pt.now() }
            this.Rs(i)
        }
        clickListener(t) {
            const s = Ls(t)
            if (this.us.isSensitiveChild(s)) return
            const i = this.cs.getId(s)
            if (!i) return
            const e = { type: fs.CLICK, args: [i], date: pt.now() }
            this.Rs(e)
        }
        keyUpListener(t) {
            const s = Ls(t)
            if (this.us.isSensitiveChild(s)) return
            const i = this.cs.getId(s)
            if (!i) return
            const e = this.Ns[t.key]
            if (void 0 === e) return
            const n = { type: fs.KEY_UP, args: [i, e], date: pt.now() }
            this.Rs(n)
        }
        keyDownListener(t) {
            const s = Ls(t)
            if (this.us.isSensitiveChild(s)) return
            const i = this.cs.getId(s)
            if (!i) return
            const e = this.Ns[t.key]
            if (void 0 === e) return
            const n = { type: fs.KEY_DOWN, args: [i, e], date: pt.now() }
            this.Rs(n)
        }
        copyListener(t) {
            const s = Ls(t)
            if (this.us.isSensitiveChild(s)) return
            const i = this.cs.getId(s)
            if (!i) return
            const e = {
                type: fs.CLIPBOARD_COMMAND,
                args: [i, Ps.COPY],
                date: pt.now(),
            }
            this.Rs(e)
        }
        cutListener(t) {
            const s = Ls(t)
            if (this.us.isSensitiveChild(s)) return
            const i = this.cs.getId(s)
            if (!i) return
            const e = {
                type: fs.CLIPBOARD_COMMAND,
                args: [i, Ps.CUT],
                date: pt.now(),
            }
            this.Rs(e)
        }
        pasteListener(t) {
            const s = Ls(t)
            if (this.us.isSensitiveChild(s)) return
            const i = this.cs.getId(s)
            if (!i) return
            const e = {
                type: fs.CLIPBOARD_COMMAND,
                args: [i, Ps.PASTE],
                date: pt.now(),
            }
            this.Rs(e)
        }
        pointerUpListener(t) {
            const s = Ls(t)
            if (this.us.isSensitiveChild(s)) return
            const i = this.cs.getId(s)
            if (!i) return
            const e = {
                type: fs.POINTER_UP,
                args: [
                    t.pointerId,
                    t.pointerType,
                    Rs(t.clientX, 1),
                    Rs(t.clientY, 1),
                    i,
                    t.button,
                ],
                date: pt.now(),
            }
            this.Rs(e)
        }
        pointerMoveListener(t) {
            const s = {
                type: fs.POINTER_MOVE,
                args: [
                    t.pointerId,
                    t.pointerType,
                    Rs(t.clientX, 1),
                    Rs(t.clientY, 1),
                ],
                date: pt.now(),
            }
            this.Rs(s)
        }
        pointerDownListener(t) {
            const s = Ls(t)
            if (this.us.isSensitiveChild(s)) return
            const i = this.cs.getId(s)
            if (!i) return
            const e = {
                type: fs.POINTER_DOWN,
                args: [
                    t.pointerId,
                    t.pointerType,
                    Rs(t.clientX, 1),
                    Rs(t.clientY, 1),
                    i,
                    t.button,
                    { pageX: Rs(t.pageX, 1), pageY: Rs(t.pageY, 1) },
                ],
                date: pt.now(),
            }
            this.Rs(e)
        }
        touchStartListener(t) {
            if (!t.changedTouches) return
            const { changedTouches: s } = t
            for (let t = 0; t < s.length; t += 1) {
                const i = s[t],
                    e = {
                        type: fs.TOUCH_START,
                        args: [
                            i.identifier,
                            Rs(i.clientX, 1),
                            Rs(i.clientY, 1),
                        ],
                        date: pt.now(),
                    }
                this.Rs(e)
            }
        }
        touchMoveListener(t) {
            if (!t.changedTouches) return
            const { changedTouches: s } = t
            for (let t = 0; t < s.length; t += 1) {
                const i = s[t],
                    e = {
                        type: fs.TOUCH_MOVE,
                        args: [
                            i.identifier,
                            Rs(i.clientX, 1),
                            Rs(i.clientY, 1),
                        ],
                        date: pt.now(),
                    }
                this.Rs(e)
            }
        }
        touchEndCancelListener(t) {
            if (!t.changedTouches) return
            const { changedTouches: s } = t
            for (let i = 0; i < s.length; i += 1) {
                const e = s[i],
                    n = {
                        type:
                            "touchend" === t.type
                                ? fs.TOUCH_END
                                : fs.TOUCH_CANCEL,
                        args: [
                            e.identifier,
                            Rs(e.clientX, 1),
                            Rs(e.clientY, 1),
                        ],
                        date: pt.now(),
                    }
                this.Rs(n)
            }
        }
        gs() {
            ;(this.Ns = {}),
                (this.Ns[" "] = Is.SPACE),
                (this.Ns.Spacebar = Is.SPACE),
                (this.Ns.Backspace = Is.BACKSPACE),
                (this.Ns.Enter = Is.ENTER),
                (this.Ns.Delete = Is.DELETE),
                (this.Ns.ArrowUp = Is.ARROWUP),
                (this.Ns.ArrowDown = Is.ARROWDOWN),
                (this.Ns.ArrowLeft = Is.ARROWLEFT),
                (this.Ns.ArrowRight = Is.ARROWRIGHT),
                (this.Ns.Up = Is.ARROWUP),
                (this.Ns.Down = Is.ARROWDOWN),
                (this.Ns.Left = Is.ARROWLEFT),
                (this.Ns.Right = Is.ARROWRIGHT),
                (this.Ns.CapsLock = Is.CAPSLOCK),
                (this.Ns.Shift = Is.SHIFT),
                (this.Ns.Tab = Is.TAB),
                (this.Ns.Escape = Is.ESCAPE),
                (this.Ns.Esc = Is.ESCAPE),
                (this.Ns.End = Is.END),
                (this.Ns.Alt = Is.ALT),
                (this.Ns.Control = Is.CTRL),
                (this.Ns.Meta = Is.META)
        }
    }
    function Fs(t) {
        var s
        const i = null !== (s = t.length) && void 0 !== s ? s : 0,
            e = new csArray(i)
        for (let s = 0; s < i; s += 1) e[s] = t[s]
        return e
    }
    function Bs(t, s, i) {
        let e = 0
        for (let n = 0; n < t.length; n += 1) {
            const r = s(t[n])
            for (let t = 0; t < r.length; t++) i(r[t], e++)
        }
        return []
    }
    function Hs(t, s) {
        if (t.length >= 0) {
            const i = t.length
            for (let e = 0; e < i; e++) s(t[e], e)
        } else {
            let i = 0,
                e = t.next()
            for (; !e.done; ) s(e.value, i++), (e = t.next())
        }
    }
    function qs(t, s) {
        const i = t.length
        for (let e = 0; e < i; e++) if (s(t[e], e)) return !0
        return !1
    }
    function js(t, s) {
        const i = t.length,
            e = []
        for (let n = 0; n < i; n += 1) {
            const i = t[n]
            s(i) && csArray.prototype.push.call(e, i)
        }
        return e
    }
    ss([$s("RecordingPageEvents.start")], zs.prototype, "start", null),
        ss([ts("scroll")], zs.prototype, "scrollListener", null),
        ss(
            [
                ts("mouseOver"),
                xs(),
                (t, s, i) => {
                    const e = i.value
                    return (
                        e &&
                            (i.value = function (t) {
                                if (Ls(t) === csEventtarget.apply(t))
                                    return e.call(this, t)
                            }),
                        i
                    )
                },
            ],
            zs.prototype,
            "mouseOverListener",
            null
        ),
        ss([ts("click"), xs()], zs.prototype, "clickListener", null),
        ss(
            [ts("Event handler type: keyup")],
            zs.prototype,
            "keyUpListener",
            null
        ),
        ss(
            [ts("Event handler type: keydown")],
            zs.prototype,
            "keyDownListener",
            null
        ),
        ss(
            [ts("Event handler type: copy")],
            zs.prototype,
            "copyListener",
            null
        ),
        ss([ts("Event handler type: cut")], zs.prototype, "cutListener", null),
        ss(
            [ts("Event handler type: paste")],
            zs.prototype,
            "pasteListener",
            null
        ),
        ss(
            [ts("Event handler type: pointerup"), xs()],
            zs.prototype,
            "pointerUpListener",
            null
        ),
        ss(
            [
                ts("Event handler type: pointermove"),
                xs(),
                Ts({ wait: 33, ignoreThrottledCalls: !0 }),
            ],
            zs.prototype,
            "pointerMoveListener",
            null
        ),
        ss(
            [ts("Event handler type: pointerdown"), xs()],
            zs.prototype,
            "pointerDownListener",
            null
        ),
        ss(
            [ts("Event handler type: touchstart"), xs()],
            zs.prototype,
            "touchStartListener",
            null
        ),
        ss(
            [ts("Event handler type: touchmove"), xs()],
            zs.prototype,
            "touchMoveListener",
            null
        ),
        ss(
            [ts("Event handler type: touchend-cancel"), xs()],
            zs.prototype,
            "touchEndCancelListener",
            null
        )
    const Gs = xt("queueMicrotask", setTimeout)
    let Zs = []
    function Ws(t) {
        0 == Zs.length &&
            Ks(() => {
                for (const t of Zs) t()
                Zs = []
            }),
            csArray.prototype.push.call(Zs, t)
    }
    function Ks(t, s = 10) {
        Gs(0 === s ? t : () => Ks(t, s - 1))
    }
    class Ys {
        constructor(t, s, i, e, n, r, h = document) {
            ;(this.Os = t),
                (this.ks = s),
                (this.$s = i),
                (this.Ls = e),
                (this.cs = n),
                (this.us = r),
                (this.xs = h),
                (this.Ms = !1),
                (this.Ds = (t) => {
                    this.Ls.emitInitialDomDone(t)
                }),
                (this.Us = (t) => {
                    const s = this.cs.getId(t.target)
                    if (!s) return
                    const i = t.target.getBoundingClientRect()
                    if (
                        i.width === t.target.__contentsquare_width &&
                        i.height === t.target.__contentsquare_height
                    )
                        return
                    ;(t.target.__contentsquare_width = i.width),
                        (t.target.__contentsquare_height = i.height)
                    const e = {
                        args: [
                            s,
                            null,
                            "style",
                            `width:${i.width}px !important;height:${i.height}px !important;`,
                        ],
                        date: pt.now(),
                        type: fs.MUTATION_ATTRIBUTE,
                    }
                    this.zs(e)
                }),
                this.ks.onCharacterDataMutation((t) => {
                    this.Fs(t)
                }),
                this.ks.onAttributesMutation((t) => {
                    this.Bs(t)
                }),
                this.ks.onChildListMutation((t, s) => {
                    Hs(t.addedNodes, (t) => {
                        this.us.identifySensitiveNodes(t),
                            this.cs.identifyNodes(t, s)
                    }),
                        this.Hs(t, s),
                        Hs(t.removedNodes, (t) => {
                            this.us.unidentifySensitiveNodes(t)
                        })
                }),
                this.ks.onAttachShadowMutation((t) => {
                    t.target.isConnected &&
                        null !== csElementshadowRoot.apply(t.target) &&
                        (this.us.identifySensitiveNodes(t.target),
                        this.cs.identifyNodes(
                            csElementshadowRoot.apply(t.target)
                        ),
                        Ws(() => this.qs(t)))
                }),
                this.us.onSensitiveElementResize(this.Us)
        }
        onEvent(t) {
            this.zs = t
        }
        isStarted() {
            return this.Ms
        }
        start() {
            this.isStarted() || ((this.Ms = !0), this.ks.start(), this.js())
        }
        stop() {
            this.isStarted() &&
                ((this.Ms = !1),
                this.us.unidentifySensitiveNodes(this.xs),
                this.us.disconnectResizeObserver(),
                this.ks.stop())
        }
        flushEvents() {
            this.ks.flushPendingMutations()
        }
        js() {
            this.Ls.emitInitialDomStart(),
                this.us.identifySensitiveNodes(this.xs),
                this.cs.identifyNodes(this.xs),
                this.Os.serializeInitialDom(this.xs, this.Ds)
        }
        qs(t) {
            if (
                this.us.isSensitive(t.target) ||
                this.us.isSensitiveChild(t.target)
            )
                return
            const s = this.Os.serializeAttachShadowEvent(t)
            if (!s) return
            const i = { args: s, date: t.date, type: fs.ATTACH_SHADOW }
            this.zs(i)
        }
        Bs(t) {
            if (
                this.us.isSensitiveChild(t.target) ||
                this.us.isSensitiveAttribute(t.target, t.attributeName)
            )
                return
            const s = this.Os.serializeMutationAttribute(t)
            if (!s) return
            const i = { args: s, date: t.date, type: fs.MUTATION_ATTRIBUTE }
            this.zs(i), this.$s.scanAttribute(t.target, t.attributeName)
        }
        Fs(t) {
            const s = t.target.parentElement
            if (s && (this.us.isSensitive(s) || this.us.isSensitiveChild(s)))
                return
            const i = this.Os.serializeMutationCharacterData(t)
            if (!i) return
            const e = {
                args: i,
                date: t.date,
                type: fs.MUTATION_CHARACTER_DATA,
            }
            this.zs(e), this.$s.scanText(t.target)
        }
        Hs(t, s) {
            if (
                this.us.isSensitive(t.target) ||
                this.us.isSensitiveChild(t.target)
            )
                return
            const i = this.Os.serializeMutationChildList(t, s)
            if (!i) return
            const { removedNodes: e, addedNodes: n } = i
            csArray.prototype.forEach.call(e, (s) => {
                const i = { args: s, date: t.date, type: fs.MUTATION_REMOVE }
                this.zs(i)
            }),
                csArray.prototype.forEach.call(n, (s) => {
                    const i = {
                        args: s,
                        date: t.date,
                        type: fs.MUTATION_INSERT,
                    }
                    this.zs(i)
                })
        }
    }
    class Qs {
        constructor(t) {
            ;(this.Gs = t), (this.Zs = 0)
        }
        addString(t) {
            this.Zs += 2 * t.length
        }
        addArrayBuffer(t) {
            this.Zs += t.byteLength
        }
        isThresholdReached() {
            return this.Zs > this.Gs
        }
        reset() {
            this.Zs = 0
        }
    }
    class Js {
        constructor(t = [], s = 512e3) {
            ;(this.Ws = t), (this.Ks = new Qs(s))
        }
        addEvent(t) {
            this.Ks.addString(J(t)), csArray.prototype.push.call(this.Ws, t)
        }
        addEventByTimestamp(t) {
            let s = 0
            for (; s < this.Ws.length; s += 1) {
                if (this.Ws[s].date > t.date) break
            }
            csArray.prototype.splice.call(this.Ws, s, 0, t)
        }
        eventsCount() {
            return this.Ws.length
        }
        clearEvents() {
            this.Ks.reset(), (this.Ws = [])
        }
        isFull() {
            return this.eventsCount() >= 200
        }
        isThresholdReached() {
            return this.Ks.isThresholdReached()
        }
        getEvents() {
            return this.Ws
        }
        extractEvents(...t) {
            const s = [],
                i = []
            return (
                csArray.prototype.forEach.call(this.Ws, (e) => {
                    ;-1 !== csArray.prototype.indexOf.call(t, e.type)
                        ? csArray.prototype.push.call(s, e)
                        : csArray.prototype.push.call(i, e)
                }),
                (this.Ws = i),
                s
            )
        }
        stringifyEvents() {
            return J(this.Ws)
        }
        Ys(t) {
            t.type === fs.INITIAL_DOM &&
                (window.CSDomSerialized = window.CSDomSerialized
                    ? window.CSDomSerialized + 1
                    : 1)
        }
    }
    ss([$s("RecordingBatch.addEvent")], Js.prototype, "addEvent", null)
    class Xs {
        constructor() {
            this.Qs = 1
        }
        getCurrentIndex() {
            return this.Qs
        }
        increment() {
            this.Qs += 1
        }
        reset() {
            this.Qs = 1
        }
        getRequestParameters() {
            return { ri: `${this.Qs}` }
        }
    }
    class ti {
        emit(t, s, i, e = document) {
            const n = `${void 0 !== i ? `${i}` : `${ti.Js}`}${t}`,
                r = ti.createEvent(n, { detail: s })
            null !== r && e.dispatchEvent(r)
        }
        static createEvent(t, s = {}) {
            if ("function" == typeof CustomEvent) return new CustomEvent(t, s)
            const i = this.Xs()
            if (null === i) return null
            const { bubbles: e = !1, cancelable: n = !1, detail: r } = s
            return i.initCustomEvent(t, e, n, r), i
        }
        static Xs() {
            try {
                return document.createEvent("CustomEvent")
            } catch {
                return null
            }
        }
    }
    ti.Js = "cs.tracking."
    class si {
        constructor() {
            this.isStarted = !1
        }
        start(...t) {
            this.isStarted || ((this.isStarted = !0), this.onStart(...t))
        }
        stop() {
            this.isStarted && ((this.isStarted = !1), this.onStop())
        }
        restart() {
            this.stop(), this.start()
        }
    }
    var ii, ei, ni, ri
    !(function (t) {
        ;(t.BLOCKED_BY_CONSENT_NOT_EXPRESSED = "B"),
            (t.BLOCKED_BY_CONSENT_WITHDRAWN = "W"),
            (t.NOT_RECORDED = "0"),
            (t.TEMPORARILY_RECORDED = "T"),
            (t.GLOBAL_SAMPLING = "5"),
            (t.URL_SAMPLING = "6"),
            (t.ETR_SAMPLING = "7")
    })(ii || (ii = {})),
        (function (t) {
            ;(t.ETR_OFF = "0"), (t.ETR_ON = "1")
        })(ei || (ei = {})),
        (function (t) {
            ;(t.ETR_LEGACY = "0"), (t.ETR_SESSION = "1"), (t.ETR_PAGE = "2")
        })(ni || (ni = {}))
    class hi {
        constructor(t) {
            ;(this.type = "asyncEvent"),
                (this.ti = !1),
                t && t((t) => this.resolve(t))
        }
        resolve(t) {
            if (this.ti) throw new Error("AsyncEvent already resolve.")
            null == t.timestamp && (t = { ...t, timestamp: this.timestamp }),
                (this.si = t),
                (this.ti = !0),
                this.ii && this.ii(this.si)
        }
        complete(t) {
            this.ti && t(this.si), (this.ii = t)
        }
        wait() {
            return new Promise((t) => this.complete(t))
        }
    }
    class oi {
        constructor() {
            this.ei = 0
        }
        get length() {
            return this.ei
        }
        get isEmpty() {
            return !this.ni
        }
        pushAll(t) {
            for (let s = 0; s < t.length; s++) this.push(t[s])
        }
        push(t) {
            this.ei++,
                this.hi
                    ? (this.hi = this.hi[1] = [t, void 0])
                    : (this.hi = this.ni = [t, void 0])
        }
        pop() {
            if (!this.ni) return null
            this.ei--
            const t = this.ni[0]
            return (this.ni = this.ni[1]), this.ni || (this.hi = void 0), t
        }
        forEach(t) {
            let s = this.ni
            for (; null == s ? void 0 : s.length; ) t(s[0]), (s = s[1])
        }
        clear() {
            ;(this.ei = 0), (this.ni = this.hi = void 0)
        }
    }
    class ci {
        constructor(t) {
            ;(this.ii = t), (this.oi = new oi()), (this.ci = !1)
        }
        onEvent(t) {
            if (this.ii) throw new Error("callback already set")
            return (this.ii = t), this
        }
        push(t) {
            this.oi.push(t), this.ai()
        }
        static pipe(t, s) {
            let i = t
            for (const t of s) {
                const s = new ci((s) => {
                    t.pushEvent(s)
                })
                Hs(i, (t) => t.subscribe((t) => s.push(t))), (i = [t])
            }
            const e = new ci()
            return Hs(i, (t) => t.subscribe((t) => e.push(t))), e
        }
        ai() {
            if (this.ci) return
            if (((this.ci = !0), !this.ii)) throw new Error("callback not set")
            const t = this.oi.pop(),
                s = (t) => {
                    this.ii(t), (this.ci = !1), this.oi.isEmpty || this.ai()
                }
            t instanceof hi ? t.complete(s) : s(t)
        }
    }
    class ai {
        constructor(t, s = []) {
            ;(this.producers = t),
                (this.processors = s),
                (this.Ms = !1),
                (this.ui = []),
                (this.li = (t) =>
                    csArray.prototype.forEach.call(this.ui, (s) => s(t)))
        }
        start() {
            if (this.Ms) throw new Error("Recording is already started.")
            ci.pipe(this.producers, this.processors).onEvent(this.li),
                Hs(this.producers, (t) => t.start()),
                Hs(this.processors, (t) => t.start()),
                (this.Ms = !0)
        }
        stop() {
            for (const t of this.producers) t.stop()
            for (const t of this.processors) t.stop()
            ;(this.Ms = !1), (this.ui = [])
        }
        subscribe(t) {
            if (this.Ms) throw new Error("Recording is already started.")
            return (
                csArray.prototype.push.call(this.ui, t),
                () =>
                    (this.ui = csArray.prototype.filter.call(
                        this.ui,
                        (s) => s !== t
                    ))
            )
        }
    }
    class ui {
        constructor(t) {
            this.fi = t
        }
        start() {
            this.fi.subscribe((t) => {
                const s = t,
                    { timestamp: i } = s
                switch (s.type) {
                    case "Legacy":
                        this.ii(s.originalEvent)
                        break
                    case "CustomElementRegistration":
                        this.ii({
                            type: fs.CUSTOM_ELEMENT_REGISTRATION,
                            date: i,
                            args: [s.tagName],
                        })
                        break
                    case "DomEvent":
                        !(function (t, s) {
                            const { timestamp: i } = t
                            switch (t.domEvent) {
                                case "initialDOM": {
                                    const { initialDOM: e } = t
                                    s({
                                        type: fs.INITIAL_DOM,
                                        date: i,
                                        args: [e],
                                    })
                                    break
                                }
                                case "nodesAdded":
                                    csArray.prototype.forEach.call(
                                        t.nodes,
                                        (e) => {
                                            s({
                                                type: fs.MUTATION_INSERT,
                                                date: i,
                                                args: [
                                                    t.target,
                                                    t.nextSibling,
                                                    e,
                                                ],
                                            })
                                        }
                                    )
                                    break
                                case "nodesMoved":
                                    s({
                                        type: fs.MUTATION_MOVE,
                                        date: i,
                                        args: [
                                            t.target,
                                            t.nextSibling,
                                            t.nodesIds,
                                        ],
                                    })
                                    break
                                case "nodesRemoved":
                                    csArray.prototype.forEach.call(
                                        t.nodesIds,
                                        (t) => {
                                            s({
                                                type: fs.MUTATION_REMOVE,
                                                date: i,
                                                args: [t],
                                            })
                                        }
                                    )
                                    break
                                case "attributeChanged": {
                                    const {
                                        target: e,
                                        namespace: n,
                                        attribute: r,
                                        newValue: h,
                                    } = t
                                    s({
                                        type: fs.MUTATION_ATTRIBUTE,
                                        date: i,
                                        args: [e, n, r, h],
                                    })
                                    break
                                }
                                case "characterDataChanged": {
                                    const { target: e, newValue: n } = t
                                    s({
                                        type: fs.MUTATION_CHARACTER_DATA,
                                        date: i,
                                        args: [e, n],
                                    })
                                    break
                                }
                                case "cssRuleInserted": {
                                    const { target: e, rule: n, index: r } = t,
                                        h = St(r) ? [e, n, r] : [e, n]
                                    s({
                                        type: fs.STYLESHEET_RULE_INSERT,
                                        date: i,
                                        args: h,
                                    })
                                    break
                                }
                                case "cssRuleDeleted": {
                                    const { target: e, index: n } = t
                                    s({
                                        type: fs.STYLESHEET_RULE_DELETE,
                                        date: i,
                                        args: [e, n],
                                    })
                                    break
                                }
                                case "shadowRootAttached": {
                                    const { target: e, shadowRoot: n } = t
                                    s({
                                        type: fs.ATTACH_SHADOW,
                                        date: i,
                                        args: [e, n],
                                    })
                                    break
                                }
                                case "adoptedStyleSheetRegistered": {
                                    const { sheetId: e, cssRules: n } = t
                                    s({
                                        type: fs.REGISTER_ADOPTED_STYLE_SHEET,
                                        date: i,
                                        args: [e, n],
                                    })
                                    break
                                }
                                case "adoptedStyleSheetsSet": {
                                    const { target: e, sheetsIds: n } = t
                                    s({
                                        type: fs.SET_ADOPTED_STYLE_SHEETS,
                                        date: i,
                                        args: [e, n],
                                    })
                                    break
                                }
                                case "adoptedStyleSheetRuleInserted": {
                                    const { sheetId: e, rule: n, index: r } = t,
                                        h = St(r) ? [e, n, r] : [e, n]
                                    s({
                                        type: fs.ADOPTED_STYLESHEET_RULE_INSERT,
                                        date: i,
                                        args: h,
                                    })
                                    break
                                }
                                case "adoptedStyleSheetRuleDeleted": {
                                    const { sheetId: e, index: n } = t
                                    s({
                                        type: fs.ADOPTED_STYLESHEET_RULE_DELETE,
                                        date: i,
                                        args: [e, n],
                                    })
                                    break
                                }
                                default:
                                    Jt.error(
                                        "translateDOMEvent: DOMEvent not supported"
                                    )
                            }
                        })(s, this.ii)
                        break
                    case "TextVisibility":
                        break
                    case "encryptedCharacterDataEvent": {
                        const {
                            target: t,
                            rawData: e,
                            encryptedData: n,
                            encryptionMetadata: r,
                        } = s
                        this.ii({
                            type: fs.MUTATION_ENCRYPTED_CHARACTER_DATA,
                            date: i,
                            args: [t, e, n, r],
                        })
                        break
                    }
                    case "StaticResource": {
                        const { url: t } = s
                        this.ii({
                            type: fs.STATIC_RESOURCE_URL,
                            date: i,
                            args: [t],
                        })
                        break
                    }
                    default:
                        Jt.error(
                            "WebRecorderEventTranslator: Event not supported"
                        )
                }
            }),
                this.fi.start()
        }
        stop() {
            this.fi.stop()
        }
        onEvent(t) {
            this.ii = t
        }
    }
    class li {
        constructor() {
            this.wi = []
        }
        produceEvent(t) {
            var s
            ;(null !== (s = t.timestamp) && void 0 !== s) ||
                (t.timestamp = pt.now()),
                csArray.prototype.forEach.call(this.wi, (s) => s(t))
        }
        stop() {
            this.wi = []
        }
        subscribe(t) {
            return (
                csArray.prototype.push.call(this.wi, t),
                () => {
                    const s = csArray.prototype.indexOf.call(this.wi, t)
                    csArray.prototype.splice.call(this.wi, s, 1)
                }
            )
        }
    }
    class di extends li {
        constructor(t) {
            super(), (this.pi = t)
        }
        subscribe(t) {
            return super.subscribe(t)
        }
        start() {
            Hs(this.pi, (t) => {
                t.onEvent((t) => this.li(t))
            }),
                Hs(this.pi, (t) => {
                    var s
                    null === (s = t.start) || void 0 === s || s.call(t)
                })
        }
        stop() {
            Hs(this.pi, (t) => {
                var s
                return null === (s = t.stop) || void 0 === s
                    ? void 0
                    : s.call(t)
            }),
                super.stop()
        }
        li(t) {
            this.produceEvent({
                timestamp: pt.now(),
                type: "Legacy",
                originalEvent: t,
            })
        }
    }
    !(function (t) {
        ;(t.Visible = "visible"),
            (t.Hidden = "hidden"),
            (t.Blur = "blur"),
            (t.PagehideVisible = "pagehideVisible"),
            (t.PagehideHidden = "pagehideHidden")
    })(ri || (ri = {}))
    class fi {
        constructor() {
            ;(this.mi = !1),
                (this.Ei = (t) => {
                    try {
                        switch (t.type) {
                            case "visibilitychange":
                                if ("hidden" === document.visibilityState)
                                    return this.yi(ri.Hidden)
                                break
                            case "pagehide":
                                return "hidden" === document.visibilityState
                                    ? this.yi(ri.PagehideHidden)
                                    : this.yi(ri.PagehideVisible)
                            case "blur":
                                return this.yi(ri.Blur)
                            default:
                                return
                        }
                    } catch {}
                })
        }
        start() {
            this.mi || ((this.mi = !0), this.Ai(), this.gi(), this.vi())
        }
        stop() {
            this.mi && ((this.mi = !1), this._i(), this.Ri(), this.Si())
        }
        onEvent(t) {
            this.yi = t
        }
        Ai() {
            document.addEventListener("visibilitychange", this.Ei)
        }
        _i() {
            document.removeEventListener("visibilitychange", this.Ei)
        }
        gi() {
            window.addEventListener("pagehide", this.Ei)
        }
        Ri() {
            window.removeEventListener("pagehide", this.Ei)
        }
        vi() {
            window.addEventListener("blur", this.Ei)
        }
        Si() {
            window.removeEventListener("blur", this.Ei)
        }
    }
    function wi(t, s, i, e) {
        var n,
            r = arguments.length,
            h =
                r < 3
                    ? s
                    : null === e
                    ? (e = Object.getOwnPropertyDescriptor(s, i))
                    : e
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            h = Reflect.decorate(t, s, i, e)
        else
            for (var o = t.length - 1; o >= 0; o--)
                (n = t[o]) &&
                    (h = (r < 3 ? n(h) : r > 3 ? n(s, i, h) : n(s, i)) || h)
        return r > 3 && h && Object.defineProperty(s, i, h), h
    }
    Object.create
    Object.create
    "function" == typeof SuppressedError && SuppressedError
    let pi = 0
    function mi(t) {
        return "$$" + t + ++pi
    }
    mi.asyncIterator = "$$asyncIterator"
    const Ei = xt("Symbol", mi)
    var yi
    const Ai = () => (t, s, i) => {
            i.value = (function (t) {
                const s = Ei("oncePerTickSymbol")
                let i = null
                const e = {},
                    n = function () {
                        var n
                        const r = null !== (n = this) && void 0 !== n ? n : e
                        if (((i = arguments), r[s])) return
                        r[s] = !0
                        gi(() => {
                            ;(r[s] = !1), t.apply(r, i)
                        })
                    }
                return (n.oncePerTickSymbol = s), n
            })(i.value)
        },
        gi =
            null !== (yi = window.queueMicrotask) && void 0 !== yi
                ? yi
                : setTimeout
    Ai.isScheduled = (t, s) => t[s.oncePerTickSymbol]
    class vi {
        constructor(t) {
            ;(this.ii = t),
                (this.Ti = new Map()),
                (this.Ii = (t) => {
                    const s = t.target
                    if (this.Ti.has(s)) return !0
                    let i = !1
                    return (
                        this.Ti.forEach((t, e) => {
                            !i && this.Ti.get(e).subtree && (i = e.contains(s))
                        }),
                        i
                    )
                }),
                (this.ks = new csMutationObserver((s) => {
                    Ai.isScheduled(this, this.garbageCollect) &&
                        (s = js(s, this.Ii)),
                        s.length && Ws(() => t(s, this))
                }))
        }
        disconnect() {
            this.ks.disconnect(), (this.Ti = new Map())
        }
        takeRecords() {
            return this.ks.takeRecords()
        }
        observe(t, s) {
            return this.Ti.set(t, s), this.ks.observe(t, s)
        }
        unobserve(t) {
            this.Ti.has(t) && (this.Ti.delete(t), this.garbageCollect())
        }
        garbageCollect() {
            const t = js(this.takeRecords(), this.Ii)
            t.length && this.ii(t, this),
                this.ks.disconnect(),
                this.Ti.forEach((t, s) => this.ks.observe(s, t))
        }
    }
    function _i() {
        const t = new Error()
        let s = t.stack
            ? csArray.prototype.filter.call(
                  csString.prototype.split.call(t.stack, "\n"),
                  (t) =>
                      "Error" !== t &&
                      -1 ===
                          csString.prototype.indexOf.call(
                              csString.prototype.toLowerCase.call(t),
                              "promise "
                          ) &&
                      -1 === csString.prototype.indexOf.call(t, "[native code]")
              )
            : []
        if (0 === s.length) return ""
        const i = (function (t) {
            return t.length > 0 ? Ri(t[0]) : ""
        })(s)
        return "" === i
            ? ""
            : ((s = (function (t, s) {
                  return csArray.prototype.filter.call(
                      t,
                      (t) => -1 === csString.prototype.indexOf.call(t, s)
                  )
              })(s, i)),
              0 === s.length ? "" : Ri(s[0]))
    }
    function Ri(t) {
        let s,
            i = ""
        var e
        ;(e = t),
            (s =
                -1 !== csString.prototype.indexOf.call(e, "@")
                    ? new RegExp("@(.+):(\\d+):(\\d+)$")
                    : new RegExp("\\((.+):(\\d+):(\\d+)\\)"))
        const n = s.exec(t)
        return n && (i = n[1]), i
    }
    wi([Ai()], vi.prototype, "garbageCollect", null)
    const Si = (t) => t
    function Ti({
        target: t,
        methodName: s,
        hook: i,
        hookPrepareArgs: e = Si,
        options: n,
    }) {
        var r
        if (
            !(null === (r = Object.getOwnPropertyDescriptor(t, s)) ||
            void 0 === r
                ? void 0
                : r.writable)
        )
            return (
                Xt.warn(
                    `Cannot intercept read only function '${csString(
                        s
                    )}' of object '${t}'`
                ),
                null
            )
        let h = !1
        const o = t[s]
        if ("function" == typeof o) {
            const r = function () {
                const t = e(arguments),
                    s = o.apply(this, arguments)
                if (h) {
                    let e
                    n && n.withCallerName && (e = _i())
                    try {
                        i({ result: s, context: this, args: t, callerName: e })
                    } catch (t) {
                        Xt.error(t)
                    }
                }
                return s
            }
            ;(a = o),
                ((c = r).prototype = a.prototype),
                Object.defineProperty(c, "toString", {
                    value: () => a.toString(),
                }),
                (t[s] = r)
        }
        var c, a
        return { activate: () => (h = !0), deactivate: () => (h = !1) }
    }
    function Ii(t, s, i) {
        let e = !1
        const n = Object.getOwnPropertyDescriptor(t, s)
        if (n) {
            if (!n.configurable)
                return (
                    Xt.warn(
                        `Cannot intercept read only property '${csString(
                            s
                        )}' of object '${t}'`
                    ),
                    null
                )
            const r = function () {
                    return n.get.apply(this, arguments)
                },
                h = function () {
                    const t = arguments,
                        s = n.set.apply(this, t)
                    if (e)
                        try {
                            i(this, t[0])
                        } catch (t) {
                            Xt.error(t)
                        }
                    return s
                }
            Object.defineProperty(t, s, {
                ...(n.get ? { get: r } : {}),
                ...(n.set ? { set: h } : {}),
            })
        }
        return { activate: () => (e = !0), deactivate: () => (e = !1) }
    }
    function Pi() {
        const t = new Set()
        return {
            add: function (s) {
                t.add(s),
                    1 === t.size &&
                        setTimeout(() => {
                            t.clear()
                        })
            },
            has: function (s) {
                return t.has(s)
            },
            del: function (s) {
                t.delete(s)
            },
            values: () =>
                (function (t) {
                    const s = []
                    return (
                        t.forEach((t) => csArray.prototype.push.call(s, t)), s
                    )
                })(t),
            get count() {
                return t.size
            },
        }
    }
    var bi, Vi, Ci
    !(function (t) {
        ;(t.isSupported = function () {
            return !!Element.prototype.attachShadow
        }),
            (t.getShadowRoot = function (t) {
                return t && I(t) ? t.shadowRoot : null
            }),
            (t.getAllShadowHosts = function (t) {
                const s = []
                if (!((t) => t.querySelectorAll)(t)) return []
                const i = (t, s) => {
                        Hs(
                            window.csquerySelectorAll[t.nodeType].call(t, "*"),
                            s
                        )
                    },
                    e = (t) => {
                        csElementshadowRoot.apply(t) &&
                            (csArray.prototype.push.call(s, t),
                            i(csElementshadowRoot.apply(t), e))
                    }
                return (
                    ((t) => t.shadowRoot)(t) &&
                        (csArray.prototype.push.call(s, t),
                        i(csElementshadowRoot.apply(t), e)),
                    i(t, e),
                    s
                )
            })
    })(bi || (bi = {})),
        (function (t) {
            function s() {
                const t = [e()]
                return (
                    document.documentElement &&
                        csArray.prototype.push.call(
                            t,
                            document.documentElement.scrollHeight,
                            document.documentElement.offsetHeight,
                            document.documentElement.clientHeight
                        ),
                    document.body &&
                        csArray.prototype.push.call(
                            t,
                            document.body.scrollHeight,
                            document.body.offsetHeight
                        ),
                    Math.max(...t)
                )
            }
            function i() {
                return document.documentElement.scrollWidth
            }
            function e() {
                return window.innerHeight
            }
            function n() {
                return window.innerWidth
            }
            function r() {
                const t = window.csScreen.width
                return vt(t) && t > 0 ? t : window.screen.width
            }
            function h() {
                const t = window.csScreen.height
                return vt(t) && t > 0 ? t : window.screen.height
            }
            ;(t.documentHeight = s),
                (t.documentWidth = i),
                (t.windowHeight = e),
                (t.windowWidth = n),
                (t.screenWidth = r),
                (t.screenHeight = h),
                (t.windowOffsetX = function () {
                    return window.pageXOffset
                }),
                (t.windowOffsetY = function () {
                    return window.pageYOffset
                }),
                (t.getRequestParameters = function () {
                    return {
                        dw: `${i()}`,
                        dh: `${s()}`,
                        ww: `${n()}`,
                        wh: `${e()}`,
                        sw: `${r()}`,
                        sh: `${h()}`,
                    }
                })
        })(Vi || (Vi = {}))
    const Ni = null !== (Ci = Lt.Node) && void 0 !== Ci ? Ci : Object
    var Oi
    !(function (t) {
        const s =
            "isConnected" in Ni.prototype
                ? (t) => t.isConnected
                : (t) =>
                      !(
                          t.ownerDocument &&
                          t.ownerDocument.compareDocumentPosition(t) &
                              t.DOCUMENT_POSITION_DISCONNECTED
                      )
        function i(t) {
            var s
            return t.parentElement
                ? t.parentElement
                : t.getRootNode
                ? null === (s = t.getRootNode()) || void 0 === s
                    ? void 0
                    : s.host
                : null
        }
        function e(t) {
            var s, i
            if (
                !1 ===
                (null === (s = t.checkVisibility) || void 0 === s
                    ? void 0
                    : s.call(t, { checkOpacity: !0, checkVisibilityCSS: !0 }))
            )
                return !0
            if (!t.offsetParent) {
                if (!t.getBoundingClientRect)
                    return (
                        Xt.warn(
                            `SUP-11432: Element doesn't have getBoundingClientRect. Node: ${
                                t instanceof Ni
                            } Ctor: ${
                                null ===
                                    (i = null == t ? void 0 : t.constructor) ||
                                void 0 === i
                                    ? void 0
                                    : i.name
                            }`
                        ),
                        !1
                    )
                const s = t.getBoundingClientRect()
                if (0 == s.width && 0 == s.height) return !0
            }
            const e = window.getComputedStyle(t)
            if (!e) return !0
            var n
            return (
                "none" === e.display ||
                "hidden" === e.visibility ||
                "collapse" === e.visibility ||
                "0" === e.opacity ||
                "opacity(0)" === e.filter ||
                ("0px" === e.width && "0px" === e.height) ||
                "transparent" === (n = e.color) ||
                /^(rgba|hsla)\(\d+, \d+%?, \d+%?, 0\)$/.test(n)
            )
        }
        function n(t) {
            const s = t.getBoundingClientRect(),
                i = s.left + 0.5 * s.width,
                e = s.top + 0.5 * s.height
            return r(document, i, e)
        }
        function r(t, s, i) {
            const e = t.elementFromPoint(s, i)
            if (!e) return null
            const n = bi.getShadowRoot(e)
            return n && n != document.body.getRootNode() && n !== t
                ? r(n, s, i)
                : e
        }
        function h(t) {
            const s = n(t)
            return null !== s && (t === s || t.contains(s))
        }
        ;(t.forEachChild = function (t, s) {
            for (let i = t; i; i = csNodenextSibling.apply(i)) s(t)
        }),
            (t.isConnected = function (t) {
                return s(t)
            }),
            (t.getAncestors = function (t, s) {
                const i = [],
                    e = (t) => {
                        csArray.prototype.push.call(i, t)
                        const s = t.getRootNode()
                        let e = t
                        for (
                            ;
                            (null == e ? void 0 : e.parentElement) &&
                            e.parentElement !== s;

                        )
                            csArray.prototype.push.call(i, e.parentElement),
                                (e = e.parentElement)
                        return csArray.prototype.push.call(i, s), i
                    }
                if (s) {
                    let s = t
                    for (; s; ) {
                        e(s)
                        const t = s.getRootNode()
                        if (!(t instanceof ShadowRoot)) break
                        s = t.host
                    }
                } else e(t)
                return i
            }),
            (t.isDescendantOf = function s(i, e) {
                if (i === e || e.contains(i)) return !0
                const n = t.getParentElement(i)
                return !(!n || n === i) && s(n, e)
            }),
            (t.getParentElement = i),
            (t.findAllElements = function (t, s = document) {
                const i = Fs(window.csquerySelectorAll[s.nodeType].call(s, t)),
                    e = bi.getAllShadowHosts(s)
                for (const s of e) {
                    const e = csElementshadowRoot.apply(s),
                        n = Fs(window.csquerySelectorAll[e.nodeType].call(e, t))
                    csArray.prototype.push.call(i, ...n)
                }
                return i
            }),
            (t.isHiddenByCSS = e),
            (t.areAncestorsHiddenByCSS = function t(s) {
                if (e(s)) return !0
                const n = i(s)
                return null != n && t(n)
            }),
            (t.getTopAncestorHiddenByCSS = function (t) {
                let s = null,
                    n = t
                do {
                    if (!e(n)) break
                    s = n
                } while ((n = i(n)))
                return s
            }),
            (t.getTopElement = n),
            (t.getElementOnTop = function (s) {
                if (!s.getBoundingClientRect) return null
                const i = s.getBoundingClientRect(),
                    e = i.x + i.width / 2,
                    n = i.y + i.height / 2
                return t.getTopElementFromPoint(document, e, n)
            }),
            (t.getTopElementFromPoint = r),
            (t.isVisibleInDocument = function (t) {
                return (
                    !(function (t) {
                        const s = t.getBoundingClientRect()
                        return (
                            s.right + Vi.windowOffsetX() < 0 ||
                            s.bottom + Vi.windowOffsetY() < 0
                        )
                    })(t) &&
                    !e(t) &&
                    !(function (t) {
                        const s = n(t)
                        return null !== s && !t.contains(s)
                    })(t)
                )
            }),
            (t.isVisibleInViewportInForeground = function (t) {
                return !e(t) && h(t)
            }),
            (t.isInViewPort = h),
            (t.getAttributeNS = function (t, s, i) {
                const e = t.getAttributeNS(s, i)
                return "" === e ? (t.hasAttributeNS(s, i) ? e : null) : e
            }),
            (t.isElementFocusable = function (t) {
                return (
                    !!t.hasAttribute("tabIndex") ||
                    "true" === t.getAttribute("contentEditable") ||
                    !(!w(t) || !t.hasAttribute("href")) ||
                    !(
                        !(
                            _(t) ||
                            A(t) ||
                            y(t) ||
                            ((s = t), u(s) && "button" === s.localName)
                        ) || t.hasAttribute("disabled")
                    ) ||
                    !(
                        !(function (t) {
                            return u(t) && "details" === t.localName
                        })(t) &&
                        !(function (t) {
                            return u(t) && "summary" === t.localName
                        })(t)
                    )
                )
                var s
            })
    })(Oi || (Oi = {}))
    class ki {
        constructor(t) {
            ;(this.ii = t),
                (this.Pi = []),
                (this.bi = Pi()),
                (this.ii = (s, i) => {
                    "initial" === i
                        ? t(s, i)
                        : this.bi.has(s) || (t(s, i), this.bi.add(s))
                }),
                this.Vi()
        }
        observe(t) {
            csArray.prototype.push.call(this.Pi, t), this.Ci(), this.Ni(t, !0)
            this.ks.observe(t, { subtree: !0, childList: !0 })
        }
        disconnect() {
            ;(this.Pi = []),
                this.ks.disconnect(),
                this.Oi && this.Oi.deactivate()
        }
        Ci() {
            this.Oi ||
                (this.Oi = Ti({
                    target: Element.prototype,
                    methodName: "attachShadow",
                    hook: (t) =>
                        qs(this.Pi, (s) =>
                            Oi.isDescendantOf(t.result.host, s)
                        ) && this.ii(t.result, "added"),
                })),
                this.Oi.activate()
        }
        Ni(t, s) {
            Hs(bi.getAllShadowHosts(t), (t) => {
                this.ii(csElementshadowRoot.apply(t), s ? "initial" : "added"),
                    this.ks.observe(csElementshadowRoot.apply(t), {
                        subtree: !0,
                        childList: !0,
                    })
            })
        }
        Vi() {
            this.ks = new vi((t) => {
                Ws(() => {
                    for (const s of t)
                        Hs(s.addedNodes, (t) => this.Ni(t, !1)),
                            Bs(s.removedNodes, bi.getAllShadowHosts, (t) => {
                                this.ii(
                                    csElementshadowRoot.apply(t),
                                    "removed"
                                ),
                                    this.ks.unobserve(
                                        csElementshadowRoot.apply(t)
                                    )
                            })
                })
            })
        }
    }
    const $i = Lt.ShadowRoot
        ? class extends vi {
              constructor(t) {
                  super((s) => t(s, this)), (this.ki = new Map())
              }
              observe(t, s) {
                  super.observe(t, s), s.subtree && this.$i(s).observe(t)
              }
              disconnect() {
                  super.disconnect(), this.ki.forEach((t) => t.disconnect())
              }
              $i(t) {
                  const s = (s, i) => {
                          "added" === i || "initial" === i
                              ? super.observe(s, t)
                              : "removed" === i && super.unobserve(s)
                      },
                      i =
                          ((e = t),
                          csJSON.stringify(
                              e,
                              csArray.prototype.sort.call(Object.keys(e))
                          ))
                  var e
                  let n = this.ki.get(i)
                  return n || this.ki.set(i, (n = new ki(s))), n
              }
          }
        : Lt.csMutationObserver
    var Li, xi
    function Mi(t, s = zi.SHOW_ALL) {
        var i
        const e = s | zi.SHOW_ELEMENT,
            n = [document.createTreeWalker(t, e, null, !1)]
        t instanceof Element &&
            (null === (i = csElementshadowRoot.apply(t)) || void 0 === i
                ? void 0
                : i.firstElementChild) &&
            csArray.prototype.push.call(
                n,
                document.createTreeWalker(
                    csElementshadowRoot.apply(t),
                    e,
                    null,
                    !1
                )
            )
        let r = null
        return {
            root: t,
            nextNode() {
                for (; n.length > 0; ) {
                    if (s === zi.SHOW_ALL && r) {
                        const t = r
                        return (r = null), t
                    }
                    const t = n[n.length - 1].nextNode()
                    if (!t) {
                        csArray.prototype.pop.call(n)
                        continue
                    }
                    const i = Di(t)
                    if (
                        (s === zi.SHOW_ALL && (r = i),
                        i &&
                            csArray.prototype.push.call(
                                n,
                                document.createTreeWalker(i, e, null, !1)
                            ),
                        0 != (Fi[t.nodeType] & s))
                    )
                        return t
                }
                return null
            },
            visitAll(s) {
                s(t)
                let i = this.nextNode()
                for (; i; ) s(i), (i = this.nextNode())
            },
        }
    }
    function Di(t) {
        return t && I(t) ? t.shadowRoot : null
    }
    const Ui = null !== (Li = Lt.Node) && void 0 !== Li ? Li : {},
        zi = null !== (xi = Lt.NodeFilter) && void 0 !== xi ? xi : {},
        Fi = {
            2: zi.SHOW_ATTRIBUTE,
            4: zi.SHOW_CDATA_SECTION,
            8: zi.SHOW_COMMENT,
            11: zi.SHOW_DOCUMENT_FRAGMENT,
            9: zi.SHOW_ALL,
            10: zi.SHOW_DOCUMENT_TYPE,
            1: zi.SHOW_ELEMENT,
            [Ui.ENTITY_NODE]: zi.SHOW_ENTITY,
            [Ui.ENTITY_REFERENCE_NODE]: zi.SHOW_ENTITY_REFERENCE,
            [Ui.NOTATION_NODE]: zi.SHOW_NOTATION,
            7: zi.SHOW_PROCESSING_INSTRUCTION,
            3: zi.SHOW_TEXT,
        }
    class Bi {
        constructor(t) {
            ;(this.ii = t), (this.Li = new $i((t) => Ws(() => this.xi(t))))
        }
        observe(t = document) {
            this.Li.observe(t, { childList: !0, subtree: !0 })
            Mi(t, NodeFilter.SHOW_ELEMENT).visitAll((t) => {
                u(t) && this.ii(t)
            })
        }
        disconnect() {
            this.Li.disconnect()
        }
        xi(t) {
            const s = new Set()
            for (const i of t)
                Hs(i.addedNodes, (t) => {
                    if (s.has(t)) return
                    Mi(t, NodeFilter.SHOW_ELEMENT).visitAll((t) => {
                        !s.has(t) && u(t) && this.ii(t)
                    })
                })
        }
    }
    class Hi extends li {
        constructor() {
            super(),
                (this.Mi =
                    "object" == typeof window.customElements &&
                    "function" == typeof window.customElements.whenDefined &&
                    "function" == typeof window.Promise),
                (this.Di = (t) => {
                    for (const i of t)
                        u((s = i)) &&
                            csString.prototype.indexOf.call(s.tagName, "-") >
                                0 &&
                            -1 ===
                                csString.prototype.indexOf.call(
                                    s.tagName,
                                    ":"
                                ) &&
                            -1 ===
                                csString.prototype.indexOf.call(
                                    s.tagName,
                                    '"'
                                ) &&
                            -1 ===
                                csString.prototype.indexOf.call(
                                    s.tagName,
                                    ","
                                ) &&
                            csArray.prototype.indexOf.call(
                                P,
                                csString.prototype.toLocaleLowerCase.call(
                                    s.tagName
                                )
                            ) < 0 &&
                            this.Ui(
                                csString.prototype.toLowerCase.call(i.tagName)
                            )
                    var s
                })
            const t = (function (t) {
                const s = Pi()
                return {
                    push(i) {
                        0 === s.count &&
                            setTimeout(() => {
                                t(s.values())
                            }),
                            s.add(i)
                    },
                }
            })(this.Di)
            ;(this.zi = new Bi((s) => t.push(s))), (this.Fi = new Set())
        }
        start() {
            this.Mi && this.zi.observe()
        }
        stop() {
            this.Fi.clear(), this.zi.disconnect()
        }
        async Ui(t) {
            this.Fi.has(t) ||
                (this.Fi.add(t),
                await window.customElements.whenDefined(t),
                this.produceEvent({
                    type: "CustomElementRegistration",
                    tagName: csString.prototype.toLowerCase.call(t),
                }))
        }
    }
    class qi extends si {
        constructor(
            t,
            s,
            i,
            e,
            n,
            r,
            h,
            o,
            c,
            a,
            u,
            l,
            d,
            f,
            w,
            p,
            m,
            E,
            y,
            A = [],
            g
        ) {
            super(),
                (this.$ = t),
                (this.Bi = s),
                (this.Hi = i),
                (this.qi = e),
                (this.ji = n),
                (this.Gi = r),
                (this.Zi = h),
                (this.Wi = o),
                (this.Ki = c),
                (this.Yi = a),
                (this.W = u),
                (this.Qi = l),
                (this.Ji = d),
                (this.Xi = f),
                (this.te = w),
                (this.se = p),
                (this.ie = m),
                (this.ee = E),
                (this.ne = y),
                (this.pi = A),
                (this.re = g),
                (this.he = 0),
                (this.oe = 0),
                (this.ce = 0),
                (this.ae = new ti()),
                (this.ue = {
                    allowFromQuotaService: !0,
                    allowFromSerialization: !0,
                }),
                (this.le = Ss(() => {
                    this.Bi.eventsCount() > 0 && this.de()
                }, 2e3)),
                (this.fe = (t) => this.processBrowserEvent(t)),
                (this.we = (t) => this.pe(t)),
                (this.Ee = 0),
                (this.ye = 0),
                (this.Ae = new fi()),
                (this.ge = !1),
                (this.ve = 51200),
                (this._e = !1),
                (this.Re = !1),
                (this.Se = []),
                (this.Te = (t) => {
                    this.ee.removeBatchInProgress(
                        `${t.params.sn}.${t.params.pn}.${t.params.ri}`
                    )
                }),
                (this.fi = new ai([
                    new di(
                        csArray.prototype.filter.call(
                            [this.Gi, ...this.pi],
                            (t) => t
                        )
                    ),
                    new Hi(),
                ])),
                (this.Ie = new ui(this.fi)),
                this.Ie.onEvent(this.fe)
        }
        init() {
            this.Pe(), this.ie.onLoad(this.Te), this.ie.onError(this.Te)
        }
        Pe() {
            var t, s, i, e
            this.Zi.onEvent(this.we),
                this.Wi.onEvent(this.we),
                this.Ki.onEvent(this.we),
                null === (t = this.se) ||
                    void 0 === t ||
                    t.onTextNodeToEncrypt(this.fe),
                null === (s = this.se) ||
                    void 0 === s ||
                    s.onApiErrorToEncrypt((t) => {
                        this.be(t)
                    }),
                null === (i = this.se) ||
                    void 0 === i ||
                    i.onUserIdentifierToEncrypt(this.fe),
                null === (e = this.ne) || void 0 === e || e.onEvent(this.fe),
                this.Ae.onEvent((t) =>
                    t === ri.Blur
                        ? this.Ve()
                        : this.ge
                        ? void 0
                        : ((this.ge = !0),
                          setTimeout(() => {
                              this.ge = !1
                          }),
                          t === ri.Hidden ? this.Ve() : this.Ce())
                )
        }
        isRecording() {
            return this.W.hasValidSession() && this.isStarted
        }
        Ve() {
            if (!this.canSendEvents()) return
            this.ee.saveBatchesInProgress(),
                Hs(this.pi, (t) => {
                    var s, i
                    return Hs(
                        null !==
                            (i =
                                null === (s = t.getPendingEvents) ||
                                void 0 === s
                                    ? void 0
                                    : s.call(t)) && void 0 !== i
                            ? i
                            : [],
                        (t) => this.Bi.addEvent(t)
                    )
                })
            const t = this.Bi.getEvents()
            if (0 === t.length) return
            const s = this.ie.getQueryParams()
            ;(s.rst = this.getRecordingStartTimestamp()),
                (s.let = this.getRecordingLastEventTimestamp())
            const i = this.qi.getCurrentIndex()
            ;(s.ri = i.toString()),
                this.re.removeQueryParams(),
                this.re.setQueryParams(s),
                (this.ye = t[t.length - 1].date)
            const e = this.Bi.stringifyEvents()
            if (e.length > this.ve) {
                const t = this.Ne()
                if (t.length > 0) {
                    const i = J(t)
                    this.re.send(i) ||
                        this.ee.save({
                            key: `${s.sn}.${s.pn}.${s.ri}.last`,
                            metadata: { ...s, datatype: "json" },
                            events: i,
                        }),
                        this.qi.increment()
                }
                if (this.Bi.eventsCount() > 0) {
                    s.ri = this.qi.getCurrentIndex().toString()
                    const t = this.Bi.stringifyEvents()
                    this.ee.save({
                        key: `${s.sn}.${s.pn}.${s.ri}.last`,
                        metadata: { ...s, datatype: "json" },
                        events: t,
                    }),
                        this.qi.increment()
                }
            } else {
                this.re.send(e) ||
                    this.ee.save({
                        key: `${s.sn}.${s.pn}.${s.ri}.last`,
                        metadata: { ...s, datatype: "json" },
                        events: e,
                    }),
                    this.qi.increment()
            }
            this.re.removeQueryParams(), this.Bi.clearEvents()
        }
        Ce() {
            if (!this.canSendEvents()) return
            const t = this.ie.getQueryParams()
            this.ee.saveBatchesInProgress(),
                (t.rst = this.getRecordingStartTimestamp()),
                delete t.ri,
                (t.hlm = "true"),
                this.re.removeQueryParams(),
                Hs(this.pi, (t) => {
                    var s, i
                    return Hs(
                        null !==
                            (i =
                                null === (s = t.getPendingEvents) ||
                                void 0 === s
                                    ? void 0
                                    : s.call(t)) && void 0 !== i
                            ? i
                            : [],
                        (t) => this.Bi.addEvent(t)
                    )
                })
            const s = this.Bi.getEvents()
            if (0 === s.length)
                return (
                    delete t.let,
                    delete t.rst,
                    this.re.setQueryParams(t),
                    this.re.send(),
                    void this.re.removeQueryParams()
                )
            ;(this.ye = s[s.length - 1].date),
                (t.let = this.getRecordingLastEventTimestamp()),
                this.re.setQueryParams(t)
            const i = this.Bi.stringifyEvents()
            if (i.length > this.ve) {
                const s = this.Ne()
                if (s.length > 0) {
                    const i = J(s)
                    this.re.send(i) ||
                        this.ee.save({
                            key: `${t.sn}.${t.pn}.last`,
                            metadata: { ...t, datatype: "json" },
                            events: i,
                        })
                } else
                    delete t.let,
                        delete t.rst,
                        delete t.ri,
                        this.re.removeQueryParams(),
                        this.re.setQueryParams(t),
                        this.re.send(),
                        this.re.removeQueryParams()
                if (this.Bi.eventsCount() > 0) {
                    ;(t.rst = this.getRecordingStartTimestamp()),
                        (t.let = this.getRecordingLastEventTimestamp())
                    const s = this.qi.getCurrentIndex()
                    t.ri = s.toString()
                    const i = this.Bi.stringifyEvents()
                    this.ee.save({
                        key: `${t.sn}.${t.pn}.${t.ri}.last`,
                        metadata: { ...t, datatype: "json" },
                        events: i,
                    }),
                        this.qi.increment()
                }
            } else {
                this.re.send(i) ||
                    (this.ee.save({
                        key: `${t.sn}.${t.pn}.${t.ri}.last`,
                        metadata: { ...t, datatype: "json" },
                        events: i,
                    }),
                    this.qi.increment())
            }
            this.re.removeQueryParams(), this.Bi.clearEvents()
        }
        isMutationTrackerStarted() {
            return this.Gi.isStarted()
        }
        blockSendingEventsFromQuotaService() {
            this.ue.allowFromQuotaService = !1
        }
        allowSendingEventsFromQuotaService() {
            this.ue.allowFromQuotaService = !0
        }
        blockSendingEventsFromSerialization() {
            this.ue.allowFromSerialization = !1
        }
        allowSendingEventsFromSerialization() {
            this.ue.allowFromSerialization = !0
        }
        canSendEvents() {
            return (
                this.ue.allowFromQuotaService && this.ue.allowFromSerialization
            )
        }
        onIframeJavascriptError(t) {
            this.Oe(t)
        }
        onIframeDetailedApiError(t) {
            this.ke(t)
        }
        onIframeRecordingUserEvent(t) {
            for (const s of t) this.pe(s)
        }
        onIframeRecordingBrowserEvent(t) {
            if (this.isMutationTrackerStarted())
                for (const s of t) this.processBrowserEvent(s)
        }
        processBrowserEvent(t) {
            this.Yi.isCurrentPageviewValid() && this.$e(t)
        }
        pe(t) {
            this.Yi.isSessionValid() && this.$e(t)
        }
        $e(t) {
            this.Bi.addEvent(t)
            this.Bi.isThresholdReached()
                ? this.pushEvents()
                : this.Bi.isFull() && this.le(),
                this.Le(t)
        }
        Le(t) {
            this.$.emitDebugEvents &&
                this.ae.emit("recordingEvent", { ...t, typeName: fs[t.type] })
        }
        onStart() {
            this.Ae.start(),
                this.initStates(),
                this.ji.start(),
                this.Ie.start(),
                this.Ki.start(),
                this.Wi.start(),
                this.Qi &&
                    this.Ji &&
                    this.Qi.subscribe(qi.xe, (t) => this.Oe(t)),
                this.Xi &&
                    this.te &&
                    this.Xi.subscribe(qi.xe, (t) => this.ke(t), {
                        detailedEvent: !0,
                    }),
                this.$.emitDebugEvents &&
                    this.ae.emit("replayRecordingStarted"),
                csArray.prototype.forEach.call(this.Se, (t) => this.Me(t)),
                (this.Se = [])
        }
        onStop() {
            this.Ae.stop(),
                this.ji.stop(),
                this.Zi.stop(),
                this.Wi.stop(),
                this.Qi && this.Qi.unsubscribe(qi.xe),
                this.Xi && this.Xi.unsubscribe(qi.xe),
                this.Ie.stop(),
                this.Ki.stop(),
                (this.Re = !1)
        }
        clearStates() {
            this.Gi.flushEvents(),
                this.le.cancel(),
                this.pushEvents(),
                this.ie.removeQueryParams()
        }
        initStates() {
            ;(this.Ee = pt.now()),
                this.qi.reset(),
                (this.he = 0),
                (this.oe = 0),
                (this.ce = 0),
                this.ie.setQueryParams(this.Hi.getRequestParameters())
        }
        pushEvents() {
            Hs(this.pi, (t) => {
                var s
                return null === (s = t.flushEvents) || void 0 === s
                    ? void 0
                    : s.call(t)
            }),
                this.Bi.eventsCount() > 0 &&
                    (this.isStarted ? this.de() : this.Bi.clearEvents())
        }
        de() {
            if (!this.canSendEvents()) return
            const t = this.Bi.getEvents()
            this.ye = t[t.length - 1].date
            const s = this.qi.getCurrentIndex()
            this.ie.setQueryParams({
                ri: s.toString(),
                rst: this.getRecordingStartTimestamp(),
                let: this.getRecordingLastEventTimestamp(),
            })
            const i = this.ie.getQueryParams()
            this.ee.addBatchInProgress(
                `${i.sn}.${i.pn}.${s}`,
                this.ie.getQueryParams(),
                t
            ),
                this.ie.send(t),
                this.qi.increment(),
                this.Bi.clearEvents(),
                this.De && this.De()
        }
        addInitialDom(t) {
            this.Bi.addEventByTimestamp(t), this.Le(t)
        }
        ke(t) {
            if (
                t.customRequestHeaders ||
                t.customResponseHeaders ||
                t.queryParameters ||
                t.requestBody ||
                t.responseBody
            ) {
                if (this.se) return void this.se.registerApiErrorToEncrypt(t)
                ;(t.customRequestHeaders = ""),
                    (t.customResponseHeaders = ""),
                    (t.queryParameters = ""),
                    (t.requestBody = ""),
                    (t.responseBody = "")
            }
            this.be(t)
        }
        be(t) {
            if (this.oe < qi.Ue) {
                const s = {
                    type: fs.API_ERROR,
                    date: pt.now(),
                    args: [this.te.anonymize(t)],
                }
                this.fe(s), (this.oe = this.oe + 1)
            }
        }
        Oe(t) {
            if (this.he < qi.ze) {
                const s = {
                    type: fs.JAVASCRIPT_ERROR,
                    date: pt.now(),
                    args: [this.Ji.anonymize(t)],
                }
                this.fe(s), (this.he = this.he + 1)
            }
        }
        Fe(t) {
            if (this.ce < qi.Be) {
                const s = { type: fs.CUSTOM_ERROR, date: pt.now(), args: [t] }
                this.fe(s), (this.ce = this.ce + 1)
            }
        }
        He(t) {
            t === ni.ETR_SESSION
                ? this.ie.setQueryParams({ [qi.qe]: qi.je })
                : t === ni.ETR_PAGE &&
                  this.ie.setQueryParams({ [qi.Ge]: qi.je })
        }
        clearEvents() {
            this.Bi.clearEvents()
        }
        onCustomJavaScriptErrorEvent(t) {
            this.Oe(t)
        }
        onCustomErrorEvent(t) {
            this.Fe(t)
        }
        onPageEvent(t) {
            this.Ze(t)
        }
        onUserIdentifierEvent(t) {
            var s
            const i = {
                userIdentifier: t,
                date: pt.now(),
                keyId: this.$.encryptionPublicKeyId,
            }
            null === (s = this.se) ||
                void 0 === s ||
                s.registerUserIdentifierToEncrypt(i)
        }
        onEventTriggerRecording(t, s) {
            this.isStarted
                ? this.Me({ eventName: t, eventType: s })
                : csArray.prototype.push.call(this.Se, {
                      eventName: t,
                      eventType: s,
                  })
        }
        Me(t) {
            this.He(t.eventType), this.Ze(t.eventName), this.pushEvents()
        }
        Ze(t) {
            const s = {
                type: fs.PAGE_EVENT,
                date: pt.now(),
                args: [
                    { eventName: csString.prototype.slice.call(t, 0, qi.We) },
                ],
            }
            this.Bi.addEvent(s)
        }
        triggerUnanonymizationConsentGranted() {
            const t = { date: pt.now(), type: fs.UNANONYMIZED_CONSENT_GRANTED }
            this.Bi.addEvent(t)
        }
        triggerUnanonymizationConsentWithdrawn() {
            const t = {
                date: pt.now(),
                type: fs.UNANONYMIZED_CONSENT_WITHDRAWN,
            }
            this.Bi.addEvent(t)
        }
        triggerRecordingForSessionGranted() {
            const t = {
                date: pt.now(),
                type: fs.RECORDING_INFO_EVENT,
                args: [ws.RECORDING_CONSENT_FOR_SESSION_GRANTED],
            }
            this.Bi.addEvent(t)
        }
        triggerRecordingForSessionWithdrawn() {
            const t = {
                date: pt.now(),
                type: fs.RECORDING_INFO_EVENT,
                args: [ws.RECORDING_CONSENT_FOR_SESSION_WITHDRAWN],
            }
            this.Bi.addEvent(t)
        }
        activateOnlineAssetsOnNextPageview() {
            ;(this._e = !0), (this.Re = !0)
        }
        getStaticResourceManagerStatus() {
            return this.ne
                ? {
                      isStarted:
                          this.$.useStaticResourceManager &&
                          this.ne.isSupported(),
                      onlineAssets: {
                          activated: this.ne.isOnlineAssetsActivated(),
                          enabledOnNextPageview: this._e,
                          enabledForChildrenOnNextStart: this.Re,
                      },
                  }
                : null
        }
        updateStaticResourceManagerOnlineAssets() {
            this.ne &&
                this._e &&
                (this.ne.enableOnlineAssets(), (this.Re = !0), (this._e = !1))
        }
        onRecordingRequestSent(t) {
            this.De = t
        }
        getRecordingStartTimestamp() {
            return this.Ee.toString()
        }
        getRecordingLastEventTimestamp() {
            return this.ye.toString()
        }
        Ne() {
            return this.Bi.extractEvents(
                fs.API_ERROR,
                fs.JAVASCRIPT_ERROR,
                fs.CUSTOM_ERROR,
                fs.TEXT_VISIBILITY,
                fs.POINTER_DOWN
            )
        }
    }
    ;(qi.xe = "RecordingService"),
        (qi.We = 255),
        (qi.ze = 20),
        (qi.Ue = 20),
        (qi.Be = 20),
        (qi.Ge = "etrp"),
        (qi.qe = "etrs"),
        (qi.je = "1"),
        ss([$s("addInitialDom")], qi.prototype, "addInitialDom", null)
    class ji extends si {
        constructor(t, s, i) {
            super(),
                (this.Zt = t),
                (this.re = s),
                (this.ie = i),
                (this.Ke = !1),
                (this.Ye = {}),
                (this.Qe = (t) => {
                    if (0 !== t.length)
                        for (const s of t) {
                            const { metadata: t, events: i } = s
                            this.Je(t.rt) && this.ie.send(i, t)
                        }
                }),
                window.addEventListener("focus", () => {
                    this.recover()
                })
        }
        onStart() {
            this.Ye = {}
        }
        onStop() {}
        recover() {
            this.Zt.recover(this.Qe)
        }
        addBatchInProgress(t, s, i) {
            this.Ye[t] = { metadata: { ...s }, events: i }
        }
        removeBatchInProgress(t) {
            delete this.Ye[t]
        }
        blockSendingLastMessage() {
            this.Ke = !1
        }
        allowSendingLastMessage() {
            this.Ke = !0
        }
        sendLastMessageBeacon() {
            if (this.Ke) {
                const { ri: t, rst: s, let: i, ...e } = this.ie.getQueryParams()
                ;(e.hlm = "true"), this.re.setQueryParams(e), this.re.send()
            }
        }
        Je(t) {
            return (
                !!t &&
                -1 ===
                    csString.prototype.indexOf.call(t, ii.TEMPORARILY_RECORDED)
            )
        }
        saveBatchesInProgress() {
            csArray.prototype.forEach.call(Object.keys(this.Ye), (t) => {
                const { metadata: s, events: i } = this.Ye[t]
                this.Zt.save({
                    key: `${s.sn}.${s.pn}.${s.ri}`,
                    metadata: { ...s, datatype: "json" },
                    events: csJSON.stringify(i),
                })
            })
        }
        save(t) {
            this.Zt.save(t)
        }
    }
    ss([ts("RecordingRecovery")], ji.prototype, "recover", null)
    const Gi = /[^\s]/g
    function Zi(t) {
        return csString.prototype.replace.call(t, Gi, "a")
    }
    class Wi {
        constructor(t, s, i, e) {
            ;(this.Xe = t),
                (this.cs = s),
                (this.tn = i),
                (this.se = e),
                (this.en = !1)
        }
        setAnonymization(t) {
            this.nn = t
        }
        isDOMSerializationInProgress() {
            return this.en
        }
        serializeInitialDom(t, s) {
            if (this.Xe.isAsynchronous())
                this.serializeDocumentAsync(t)
                    .then((t) => {
                        t && s(t)
                    })
                    .catch((t) => {
                        Jt.error(t)
                    })
            else {
                const i = this.rn(t)
                s(i)
            }
        }
        rn(t) {
            return {
                args: [this.Xe.serialize(t, { withAnonymization: this.nn })],
                date: pt.now(),
                type: fs.INITIAL_DOM,
            }
        }
        async serializeDocumentAsync(t) {
            this.en = !0
            try {
                return await this.Xe.startSerializeAsync(t, {
                    withAnonymization: this.nn,
                })
            } finally {
                this.en = !1
            }
        }
        serializeMutationCharacterData(t) {
            var s
            const i = this.cs.getId(t.target)
            if (!i) return null
            const e = t.target
            if (e.data === t.oldValue) return null
            if (
                l(e) &&
                (null === (s = this.se) || void 0 === s
                    ? void 0
                    : s.shouldEncrypt(e))
            )
                return (
                    this.se.registerTextNodeMutationToEncrypt({
                        targetId: i,
                        textNode: e,
                        serializedTextData: Zi(e.data),
                        date: t.date,
                    }),
                    null
                )
            let n = this.tn.getAnonymizedText(this.nn, e, e.data)
            l(e) && (n = this.Xe.serializeTextMutation(e, n))
            const r = [i, n]
            return (
                this.hn(this.Xe) &&
                    this.isDOMSerializationInProgress() &&
                    this.Xe.handleMutationCharacterData(t, r),
                r
            )
        }
        serializeAttachShadowEvent(t) {
            const s = this.cs.getId(t.target)
            if (!s) return null
            return [s, this.Xe.serialize(t.shadowRoot)]
        }
        serializeMutationAttribute(t) {
            const s = this.cs.getId(t.target)
            if (!s) return null
            const i = t.target,
                e = t.attributeName,
                n = t.attributeNamespace
            let r = Oi.getAttributeNS(t.target, n, e)
            r &&
                ((r = this.tn.getAnonymizedAttributeValue(i, this.nn, e, r)),
                (r = this.Xe.serializeAttributeMutationValue(t.target, e, r)))
            const h = [s, n, e, r]
            return (
                this.hn(this.Xe) &&
                    this.isDOMSerializationInProgress() &&
                    this.Xe.handleMutationAttribute(
                        t.oldValue
                            ? this.tn.getAnonymizedAttributeValue(
                                  i,
                                  this.nn,
                                  e,
                                  t.oldValue
                              )
                            : t.oldValue,
                        h
                    ),
                h
            )
        }
        serializeMutationChildList(t, s) {
            const i = this.cs.getId(t.target)
            if (!i)
                return (
                    Hs(t.addedNodes, (t) => {
                        const i = s.get(t)
                        i && s.set(t, i - 1)
                    }),
                    null
                )
            if (this.hn(this.Xe) && this.isDOMSerializationInProgress())
                return this.Xe.serializeMutationChildList(t, this.nn, s)
            return { removedNodes: this.cn(t), addedNodes: this.an(t, i, s) }
        }
        hn(t) {
            return t.isAsynchronous()
        }
        cn(t) {
            const s = []
            for (let i = 0; i < t.removedNodes.length; i += 1) {
                const e = this.cs.getId(t.removedNodes[i])
                e && csArray.prototype.push.call(s, [e])
            }
            return s
        }
        an(t, s, i) {
            const e = []
            let n = null
            if (t.nextSibling) {
                const s = this.cs.getId(t.nextSibling)
                n = void 0 !== s ? s : null
            }
            for (let r = 0; r < t.addedNodes.length; r += 1) {
                const h = t.addedNodes[r],
                    o = this.Xe.serialize(h, {
                        excludedNodes: i,
                        withAnonymization: this.nn,
                    }),
                    c = i.get(h)
                c && i.set(h, c - 1), csArray.prototype.push.call(e, [s, n, o])
            }
            return e
        }
    }
    var Ki
    ss(
        [
            ((Ki = "serializeDocumentAsync"),
            function (t, s, i) {
                const e = i.value
                i.value = function (...t) {
                    if (!Ns) return (i.value = e), e.apply(this, t)
                    !(function (t) {
                        performance.mark(`${t}-start`)
                    })(Ki)
                    const s = e.apply(this, t)
                    return (
                        s.then(() => {
                            !(function (t) {
                                const s = performance.measure(t, `${t}-start`)
                                if (!s) return
                                const i = s.duration
                                i > Vs &&
                                    bs.add([
                                        { mName: t, mDuration: +i.toFixed(2) },
                                    ])
                            })(Ki)
                        }),
                        s
                    )
                }
            }),
        ],
        Wi.prototype,
        "serializeDocumentAsync",
        null
    )
    class Yi {
        constructor(t, s, i, e) {
            ;(this.cs = t),
                (this.us = s),
                (this.$s = i),
                (this.ji = e),
                this.un() &&
                    (this.ln = Ii(
                        window.CSSStyleDeclaration.prototype,
                        "cssText",
                        (t, s) => this.setStyleDeclarationCssText(t, s)
                    ))
        }
        onEvent(t) {
            this.zs = t
        }
        start() {
            ;(this.dn = this.ji.registerToInsertRuleInterceptor(
                this.sendInsertion.bind(this)
            )),
                (this.fn = this.ji.registerToDeleteRuleInterceptor(
                    this.sendDeletion.bind(this)
                )),
                this.ln && this.ln.activate()
        }
        stop() {
            var t, s
            null === (t = this.dn) || void 0 === t || t.call(this),
                null === (s = this.fn) || void 0 === s || s.call(this),
                this.ln && this.ln.deactivate()
        }
        setStyleDeclarationCssText(t, s) {
            const i = this.wn(t)
            if (!(null == i ? void 0 : i.ownerNode)) return
            if (u(i.ownerNode) && this.us.isSensitiveChild(i.ownerNode)) return
            const e = this.cs.getId(i.ownerNode)
            if (!e) return
            const n = this.mn(i.cssRules, t.parentRule),
                r = {
                    date: pt.now(),
                    type: fs.STYLESHEET_CSS_TEXT_UPDATE,
                    args: [e, n, s],
                }
            this.zs(r), this.$s.scanCssString(s)
        }
        wn(t) {
            const s = t.parentRule
            return s && s.parentStyleSheet
        }
        mn(t, s) {
            return csArray.prototype.indexOf.call(csArray.from(t), s)
        }
        un() {
            return (
                window.CSSStyleDeclaration &&
                window.CSSStyleDeclaration.prototype &&
                Object.getOwnPropertyDescriptor(
                    window.CSSStyleDeclaration.prototype,
                    "cssText"
                )
            )
        }
        sendInsertion(t, [s, i]) {
            if (!t.ownerNode) return
            if (u(t.ownerNode) && this.us.isSensitiveChild(t.ownerNode)) return
            const e = this.cs.getId(t.ownerNode)
            if (!e) return
            const n = {
                date: pt.now(),
                type: fs.STYLESHEET_RULE_INSERT,
                args: St(i) ? [e, s, i] : [e, s],
            }
            this.zs(n), this.$s.scanCssString(s)
        }
        sendDeletion(t, [s]) {
            if (!t.ownerNode) return
            if (u(t.ownerNode) && this.us.isSensitiveChild(t.ownerNode)) return
            const i = this.cs.getId(t.ownerNode)
            if (!i) return
            const e = {
                date: pt.now(),
                type: fs.STYLESHEET_RULE_DELETE,
                args: [i, s],
            }
            this.zs(e)
        }
    }
    ss(
        [ts("styleSheetRuleTracker.setStyleDeclarationCssText")],
        Yi.prototype,
        "setStyleDeclarationCssText",
        null
    ),
        ss(
            [ts("styleSheetRuleTracker.sendInsertion")],
            Yi.prototype,
            "sendInsertion",
            null
        ),
        ss(
            [ts("styleSheetRuleTracker.sendDeletion")],
            Yi.prototype,
            "sendDeletion",
            null
        )
    const Qi = "data-cs-mask"
    class Ji {
        constructor(t) {
            this.us = t
        }
        beforeSerializeChildren(t, s) {
            return this.us.isSensitive(t) || this.En(t) ? [] : s
        }
        beforeSerializeAttributes(t, s) {
            return (
                this.us.isSensitive(t) &&
                    !g(t) &&
                    (csArray.prototype.push.call(s, this.yn(t)),
                    t.hasAttribute(Qi) ||
                        csArray.prototype.push.call(
                            s,
                            document.createAttribute(Qi)
                        )),
                csArray.prototype.filter.call(
                    s,
                    (s) => !this.us.isSensitiveAttribute(t, s.name)
                )
            )
        }
        En(t) {
            return T(t) && this.us.isSensitive(t.host)
        }
        yn(t) {
            const s = t.getBoundingClientRect(),
                i = document.createAttribute("style")
            return (
                (i.value = `width: ${s.width}px !important; height: ${s.height}px !important;`),
                (t.__contentsquare_height = s.height),
                (t.__contentsquare_width = s.width),
                i
            )
        }
    }
    var Xi, te, se
    const ie =
            null !== (Xi = Lt.Element) && void 0 !== Xi
                ? Xi
                : { prototype: {} },
        ee = null !== (te = Lt.Node) && void 0 !== te ? te : { prototype: {} },
        ne = (t) => Object.getOwnPropertyDescriptor(t.prototype, "localName"),
        re = null !== (se = ne(ie)) && void 0 !== se ? se : ne(ee)
    var he
    !(function (t) {
        ;(t[(t.WebElement = 0)] = "WebElement"),
            (t[(t.MobileView = 1)] = "MobileView"),
            (t[(t.WebViewContainer = 2)] = "WebViewContainer")
    })(he || (he = {}))
    class oe {
        constructor(t) {
            ;(this.csId = t.__contentsquare_identifier),
                (this.format = he.WebElement),
                t.__contentsquare_artificial &&
                    (this.artificial = t.__contentsquare_artificial)
        }
    }
    class ce extends oe {
        constructor(t) {
            var s
            super(t),
                (this.attributes = []),
                (this.localName = ((s = t), re.get.call(s))),
                (this.namespaceURI = t.namespaceURI),
                (this.children = []),
                (this.nodeType = 1)
        }
    }
    const ae = [
        "id",
        "class",
        "style",
        "src",
        "srcset",
        "sizes",
        "href",
        "rel",
        "type",
        "width",
        "height",
        "media",
        "align",
        "dir",
        "bgcolor",
        "color",
        "border",
        "colspan",
        "rowspan",
        "cols",
        "rows",
        "size",
        "start",
        "slot",
        x,
    ]
    class ue {
        constructor(t, s) {
            ;(this.L = t), (this.$ = s), (this.An = new Set()), (this.gn = "")
        }
        init() {
            csArray.prototype.forEach.call(ae, (t) => {
                this.An.add(t)
            }),
                csArray.prototype.forEach.call(
                    this.$.whitelistedAttributes,
                    (t) => {
                        this.An.add(t)
                    }
                )
        }
        beforeSerializeChildren(t, s, i) {
            return (E(t) || this.vn(t)) && (i.withAnonymization = !1), s
        }
        serializeAttribute(t, s, i, e) {
            i.anonymized = e.withAnonymization
            const n = this.getAnonymizedAttributeValue(
                t,
                e.withAnonymization,
                i.name,
                i.value
            )
            i.value = n
        }
        serializeTextNode(t, s, i) {
            s.data = this.getAnonymizedText(i.withAnonymization, t, s.data)
        }
        serializeCDATASectionNode(t, s, i) {
            const e = t.data
            return (
                (s.data = i.withAnonymization ? Zi(e) : this.L.anonymizePII(e)),
                s
            )
        }
        getAnonymizedText(t, s, i) {
            if (csNodeparentNode.apply(s)) {
                if (E(csNodeparentNode.apply(s))) return i
                if (t && this.vn(csNodeparentNode.apply(s)))
                    return this.L.anonymizeCreditCard(this.L.anonymizeEmail(i))
            }
            return t
                ? Zi(i)
                : this.L.anonymizeCreditCard(this.L.anonymizeEmail(i))
        }
        getAnonymizedAttributeValue(t, s, i, e) {
            return this._n(i) || v(t) || (u((n = t)) && "slot" === n.localName)
                ? e
                : s &&
                  y(t) &&
                  ("submit" === t.type || "button" === t.type) &&
                  "value" === i
                ? Zi(e)
                : s
                ? ""
                : this.L.anonymizeCreditCard(this.L.anonymizeEmail(e))
            var n
        }
        setWhitelistedElementsSelector(t) {
            this.gn = t
        }
        getWhitelistedElementsSelector() {
            return this.gn
        }
        afterSerialize(t, s, i) {
            null == s.anonymized && (s.anonymized = i.withAnonymization),
                s instanceof ce &&
                    s.shadowRoot &&
                    null == s.shadowRoot.anonymized &&
                    (s.shadowRoot.anonymized = i.withAnonymization)
        }
        _n(t) {
            return this.An.has(t)
        }
        vn(t) {
            return u(t) && (t.hasAttribute("data-cs-capture") || this.Rn(t))
        }
        Rn(t) {
            return !!this.gn && N.call(t, this.gn)
        }
    }
    class le {
        constructor(...t) {
            this.Sn = t
        }
        addProvider(t) {
            csArray.prototype.push.call(this.Sn, t)
        }
        getRequestParameters() {
            return csArray.prototype.reduce.call(
                this.Sn,
                (t, s) => ({ ...s.getRequestParameters(), ...t }),
                {}
            )
        }
    }
    function de(t, s) {
        let i,
            e,
            n,
            r,
            h = null
        const o = (c) => {
                const a = pt.now()
                if (!c && null !== h) {
                    const t = s - (a - h)
                    if (t > 0) return void (e = window.setTimeout(o, t))
                }
                const u = a - n
                ;(e = null), (h = null), (n = null), (r = t(u, ...i))
            },
            c = (...t) => {
                if (((i = [...t]), !n))
                    return (n = pt.now()), (e = window.setTimeout(o, s)), r
                h = pt.now()
            }
        return (
            (c.flushPending = () => {
                e && (window.clearTimeout(e), o(!0))
            }),
            (c.cancel = () => {
                ;(h = null),
                    (n = null),
                    e && (window.clearTimeout(e), (e = null))
            }),
            c
        )
    }
    function fe(t = 0) {
        return (s, i, e) => {
            const n = e.value
            let r = !1
            e.value = function (...s) {
                r ||
                    ((r = !0),
                    setTimeout(() => {
                        ;(r = !1), n.apply(this, s)
                    }, t))
            }
        }
    }
    class we {
        constructor(t) {
            ;(this.$ = t),
                (this.Tn = !1),
                (this.In = de(() => {
                    ;(this.Tn = !1), this.Pn()
                }, this.$.pendingInactivityTimeout))
        }
        start() {
            ;(this.Tn = !0), this.In()
        }
        stop() {
            ;(this.Tn = !1), this.In.cancel()
        }
        trackActivity() {
            this.Tn || ((this.Tn = !0), this.bn()), this.In()
        }
        isUserActive() {
            return this.Tn
        }
        onActivityStopped(t) {
            this.Pn = t
        }
        onActivityResumed(t) {
            this.bn = t
        }
    }
    class pe {
        constructor(t, s, i) {
            ;(this.Vn = t),
                (this.L = s),
                (this.Cn = i),
                (this.Nn = [
                    {
                        boundElement: window,
                        type: "resize",
                        listener: () => this.resizeListener(),
                    },
                    {
                        boundElement: window,
                        type: "hashchange",
                        listener: () => this.hashChangeListener(),
                    },
                    {
                        boundElement: document,
                        type: "visibilitychange",
                        listener: () => this.visibilityChangeListener(),
                    },
                ])
        }
        onEvent(t) {
            this.zs = t
        }
        start() {
            this._s(),
                this.triggerInitialEvents(),
                this.Cn &&
                    (this.Cn.setOnScreenChangedCallback(this.zs),
                    this.Cn.start())
        }
        stop() {
            var t
            this.bs(), null === (t = this.Cn) || void 0 === t || t.stop()
        }
        _s() {
            csArray.prototype.forEach.call(this.Nn, (t) => vs(t))
        }
        bs() {
            csArray.prototype.forEach.call(this.Nn, (t) => _s(t))
        }
        triggerInitialEvents() {
            this.resizeListener(), this.hashChangeListener()
        }
        resizeListener() {
            var t
            const s = {
                type: fs.RESIZE,
                args: [Vi.windowWidth(), Vi.windowHeight()],
                date: pt.now(),
            }
            this.zs(s),
                null === (t = this.Cn) ||
                    void 0 === t ||
                    t.onScreenPotentiallyChanged()
        }
        hashChangeListener() {
            const t = {
                type: fs.HASH_CHANGE,
                args: [this.L.anonymizePII(this.Vn.href)],
                date: pt.now(),
            }
            this.zs(t)
        }
        visibilityChangeListener() {
            const t = {
                type: fs.VISIBILITY_CHANGE,
                args: [document.visibilityState],
                date: pt.now(),
            }
            this.zs(t)
        }
    }
    ss([ts("resize")], pe.prototype, "resizeListener", null),
        ss([ts("hashChange")], pe.prototype, "hashChangeListener", null),
        ss(
            [ts("visibilityChange")],
            pe.prototype,
            "visibilityChangeListener",
            null
        )
    class me extends si {
        constructor(t, s, i, e, n, r, h) {
            super(),
                (this.Zi = t),
                (this.Gi = s),
                (this.On = i),
                (this.kn = e),
                (this.Os = n),
                (this.$n = r),
                (this.Ls = h),
                (this.Ln = 0)
        }
        init() {
            this.Zi.onEvent((t, s) => {
                s || this.xn()
            }),
                this.kn.onRecordingRequestSent(() => {
                    ;(this.Ln += 1), this.Mn()
                }),
                this.On.onActivityStopped(() => {
                    this.Mn()
                }),
                this.On.onActivityResumed(() => {
                    this.Gi.isStarted() || this.Dn()
                })
        }
        onIframeRecordingUserEvent(t) {
            this.xn()
        }
        onStart() {
            this.On.start()
        }
        onStop() {
            this.On.stop()
        }
        Mn() {
            this.Gi.isStarted() &&
                !this.Os.isDOMSerializationInProgress() &&
                !this.On.isUserActive() &&
                this.Ln >= 2 &&
                this.Un()
        }
        xn() {
            this.On.trackActivity(), (this.Ln = 0)
        }
        Un() {
            this.Gi.stop(), this.Ls.emitRecordingStatusChange()
        }
        Dn() {
            this.Os.setAnonymization(this.$n.shouldUseAnonymization()),
                this.Gi.start(),
                this.Ls.emitRecordingStatusChange()
        }
    }
    var Ee,
        ye = /(@import\s*("([^"]+)"|'([^']+)'))|(url\s*\(\s*((("([^"\]]+)"|'([^'\]]+)')\s*)|([^)\]]+))\))/g
    function Ae(t, s) {
        var i = t.replace(ye, function () {
            for (var t = [], i = 0; i < arguments.length; i++)
                t[i] = arguments[i]
            var e = t[3] || t[4],
                n = t[9] || t[10] || t[11],
                r = (e || n)
                    .trim()
                    .replace(
                        /(\\)*\\(?:([a-fA-F0-9]{1,6})|(.))[\n\t\x20]?/g,
                        function (t, s, i, e) {
                            if ("\\" === s) return t.slice(1)
                            if (e) return e
                            var n = parseInt(i, 16)
                            return (55296 <= n && n <= 57343) ||
                                0 === n ||
                                n > 1114111
                                ? ""
                                : String.fromCodePoint(n)
                        }
                    )
            return (
                (e ? "@import " : "") +
                "url(" +
                (function (t) {
                    if (-1 === t.indexOf('"')) return '"' + t + '"'
                    if (-1 === t.indexOf("'")) return "'" + t + "'"
                    return t
                })(s(r) || r) +
                ")"
            )
        })
        return i
    }
    function ge(t) {
        var s = []
        return (
            Ae(t, function (t) {
                return s.push(t), t
            }),
            s
        )
    }
    function ve(t) {
        return Et(t, "data:")
    }
    function _e(t) {
        return Et(t, "#")
    }
    function Re(t) {
        const s = csString.prototype.trim.call(t)
        if ("" === t) return []
        let [i, e] = ((n = s), csString.prototype.split.call(n, /\s(.+)/))
        var n
        return e
            ? (yt(i, ",") ||
                  (e = (function (t) {
                      return csString.prototype.split.call(t, /,(.+)/)[1] || ""
                  })(e)),
              [Se(i), ...Re(e)])
            : [Se(i)]
    }
    function Se(t) {
        return csString.prototype.split.call(t, /,$/)[0]
    }
    class Te {
        constructor() {
            this.zn = !0
        }
        enable() {
            this.zn || (this.zn = !0)
        }
        disable() {
            this.zn && (this.zn = !1)
        }
        onEvent(t) {
            this.zs = t
        }
        onAsset(t) {
            this.Fn = t
        }
        onStyleSheetFound(t) {
            this.Bn = t
        }
        serializeElementNode(t) {
            this.zn && this.Hn(t)
        }
        beforeSerializeChildren(t, s, i) {
            return this.zn && this.qn(t, s), s
        }
        scanAttribute(t, s) {
            this.jn(t, s)
        }
        scanText(t) {
            l(t) &&
                csNodeparentNode.apply(t) &&
                E(csNodeparentNode.apply(t)) &&
                this.scanCssString(t.data)
        }
        scanCssString(t) {
            this.Gn(ge(t))
        }
        Hn(t) {
            this.jn(t)
        }
        qn(t, s) {
            E(t) &&
                Hs(s, (t) => {
                    l(t) && this.scanCssString(t.data)
                })
        }
        jn(t, s) {
            this.Zn(t, s) || (this.Wn(t, s), this.Kn(t, s), this.Yn(t, s))
        }
        Zn(t, s) {
            var i, e, n
            if (p(t) && (!s || "href" === s) && t.href) {
                const s =
                        (null === (i = t.sheet) || void 0 === i
                            ? void 0
                            : i.href) || t.href,
                    r = {
                        assetId: s,
                        assetBasePath: window.location.href,
                        assetRawPath: t.getAttribute("href"),
                    }
                return (
                    null === (e = this.Bn) || void 0 === e || e.call(this, r),
                    null === (n = this.Fn) || void 0 === n || n.call(this, r),
                    this.Qn(s),
                    !0
                )
            }
            return !1
        }
        Jn(t) {
            return !this.Xn(t) && !ve(t) && !_e(t)
        }
        Wn(t, s) {
            var i
            if (m(t)) {
                if (!s || "src" === s) {
                    const s = t.getAttribute("src")
                    s &&
                        this.Jn(s) &&
                        (this.Qn(t.src),
                        null === (i = this.Fn) ||
                            void 0 === i ||
                            i.call(this, {
                                assetId: t.src,
                                assetRawPath: s,
                                assetBasePath: window.location.href,
                            }))
                }
                ;(s && "srcset" !== s) || !t.srcset || this.tr(t.srcset)
            }
        }
        Kn(t, s) {
            if ((!s || "style" === s) && t.hasAttribute("style")) {
                const s = t.getAttribute("style")
                if ("string" != typeof s)
                    throw new Error("Unexpected style: " + t.outerHTML)
                this.scanCssString(s)
            }
        }
        tr(t) {
            this.Gn(Re(t))
        }
        Yn(t, s) {
            var i, e
            if (
                ((v((e = t)) && "image" === e.localName) ||
                    (function (t) {
                        return v(t) && "use" === t.localName
                    })(t) ||
                    (function (t) {
                        return v(t) && "feImage" === t.localName
                    })(t)) &&
                (!s || "href" === s || "xlink:href" === s)
            ) {
                const s = t.getAttribute("href") || t.getAttribute("xlink:href")
                if (s && this.Jn(s)) {
                    const t = Ut(s)
                    this.Qn(t),
                        null === (i = this.Fn) ||
                            void 0 === i ||
                            i.call(this, {
                                assetId: t,
                                assetRawPath: s,
                                assetBasePath: window.location.href,
                            })
                }
            }
        }
        Gn(t) {
            return csArray.prototype.forEach.call(
                csArray.prototype.map.call(
                    csArray.prototype.filter.call(
                        csArray.prototype.filter.call(
                            csArray.prototype.filter.call(
                                t,
                                (t) => !this.Xn(t)
                            ),
                            (t) => !ve(t)
                        ),
                        (t) => !_e(t)
                    ),
                    (t) => ({ rawUrl: t, absoluteUrl: Ut(t) })
                ),
                (t) => {
                    var s
                    this.zs && this.Qn(t.absoluteUrl),
                        null === (s = this.Fn) ||
                            void 0 === s ||
                            s.call(this, {
                                assetId: t.absoluteUrl,
                                assetBasePath: window.location.href,
                                assetRawPath: t.rawUrl,
                            })
                }
            )
        }
        Qn(t) {
            var s
            const i = {
                date: pt.now(),
                type: fs.STATIC_RESOURCE_URL,
                args: [t],
            }
            null === (s = this.zs) || void 0 === s || s.call(this, i)
        }
        Xn(t) {
            return /^https:\/\/\w+:\w+@/.test(t)
        }
    }
    !(function (t) {
        ;(t.REQUEST_START = "requestStart"),
            (t.DOM_INTERACTIVE = "domInteractive"),
            (t.TIME_ORIGIN = "timeOrigin")
    })(Ee || (Ee = {}))
    class Ie {
        constructor(t) {
            this.ir = t.performance
        }
        onEvent(t) {
            this.zs = t
        }
        start() {
            this.er() && this.nr()
        }
        nr() {
            const t = {
                args: this.rr(),
                date: pt.now(),
                type: fs.PERFORMANCE_TIMINGS,
            }
            this.zs(t)
        }
        er() {
            return !(!this.ir || !this.ir.timing)
        }
        rr() {
            return [
                {
                    performanceTiming: Ee.REQUEST_START,
                    timestamp: this.ir.timing.requestStart,
                },
                {
                    performanceTiming: Ee.DOM_INTERACTIVE,
                    timestamp: this.ir.timing.domInteractive,
                },
                {
                    performanceTiming: Ee.TIME_ORIGIN,
                    timestamp: this.ir.timeOrigin,
                },
            ]
        }
    }
    class Pe extends si {
        constructor(t) {
            super(), (this.hr = t), (this.cr = new Map())
        }
        init() {
            this.ar(), this.ur()
        }
        ur() {
            this.Li = new csMutationObserver((t) => {
                Ws(() => this.handleMutations(t))
            })
        }
        ar() {
            this.lr() &&
                (this.wr = Ti({
                    target: Element.prototype,
                    methodName: "attachShadow",
                    hook: ({ context: t, result: s }) =>
                        this.handleAttachShadow(t, s),
                })),
                this.pr() &&
                    (this.mr = Ti({
                        target: Element.prototype,
                        methodName: "createShadowRoot",
                        hook: ({ context: t, result: s }) =>
                            this.handleAttachShadow(t, s),
                    }))
        }
        onChildListMutation(t) {
            this.Er = t
        }
        onCharacterDataMutation(t) {
            this.yr = t
        }
        onAttributesMutation(t) {
            this.Ar = t
        }
        onAttachShadowMutation(t) {
            this.gr = t
        }
        observe(t, s) {
            this.isStarted && this.Li.observe(t, s)
        }
        onStart() {
            this.wr && this.wr.activate(), this.mr && this.mr.activate()
        }
        onStop() {
            this.wr && this.wr.deactivate(),
                this.mr && this.mr.deactivate(),
                this.hr.clearQueue(),
                this.Li.disconnect()
        }
        flushPendingMutations() {
            if (!this.isStarted) return
            this.hr.runPendingTasks()
            const t = this.Li.takeRecords()
            this.handleMutations(t, !0)
        }
        lr() {
            return (
                window.Element &&
                window.Element.prototype &&
                "function" == typeof window.Element.prototype.attachShadow
            )
        }
        pr() {
            return (
                window.Element &&
                window.Element.prototype &&
                "function" == typeof window.Element.prototype.createShadowRoot
            )
        }
        handleMutations(t, s = !1) {
            const i = pt.now(),
                e = t.length > 1 ? this.vr(t) : t
            this.hr.isEmpty() && this.cr.clear(), this._r(e)
            for (let t = 0; t < e.length; t += 1) {
                const n = e[t]
                ;(n.date = i),
                    this.hr.schedule(() => {
                        this.processMutation(n, this.cr)
                    }, s)
            }
        }
        vr(t) {
            const s = new Map()
            for (let i = 0; i < t.length; i += 1) {
                const e = t[i]
                if ("attributes" !== e.type) continue
                const n = e.target,
                    r = e.attributeNamespace,
                    h = e.attributeName,
                    o = `${r || ""} ${h}`,
                    c = s.get(n),
                    a =
                        Oi.getAttributeNS(n, r, h) === e.oldValue
                            ? "none"
                            : "last"
                if (c) c.has(o) || c.set(o, a)
                else {
                    const t = new Map()
                    t.set(o, a), s.set(n, t)
                }
            }
            const i = []
            for (let e = t.length - 1; e >= 0; e -= 1) {
                const n = t[e]
                if ("attributes" !== n.type) {
                    csArray.prototype.push.call(i, n)
                    continue
                }
                const r = n.target,
                    h = `${n.attributeNamespace || ""} ${n.attributeName}`,
                    o = s.get(r)
                "last" === o.get(h) &&
                    (csArray.prototype.push.call(i, n), o.set(h, "none"))
            }
            return csArray.prototype.reverse.call(i)
        }
        handleAttachShadow(t, s) {
            this.gr({ shadowRoot: s, date: pt.now(), target: t })
        }
        processMutation(t, s) {
            switch (t.type) {
                case "attributes":
                    this.Ar(t)
                    break
                case "characterData":
                    this.yr(t)
                    break
                case "childList":
                    this.Er(t, s)
                    break
                default:
                    throw new Error("mutation type is not supported")
            }
        }
        _r(t) {
            csArray.prototype.forEach.call(t, (t) => {
                Hs(t.addedNodes, (t) => {
                    const s = this.cr.get(t)
                    s ? this.cr.set(t, s + 1) : this.cr.set(t, 1)
                })
            })
        }
    }
    ss([ts("handleMutations")], Pe.prototype, "handleMutations", null),
        ss(
            [$s("handleAttachShadow")],
            Pe.prototype,
            "handleAttachShadow",
            null
        ),
        ss([$s("processMutation")], Pe.prototype, "processMutation", null)
    class be extends Pe {
        constructor(t, s) {
            super(t),
                (this.cs = s),
                (this.Rr = {
                    subtree: !0,
                    attributes: !0,
                    childList: !0,
                    characterData: !0,
                    attributeOldValue: !0,
                    characterDataOldValue: !0,
                })
        }
        init() {
            super.init(), this.vs()
        }
        vs() {
            this.cs.onDocumentIdentified((t) => {
                this.observe(t, this.Rr)
            })
        }
    }
    class Ve {
        constructor(t) {
            ;(this.Sr = []), (this.Tr = []), (this.Ut = {}), (this.zt = t)
        }
        setQueryParams(t) {
            csArray.prototype.forEach.call(Object.keys(t), (s) => {
                this.Ut[s] = t[s]
            })
        }
        removeQueryParams(t) {
            t
                ? csArray.prototype.forEach.call(t, (t) => {
                      delete this.Ut[t]
                  })
                : (this.Ut = {})
        }
        onBeaconSuccess(t) {
            csArray.prototype.push.call(this.Sr, t)
        }
        onBeaconFailure(t) {
            csArray.prototype.push.call(this.Tr, t)
        }
        send(t) {
            const s = it.toQuery({ ...this.Ut, ct: ds.UNCOMPRESSED }),
                i = this.Ir(s, t)
            return (
                i
                    ? csArray.prototype.forEach.call(this.Sr, (t) => t())
                    : csArray.prototype.forEach.call(this.Tr, (t) =>
                          t(this.Ut)
                      ),
                i
            )
        }
        Ir(t, s) {
            try {
                if ("function" != typeof csNavigatorsendBeacon) return !1
                const i = csNavigatorsendBeacon(`${this.zt}?${t}`, s || "")
                if (i) return i
            } catch {}
            return (
                "function" == typeof navigator.sendBeacon &&
                navigator.sendBeacon(`${this.zt}?${t}`, s || "")
            )
        }
    }
    function Ce(t) {
        const s = new ArrayBuffer(t.length),
            i = new Uint8Array(s)
        for (let s = 0, e = t.length; s < e; s += 1)
            i[s] = csString.prototype.charCodeAt.call(t, s)
        return s
    }
    function Ne(t) {
        const s = -1 !== csString.prototype.indexOf.call(t, ";base64,"),
            i = csString.prototype.indexOf.call(t, ","),
            e = s
                ? [
                      csString.prototype.substring.call(t, 0, i - 7),
                      csString.prototype.substring.call(t, i + 1),
                  ]
                : [
                      csString.prototype.substring.call(t, 0, i),
                      csString.prototype.substring.call(t, i + 1),
                  ]
        !s && /^%3Csvg/i.test(e[1]) && (e[1] = decodeURIComponent(e[1]))
        const n = s ? ((r = e[1]), Ce(self.atob(r))) : Ce(e[1])
        var r
        return new Blob([n], {
            type: csString.prototype.replace.call(e[0], "data:", ""),
        })
    }
    function Oe(t) {
        const s = csArray.from(new Uint8Array(t))
        return csArray.prototype.join.call(
            csArray.prototype.map.call(s, (t) =>
                csString.prototype.padStart.call(t.toString(16), 2, "0")
            ),
            ""
        )
    }
    class ke {
        constructor(t) {
            ;(this.Pr = t), (this.br = !1)
        }
        init() {
            ;(this.br = this.Vr()), this.br && (this.Cr = new TextEncoder())
        }
        isSupported() {
            return this.br
        }
        isValidInput(t) {
            return !!t && t.length <= 100
        }
        async digest(t, s) {
            if (!this.br) return null
            const i = this.Nr(t, s),
                e = this.Cr.encode(i)
            try {
                return Oe(await crypto.subtle.digest("SHA-1", e))
            } catch {
                return null
            }
        }
        Vr() {
            return !!(
                this.Pr &&
                this.Pr.subtle &&
                this.Pr.subtle.digest &&
                self.TextEncoder &&
                csArray.from
            )
        }
        Nr(t, s) {
            return `${csString.prototype.toLowerCase.call(
                csString.prototype.trim.call(t)
            )}:${s}`
        }
    }
    var $e, Le
    !(function (t) {
        ;(t[(t.TAP = 0)] = "TAP"),
            (t[(t.LONG_PRESS = 1)] = "LONG_PRESS"),
            (t[(t.DRAG = 2)] = "DRAG"),
            (t[(t.FLICK = 3)] = "FLICK"),
            (t[(t.PINCH_IN = 4)] = "PINCH_IN"),
            (t[(t.PINCH_OUT = 5)] = "PINCH_OUT")
    })($e || ($e = {})),
        (function (t) {
            ;(t[(t.UP = 1)] = "UP"),
                (t[(t.DOWN = 2)] = "DOWN"),
                (t[(t.LEFT = 3)] = "LEFT"),
                (t[(t.RIGHT = 4)] = "RIGHT")
        })(Le || (Le = {}))
    class xe {
        constructor(t, s, i) {
            ;(this.Or = t), (this.cs = s), (this.us = i)
        }
        start() {
            this.Or.subscribe(xe.kr, (t, s) => this.processGesture(t, s))
        }
        stop() {
            this.Or.unsubscribe(xe.kr)
        }
        onEvent(t) {
            this.zs = t
        }
        processGesture(t, s) {
            if (!t.target) return
            if (u(t.target) && this.us.isSensitiveChild(t.target)) return
            const i = this.cs.getId(t.target)
            if (i)
                switch (t.type) {
                    case $e.DRAG:
                    case $e.FLICK:
                        this.$r(ms.SWIPE, t, i, s)
                        break
                    case $e.LONG_PRESS:
                        this.$r(ms.LONG_PRESS, t, i, s)
                        break
                    case $e.TAP:
                        this.$r(ms.TAP, t, i, s)
                        break
                    case $e.PINCH_IN:
                        this.$r(ms.PINCH_IN, t, i, s)
                        break
                    case $e.PINCH_OUT:
                        this.$r(ms.PINCH_OUT, t, i, s)
                }
        }
        $r(t, s, i, e) {
            const n = this.Lr(s, t, e),
                r = {
                    type: fs.GESTURE_RECOGNITION,
                    args: [i, n],
                    date: pt.now(),
                }
            this.zs(r)
        }
        Lr(t, s, i) {
            const e = { type: s }
            if (
                (t.direction && (e.direction = t.direction),
                t.distance && (e.distance = t.distance),
                t.velocity && (e.velocity = t.velocity),
                s === ms.TAP &&
                    i.changedTouches &&
                    1 === i.changedTouches.length)
            ) {
                const t = i.changedTouches[0]
                ;(e.pageX = Rs(t.pageX, 1)), (e.pageY = Rs(t.pageY, 1))
            }
            return e
        }
    }
    ;(xe.kr = "RecordingGesturesTracker"),
        ss([xs()], xe.prototype, "processGesture", null)
    class Me extends oe {
        constructor(t) {
            super(t),
                (this.name = t.name),
                (this.publicId = t.publicId),
                (this.systemId = t.systemId),
                (this.nodeType = 10)
        }
    }
    class De {
        constructor(t) {
            var s
            ;(this.name = t.name),
                (this.value = t.value),
                (this.namespaceURI =
                    null !== (s = t.namespaceURI) && void 0 !== s ? s : "")
        }
    }
    class Ue extends oe {
        constructor(t) {
            super(t), (this.data = t.data), (this.nodeType = 3)
        }
    }
    class ze extends oe {
        constructor(t) {
            super(t), (this.data = t.data), (this.nodeType = 4)
        }
    }
    class Fe extends oe {
        constructor(t) {
            super(t), (this.data = t.data), (this.nodeType = 8)
        }
    }
    class Be extends oe {
        constructor(t) {
            super(t),
                (this.baseURI = Be.getBaseURI(t)),
                (this.children = []),
                (this.nodeType = 9)
        }
        static getBaseURI(t) {
            let s = t.baseURI
            if (null == s) {
                const i = t.getElementsByTagName("base")
                s = 0 !== i.length ? i[0].href : t.URL
            }
            return s
        }
    }
    class He extends oe {
        constructor(t) {
            super(t),
                (this.mode = t.mode),
                (this.children = []),
                (this.nodeType = 11)
        }
    }
    class qe {
        constructor(t) {
            for (const s of qe.Mr) {
                const i = csArray.prototype.map.call(
                        csArray.prototype.filter.call(t, (t) => t[s]),
                        (t) => (i, e, n, r) => t[s](i, e, n, r)
                    ),
                    e = qe.Dr(i)
                this[s] = e
            }
        }
        static create(t) {
            return new qe(t)
        }
        static Dr(t) {
            const [s, i, e, n, r] = csArray.prototype.map.call(
                t,
                (t) => (s, i, e, n) => t(s, i, e, n) || i
            )
            switch (t.length) {
                case 0:
                    return (t, s) => s
                case 1:
                    return t[0]
                case 2:
                    return (t, e, n, r) => i(t, s(t, e, n, r), n, r)
                case 3:
                    return (t, n, r, h) => e(t, i(t, s(t, n, r, h), r, h), r, h)
                case 4:
                    return (t, r, h, o) =>
                        n(t, e(t, i(t, s(t, r, h, o), h, o), h, o), h, o)
                case 5:
                    return (t, h, o, c) =>
                        r(
                            t,
                            n(t, e(t, i(t, s(t, h, o, c), o, c), o, c), o, c),
                            o,
                            c
                        )
                default:
                    return (s, i, e, n) => {
                        let r = i
                        for (let h = 0; h < t.length; h++)
                            r = t[h](s, i, e, n) || r
                        return i
                    }
            }
        }
    }
    qe.Mr = [
        "beforeSerializeAttributes",
        "beforeSerializeChildren",
        "afterSerialize",
        "afterSerializeShadowRoot",
        "serializeElementNode",
        "serializeAttribute",
        "serializeTextNode",
        "serializeCDATASectionNode",
        "serializeCommentNode",
        "serializeDocumentNode",
        "serializeShadowRootNode",
        "serializeTextMutation",
        "serializeAttributeMutationValue",
    ]
    class je {
        constructor(t) {
            this.Ur = qe.create(t)
        }
        isAsynchronous() {
            return !0
        }
        serializeTextMutation(t, s) {
            return this.Ur.serializeTextMutation(t, s)
        }
        serializeAttributeMutationValue(t, s, i) {
            return this.Ur.serializeAttributeMutationValue(t, i, s)
        }
        serialize(t, s) {
            const i = { ...s },
                e = t.nodeType
            let n
            switch (e) {
                case 1:
                    n = this.zr(t, i)
                    break
                case 3:
                    n = this.Fr(t, i)
                    break
                case 4:
                    n = this.Br(t, i)
                    break
                case 7:
                case 8:
                    n = this.Hr(t, i)
                    break
                case 10:
                    n = new Me(t)
                    break
                case 9:
                    n = this.qr(t, i)
                    break
                case 11:
                    n = this.jr(t, i)
                    break
                default:
                    throw new Error(
                        `serialization is not supported (nodeType: ${e})`
                    )
            }
            return this.Ur.afterSerialize(t, n, i), n
        }
        zr(t, s) {
            const i = new ce(t)
            this.Ur.serializeElementNode(t, i, s),
                (i.attributes = this.Gr(t, s))
            const e = csElementshadowRoot.apply(t)
            return (
                e && (i.shadowRoot = this.Zr(e, s)),
                (i.children = this.Wr(t, s)),
                i
            )
        }
        Gr(t, s) {
            let i = Fs(t.attributes)
            i = this.Ur.beforeSerializeAttributes(t, i, s)
            for (let e = 0; e < i.length; ++e) {
                const n = i[e]
                i[e] = this.Kr(t, n, s)
            }
            return i
        }
        Kr(t, s, i) {
            const e = new De(s)
            return this.Ur.serializeAttribute(t, s, e, i), e
        }
        runBeforeSerializeChildrenHook(t, s, i) {
            let e = i || csNodechildNodes.apply(t)
            return (
                (e = s.excludedNodes
                    ? js(e, (t) => !s.excludedNodes.get(t))
                    : e),
                (e = this.Ur.beforeSerializeChildren(t, e, s)),
                Fs(e)
            )
        }
        Wr(t, s) {
            if (s.skipChildrenSerialization) return []
            const i = this.runBeforeSerializeChildrenHook(t, s)
            for (let t = 0; t < i.length; ++t) {
                const e = i[t]
                i[t] = this.serialize(e, s)
            }
            return i
        }
        Fr(t, s) {
            const i = new Ue(t)
            return this.Ur.serializeTextNode(t, i, s), i
        }
        Br(t, s) {
            const i = new ze(t)
            return this.Ur.serializeCDATASectionNode(t, i, s), i
        }
        Hr(t, s) {
            const i = new Fe(t)
            return this.Ur.serializeCommentNode(t, i, s), i
        }
        qr(t, s) {
            const i = new Be(t)
            return (
                this.Ur.serializeDocumentNode(t, i, s),
                (i.children = this.Wr(t, s)),
                i
            )
        }
        Zr(t, s) {
            const i = new He(t)
            return (
                this.Ur.serializeShadowRootNode(t, i, s),
                (i.children = this.Wr(t, s)),
                this.Ur.afterSerializeShadowRoot(t, i, s),
                i
            )
        }
        jr(t, s) {
            if (t.mode) return this.Zr(t, s)
            throw new Error("Not implemented yet.")
        }
    }
    async function Ge() {
        await new Promise((t) => {
            setTimeout(() => {
                t()
            }, 0)
        })
    }
    class Ze {
        constructor(t) {
            ;(this.cs = t),
                (this.Yr = !1),
                (this.Qr = new Map()),
                (this.Jr = {}),
                (this.Xr = new Map()),
                (this.th = new Map()),
                (this.ih = new Set()),
                (this.eh = new Map())
        }
        beforeSerializeChildren(t, s) {
            return this.Yr
                ? js(s, (t) => !this.isAddedNodeDuringSerialization(t))
                : s
        }
        beforeSerializeAttributes(t, s, i) {
            if (!this.Yr) return s
            const e = this.cs.getId(t)
            if (!e) return s
            const n = this.th.get(e)
            return n
                ? csArray.prototype.filter.call(s, (t) => {
                      const s = `${t.name}${t.namespaceURI || ""}`,
                          i = n.get(s)
                      return !(i && null === i.value)
                  })
                : s
        }
        serializeTextNode(t, s, i) {
            if (!this.Yr) return
            const e = this.Xr.get(s.csId)
            e && (s.data = e)
        }
        serializeCommentNode(t, s) {
            if (!this.Yr) return
            const i = this.Xr.get(s.csId)
            i && (s.data = i)
        }
        afterSerialize(t, s, i) {
            this.Yr &&
                ((csNodeparentNode.apply(t) &&
                    !this.getSerializedNodeByNode(csNodeparentNode.apply(t))) ||
                    i.skipRegisterNode ||
                    this.nh(s, i))
        }
        afterSerializeShadowRoot(t, s, i) {
            this.Yr && (i.skipRegisterNode || this.nh(s, i))
        }
        enable() {
            ;(this.Yr = !0), this.rh()
        }
        disable() {
            ;(this.Yr = !1), this.rh()
        }
        setDefaultSerializationOptions(t) {
            this.Jr = t
        }
        getSerializedNodeById(t) {
            var s
            return null === (s = this.Qr.get(t)) || void 0 === s
                ? void 0
                : s.serializedNode
        }
        getSerializedNodeByNode(t) {
            var s
            const i = this.cs.getId(t)
            if (i)
                return null === (s = this.Qr.get(i)) || void 0 === s
                    ? void 0
                    : s.serializedNode
        }
        getOptions(t) {
            var s
            const i = this.cs.getId(t)
            return (
                (i &&
                    (null === (s = this.Qr.get(i)) || void 0 === s
                        ? void 0
                        : s.options)) ||
                this.Jr
            )
        }
        registerInitialCharacterData(t, s) {
            this.Xr.get(t) || this.Xr.set(t, s)
        }
        registerInitialAttributes(t, s, i, e) {
            let n = this.th.get(t)
            const r = `${i}${s || ""}`
            if (n) {
                if (n.has(r)) return
            } else (n = new Map()), this.th.set(t, n)
            const h = { name: i, namespaceURI: s || "", value: e }
            n.set(r, h)
        }
        markAddedTreeAsProcessed(t) {
            const s = document.createNodeIterator(
                t,
                NodeFilter.SHOW_ALL,
                null,
                !1
            )
            let i
            for (; (i = s.nextNode()); ) {
                const t = this.cs.getId(i)
                t && this.ih.add(t)
            }
        }
        markRemovedNodeAsProcessed(t, s, i) {
            const e = this.cs.getId(i),
                n = this.cs.getId(t)
            if (!e || !n) return
            const r = this.eh.get(e)
            if (r)
                csArray.prototype.push.call(r.removedNodeIds, n),
                    csArray.prototype.indexOf.call(r.childNodeIds, n) < 0 &&
                        csArray.prototype.push.call(r.childNodeIds, n)
            else {
                const t = [],
                    r = s ? this.cs.getId(s) : null
                for (let s = 0; s < csNodechildNodes.apply(i).length; s += 1) {
                    const e = this.cs.getId(csNodechildNodes.apply(i)[s])
                    e &&
                        !this.ih.has(e) &&
                        (r && e === r && csArray.prototype.push.call(t, n),
                        csArray.prototype.push.call(t, e))
                }
                null === r && csArray.prototype.push.call(t, n)
                const h = [n]
                this.eh.set(e, { childNodeIds: t, removedNodeIds: h })
            }
        }
        addSerializedChildToParent(t, s, i) {
            const e = this.getSerializedNodeByNode(t)
            e && Ke(e) && this.hh(s, e, i)
        }
        isAddedNodeDuringSerialization(t) {
            const s = this.cs.getId(t)
            return !!s && this.ih.has(s)
        }
        getInitialIndexInParent(t, s) {
            const i = this.cs.getId(s),
                e = this.cs.getId(t)
            if (!i || !e) return -1
            const n = this.eh.get(i)
            return n ? csArray.prototype.indexOf.call(n.childNodeIds, e) : -1
        }
        rh() {
            this.Qr.clear(),
                this.Xr.clear(),
                this.th.clear(),
                this.ih.clear(),
                this.eh.clear()
        }
        nh(t, s) {
            t.csId &&
                (this.oh(t.csId, t, s),
                this.ah(t.csId, t),
                this.Qr.set(t.csId, { serializedNode: t, options: s }))
        }
        oh(t, s, i) {
            if (
                !(function (t) {
                    return t instanceof ce
                })(s)
            )
                return
            const e = this.th.get(t)
            if (e) {
                for (const t of s.attributes) {
                    const s = `${t.name}${t.namespaceURI || ""}`,
                        i = e.get(s)
                    i && null !== i.value && ((t.value = i.value), e.delete(s))
                }
                e.forEach((t) => {
                    null !== t.value &&
                        csArray.prototype.push.call(s.attributes, {
                            name: t.name,
                            value: t.value,
                            namespaceURI: t.namespaceURI,
                            anonymized: i.withAnonymization || !1,
                        })
                })
            }
        }
        hh(t, s, i) {
            ;(i.csId || We(i)) &&
                (t >= 0
                    ? csArray.prototype.splice.call(s.children, t, 0, i)
                    : We(i) && csArray.prototype.push.call(s.children, i))
        }
        ah(t, s) {
            var i
            if (!Ke(s)) return
            const e = this.eh.get(t)
            if (e)
                for (const t of e.removedNodeIds) {
                    const n = csArray.prototype.indexOf.call(e.childNodeIds, t)
                    if (-1 === n) continue
                    const r =
                        null === (i = this.Qr.get(t)) || void 0 === i
                            ? void 0
                            : i.serializedNode
                    void 0 !== r && this.hh(n, s, r)
                }
        }
    }
    function We(t) {
        return "artificial" in t
    }
    function Ke(t) {
        return "children" in t
    }
    const Ye = { taskTime: 25 }
    class Qe extends je {
        constructor(t, s, i = new Ze(s), e = Ye) {
            super([i, ...t]),
                (this.uh = s),
                (this.lh = i),
                (this.fh = e),
                (this.ph = 0),
                (this.mh = this.fh.taskTime)
        }
        isAsynchronous() {
            return !0
        }
        handleMutationAttribute(t, s) {
            const [i, e, n] = s
            this.lh.getSerializedNodeById(i) ||
                this.lh.registerInitialAttributes(i, e, n, t)
        }
        handleMutationCharacterData(t, s) {
            const [i] = s
            this.lh.getSerializedNodeById(i) ||
                this.lh.registerInitialCharacterData(i, t.oldValue || "")
        }
        serializeMutationChildList(t, s, i) {
            const e = this.an(t, s, i)
            this.Eh(t)
            return { removedNodes: this.cn(t, s), addedNodes: e }
        }
        async startSerializeAsync(t, s = {}) {
            return (
                (this.ph += 1),
                this.lh.setDefaultSerializationOptions(s),
                this.yh(t, s)
            )
        }
        an(t, s, i) {
            const e = []
            let n = null
            if (t.nextSibling) {
                const s = this.uh.getId(t.nextSibling)
                n = void 0 !== s ? s : null
            }
            const r = this.uh.getId(t.target)
            for (let h = 0; h < t.addedNodes.length; h += 1) {
                const o = t.addedNodes[h],
                    c = this.serialize(o, {
                        excludedNodes: i,
                        skipRegisterNode: !0,
                        withAnonymization: s,
                    }),
                    a = i.get(o)
                a && i.set(o, a - 1), csArray.prototype.push.call(e, [r, n, c])
            }
            return e
        }
        Eh(t) {
            for (let s = 0; s < t.addedNodes.length; s += 1) {
                const i = t.addedNodes[s]
                this.lh.markAddedTreeAsProcessed(i)
            }
        }
        Ah(t, s) {
            if (!s) return -1
            const i = this.lh.getInitialIndexInParent(t, s)
            return i >= 0
                ? i
                : csArray.prototype.indexOf.call(csNodechildNodes.apply(s), t)
        }
        cn(t, s) {
            const i = []
            for (let e = 0; e < t.removedNodes.length; e += 1) {
                const n = t.removedNodes[e]
                if (
                    (this.lh.markRemovedNodeAsProcessed(
                        n,
                        t.nextSibling,
                        t.target
                    ),
                    this.gh(n))
                )
                    this._h(n) && this.Rh(n, s)
                else {
                    const i = this.serialize(n, { withAnonymization: s })
                    if (this._h(t.target)) {
                        const s = this.Ah(n, t.target)
                        this.lh.addSerializedChildToParent(t.target, s, i)
                    }
                }
                const r = this.uh.getId(n)
                r && csArray.prototype.push.call(i, [r])
            }
            return i
        }
        Rh(t, s) {
            for (let i = 0; i < csNodechildNodes.apply(t).length; i += 1) {
                const e = csNodechildNodes.apply(t)[i]
                if (this._h(e)) this.Rh(e, s)
                else if (!this.lh.isAddedNodeDuringSerialization(e)) {
                    const i = this.serialize(e, { withAnonymization: s }),
                        n = this.Ah(e, t)
                    this.lh.addSerializedChildToParent(t, n, i)
                }
            }
        }
        _h(t) {
            return !!this.lh.getSerializedNodeByNode(t)
        }
        gh(t) {
            return this._h(t) || this.lh.isAddedNodeDuringSerialization(t)
        }
        async yh(t, s = {}) {
            const i = this.ph,
                e = pt.now()
            this.lh.enable(), (s.skipChildrenSerialization = !0)
            const n = [t]
            if ((await Ge(), i !== this.ph)) return null
            for (this.Sh = csDate.now(), this.serialize(t, s); n.length > 0; ) {
                const t = csArray.prototype.pop.call(n),
                    s = this.lh.getOptions(t),
                    e = this.runBeforeSerializeChildrenHook(t, s)
                let r = csArray.prototype.shift.call(e)
                for (; r; ) {
                    if (csDate.now() - this.Sh > this.mh) {
                        if ((await Ge(), i !== this.ph)) return null
                        this.Sh = csDate.now()
                    }
                    if (this.gh(r)) {
                        r = csArray.prototype.shift.call(e)
                        continue
                    }
                    csArray.prototype.push.call(n, r)
                    const h = this.serialize(r, s),
                        o = this.Ah(r, t)
                    if (
                        (this.lh.addSerializedChildToParent(t, o, h),
                        u(r) && csElementshadowRoot.apply(r))
                    ) {
                        const t = csElementshadowRoot.apply(r)
                        csArray.prototype.push.call(n, t)
                    }
                    r = csArray.prototype.shift.call(e)
                }
            }
            const r = this.lh.getSerializedNodeByNode(t)
            if (!r)
                throw (
                    (this.lh.disable(),
                    new Error("traverseAndSerialize : fail to serialize"))
                )
            this.lh.disable()
            return { args: [r], date: e, type: fs.INITIAL_DOM }
        }
    }
    class Je extends je {
        isAsynchronous() {
            return !1
        }
    }
    class Xe {
        constructor() {
            ;(this.Th = new Map()),
                (this.Ih = document.implementation.createHTMLDocument(""))
        }
        beforeSerializeChildren(t, s) {
            if (!E(t)) return s
            const i = this.Ph(t)
            if (null === i || 0 === i.length) return s
            if (
                (function (t) {
                    const s = t.length
                    for (let i = 0; i < s; i++)
                        switch (csString.prototype.charCodeAt.call(t, i)) {
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 32:
                            case 160:
                                continue
                            default:
                                return !1
                        }
                    return !0
                })(t.textContent)
            ) {
                const t = Fs(s)
                return csArray.prototype.push.call(t, this.bh(i)), t
            }
            {
                const e = this.Vh(t)
                if (e === i.length) return s
                const n = new csArray(i.length - e)
                for (let t = e, s = 0; t < i.length; t += 1, s += 1) n[s] = i[t]
                const r = Fs(s)
                return csArray.prototype.push.call(r, this.bh(n)), r
            }
        }
        Vh(t) {
            let s = this.Th.get(t.textContent)
            if (s) return s
            const i = t.cloneNode(!0)
            ;(i.textContent = t.textContent), this.Ih.head.appendChild(i)
            const e = this.Ph(i)
            return (
                (s = e ? e.length : 0),
                this.Th.set(t.textContent, s),
                this.Ih.head.removeChild(i),
                s
            )
        }
        Ph(t) {
            try {
                if (t.disabled) return null
                const s = t.sheet
                return s ? s.cssRules || s.rules : null
            } catch (t) {
                if (
                    "SecurityError" !== t.name &&
                    "InvalidAccessError" !== t.name
                )
                    throw t
                return null
            }
        }
        bh(t) {
            let s = ""
            Hs(t, (t) => (s += t.cssText))
            const i = document.createTextNode(s)
            return (i.__contentsquare_artificial = !0), i
        }
    }
    class tn {
        constructor(t, s) {
            ;(this.cs = t), (this.ji = s), (this.Ch = 1), (this.Ms = !1)
        }
        isAdoptedStyleSheetsSupported() {
            return (
                "adoptedStyleSheets" in Document.prototype &&
                "queueMicrotask" in window
            )
        }
        init() {
            this.isAdoptedStyleSheetsSupported() &&
                ((this.Nh = new Set()),
                (this.Oh = Ii(
                    window.ShadowRoot.prototype,
                    "adoptedStyleSheets",
                    this.kh.bind(this)
                )),
                (this.$h = Ii(
                    window.Document.prototype,
                    "adoptedStyleSheets",
                    this.kh.bind(this)
                )))
        }
        onEvent(t) {
            this.zs = t
        }
        start() {
            !this.Ms &&
                this.isAdoptedStyleSheetsSupported() &&
                ((this.Ms = !0),
                this.Lh(),
                this.Oh && this.Oh.activate(),
                this.$h && this.$h.activate())
        }
        stop() {
            this.Ms &&
                this.isAdoptedStyleSheetsSupported() &&
                ((this.Ms = !1),
                this.xh(),
                this.Nh.clear(),
                this.Oh && this.Oh.deactivate(),
                this.$h && this.$h.deactivate())
        }
        serializeDocumentNode(t) {
            var s
            ;(null === (s = t.adoptedStyleSheets) || void 0 === s
                ? void 0
                : s.length) && this.kh(t, t.adoptedStyleSheets)
        }
        serializeShadowRootNode(t) {
            var s
            ;(null === (s = t.adoptedStyleSheets) || void 0 === s
                ? void 0
                : s.length) && this.kh(t, t.adoptedStyleSheets)
        }
        Lh() {
            ;(this.dn = this.ji.registerToInsertRuleInterceptor(
                this.Mh.bind(this)
            )),
                (this.fn = this.ji.registerToDeleteRuleInterceptor(
                    this.Dh.bind(this)
                ))
        }
        xh() {
            var t, s
            null === (t = this.dn) || void 0 === t || t.call(this),
                null === (s = this.fn) || void 0 === s || s.call(this)
        }
        kh(t, s) {
            this.Ms &&
                Ws(() => {
                    csArray.prototype.forEach.call(s, (t) => this.Uh(t))
                    const i = csArray.prototype.map.call(s, (t) => this.zh(t)),
                        e = this.cs.getId(t)
                    if (!e) return
                    const n = {
                        type: fs.SET_ADOPTED_STYLE_SHEETS,
                        args: [e, i],
                        date: pt.now(),
                    }
                    this.zs(n)
                })
        }
        zh(t) {
            return t.__adopted_stylesheet_id
        }
        Mh(t, [s, i]) {
            const e = this.Fh(t)
            if (!e) return
            const n = {
                date: pt.now(),
                type: fs.ADOPTED_STYLESHEET_RULE_INSERT,
                args: St(i) ? [e, s, i] : [e, s],
            }
            this.zs(n)
        }
        Dh(t, [s]) {
            const i = this.Fh(t)
            if (i && i) {
                const t = {
                    date: pt.now(),
                    type: fs.ADOPTED_STYLESHEET_RULE_DELETE,
                    args: [i, s],
                }
                this.zs(t)
            }
        }
        Fh(t) {
            return this.Nh.has(t) && t.__adopted_stylesheet_id
                ? t.__adopted_stylesheet_id
                : null
        }
        Uh(t) {
            if (this.Nh.has(t)) return
            const s = this.Ch++
            ;(t.__adopted_stylesheet_id = s), this.Nh.add(t)
            const i = this.Bh(t),
                e = {
                    type: fs.REGISTER_ADOPTED_STYLE_SHEET,
                    args: [s, i],
                    date: pt.now(),
                }
            this.zs(e)
        }
        Bh(t) {
            let s = []
            try {
                s = csArray.prototype.map.call(t.cssRules, (t) => t.cssText)
            } catch {
                Jt.warn(
                    "AdoptedStylesheetsTracker.serializeStyleSheet: could not extract cssRules"
                )
            }
            return { cssRules: s }
        }
    }
    var sn, en, nn, rn, hn, on, cn, an
    !(function (t) {
        ;(t.replayRecordingUnmaskedUrlRegex =
            "replayRecordingUnmaskedUrlRegex"),
            (t.replayRecordingMaskedUrlRegex = "replayRecordingMaskedUrlRegex"),
            (t.replayRecordingUnmaskedUrlRegexRules =
                "replayRecordingUnmaskedUrlRegexRules"),
            (t.replayRecordingMaskedUrlRegexRules =
                "replayRecordingMaskedUrlRegexRules")
    })(sn || (sn = {})),
        (function (t) {
            ;(t.START = "start"),
                (t.NOT_START = "not-start"),
                (t.END = "end"),
                (t.NOT_END = "not-end"),
                (t.CONTAIN = "contain"),
                (t.NOT_CONTAIN = "not-contain"),
                (t.EXACT = "exact"),
                (t.NOT_EXACT = "not-exact")
        })(en || (en = {}))
    class un {
        constructor(t, s, i, e) {
            ;(this.Hh = t), (this.$ = s), (this.X = i), (this.qh = e)
        }
        init() {
            this.jh()
        }
        shouldUseAnonymization() {
            if (this.Hh.isReplayUnanonymizedAllowedByConsent()) {
                switch (this.$.anonymisationMethod) {
                    case null:
                    case sn.replayRecordingMaskedUrlRegex:
                        return !(
                            !this.$.replayRecordingMaskedUrlRegex ||
                            !this.$.replayRecordingMaskedUrlRegex.test(
                                this.X.getAnonymizedUrl()
                            )
                        )
                    case sn.replayRecordingMaskedUrlRegexRules:
                        return this.qh.evaluateUrl(this.X.getAnonymizedUrl())
                }
                return !1
            }
            switch (this.$.anonymisationMethod) {
                case null:
                case sn.replayRecordingUnmaskedUrlRegex:
                    return !(
                        this.$.replayRecordingUnmaskedUrlRegex &&
                        this.$.replayRecordingUnmaskedUrlRegex.test(
                            this.X.getAnonymizedUrl()
                        )
                    )
                case sn.replayRecordingUnmaskedUrlRegexRules:
                    return !this.qh.evaluateUrl(this.X.getAnonymizedUrl())
            }
            return !0
        }
        jh() {
            this.$.anonymisationMethod ===
                sn.replayRecordingMaskedUrlRegexRules &&
            this.$.replayRecordingMaskedUrlRegexRules
                ? this.qh.setRegexRules(
                      this.$.replayRecordingMaskedUrlRegexRules
                  )
                : this.$.anonymisationMethod ===
                      sn.replayRecordingUnmaskedUrlRegexRules &&
                  this.$.replayRecordingUnmaskedUrlRegexRules &&
                  this.qh.setRegexRules(
                      this.$.replayRecordingUnmaskedUrlRegexRules
                  )
        }
    }
    class ln {
        static isRecordingSupported() {
            return "MutationObserver" in window && "visibilityState" in document
        }
        static isAsyncSerializationSupported() {
            return "Promise" in window && "findIndex" in csArray.prototype
        }
    }
    class dn {
        constructor() {
            ;(this.Ms = !1), (this.Gh = []), (this.Zh = []), this.Wh()
        }
        registerToInsertRuleInterceptor(t) {
            return this.Kh(this.Gh, t)
                ? () => {}
                : (csArray.prototype.push.call(this.Gh, t),
                  () => {
                      this.Gh = csArray.prototype.filter.call(
                          this.Gh,
                          (s) => s !== t
                      )
                  })
        }
        registerToDeleteRuleInterceptor(t) {
            return this.Kh(this.Zh, t)
                ? () => {}
                : (csArray.prototype.push.call(this.Zh, t),
                  () => {
                      this.Zh = csArray.prototype.filter.call(
                          this.Zh,
                          (s) => s !== t
                      )
                  })
        }
        start() {
            var t, s
            this.Ms ||
                ((this.Ms = !0),
                null === (t = this.Yh) || void 0 === t || t.activate(),
                null === (s = this.Qh) || void 0 === s || s.activate())
        }
        stop() {
            var t, s
            this.Ms &&
                ((this.Ms = !1),
                null === (t = this.Yh) || void 0 === t || t.deactivate(),
                null === (s = this.Qh) || void 0 === s || s.deactivate())
        }
        Kh(t, s) {
            return csArray.prototype.indexOf.call(t, s) > -1
        }
        Jh(t, s) {
            csArray.prototype.forEach.call(this.Gh, (i) => i(t, s))
        }
        Xh(t, s) {
            csArray.prototype.forEach.call(this.Zh, (i) => i(t, s))
        }
        Wh() {
            this.so() &&
                (this.Yh = Ti({
                    target: window.CSSStyleSheet.prototype,
                    methodName: "insertRule",
                    hook: ({ context: t, args: s }) => {
                        this.Jh(t, s)
                    },
                })),
                this.io() &&
                    (this.Qh = Ti({
                        target: window.CSSStyleSheet.prototype,
                        methodName: "deleteRule",
                        hook: ({ context: t, args: s }) => this.Xh(t, s),
                    }))
        }
        so() {
            var t, s
            return (
                "function" ==
                typeof (null ===
                    (s =
                        null === (t = window.CSSStyleSheet) || void 0 === t
                            ? void 0
                            : t.prototype) || void 0 === s
                    ? void 0
                    : s.insertRule)
            )
        }
        io() {
            var t, s
            return (
                "function" ==
                typeof (null ===
                    (s =
                        null === (t = window.CSSStyleSheet) || void 0 === t
                            ? void 0
                            : t.prototype) || void 0 === s
                    ? void 0
                    : s.deleteRule)
            )
        }
    }
    class fn {
        constructor(t) {
            ;(this.eo = {}), (this.no = new Qs(t))
        }
        save({ key: t, metadata: s, events: i }) {
            this.no.isThresholdReached() ||
                (this.no.addString(t),
                "string" == typeof i
                    ? this.no.addString(i)
                    : this.no.addArrayBuffer(i),
                this.no.isThresholdReached() ||
                    (this.eo[t] = { metadata: s, events: i }))
        }
        recover(t) {
            const s = []
            csArray.prototype.forEach.call(this.ro(), (t) => {
                const i = this.eo[t]
                void 0 !== i &&
                    (delete i.metadata.datatype,
                    csArray.prototype.push.call(s, i),
                    this.ho(t))
            }),
                0 !== s.length && (t(s), this.no.reset())
        }
        ro() {
            return Object.keys(this.eo)
        }
        ho(t) {
            delete this.eo[t]
        }
    }
    !(function (t) {
        ;(t[(t.NOT_STARTED = 0)] = "NOT_STARTED"),
            (t[(t.OPEN_IN_PROGRESS = 1)] = "OPEN_IN_PROGRESS"),
            (t[(t.OPEN_FAILED = 2)] = "OPEN_FAILED"),
            (t[(t.READY = 3)] = "READY")
    })(nn || (nn = {}))
    class wn {
        constructor(t, s, i) {
            ;(this.oo = t),
                (this.co = i),
                (this.ao = nn.NOT_STARTED),
                (this.uo = []),
                (this.lo = 0),
                (this.do = self.origin),
                (this.fo = "object" == typeof window ? "" : "worker-"),
                (this.no = new Qs(s)),
                this.wo()
        }
        async wo() {
            await this.po(), this.ao === nn.READY ? this.mo() : this.co(this.uo)
        }
        mo() {
            csArray.prototype.forEach.call(this.uo, (t) => {
                this.save(t)
            }),
                (this.uo = [])
        }
        async save(t) {
            try {
                if (this.ao === nn.OPEN_IN_PROGRESS)
                    return void csArray.prototype.push.call(this.uo, t)
                if (this.ao !== nn.READY) return
                if (this.no.isThresholdReached()) return
                const { key: s, metadata: i, events: e } = t
                if (
                    (this.no.addString(s),
                    "string" == typeof e
                        ? this.no.addString(e)
                        : this.no.addArrayBuffer(e),
                    this.no.isThresholdReached())
                )
                    return
                await this.Eo.put(
                    `${this.do}/${s}`,
                    new Response(e, { headers: i })
                )
            } catch {}
        }
        async recover(t) {
            ;(this.Eo || (await this.po(), this.ao === nn.READY)) && this.yo(t)
        }
        async po() {
            try {
                ;(this.ao = nn.OPEN_IN_PROGRESS),
                    (this.Eo = await self.caches.open(`${this.fo}${this.oo}`)),
                    (this.ao = nn.READY)
            } catch {
                this.ao = nn.OPEN_FAILED
            }
        }
        async yo(t) {
            try {
                if ((this.lo++, this.lo > 1)) return
                const s = await this.Eo.keys()
                if (0 === s.length) return
                const i = await this.Eo.matchAll(),
                    e = csArray.prototype.map.call(i, (t) => {
                        const s = {}
                        t.headers.forEach((t, i) => {
                            s[i] = t
                        }),
                            delete s["content-type"]
                        const i = s.datatype
                        return (
                            delete s.datatype,
                            "json" === i || "base64" === i
                                ? t
                                      .text()
                                      .then((t) => ({ metadata: s, events: t }))
                                : t
                                      .arrayBuffer()
                                      .then((t) => ({ metadata: s, events: t }))
                        )
                    }),
                    n = await Promise.all(e)
                await Promise.all(
                    csArray.prototype.map.call(s, (t) => this.Eo.delete(t))
                ),
                    t(n),
                    this.no.reset()
            } catch {
            } finally {
                this.lo--
            }
        }
    }
    class pn {
        constructor(t) {
            self.caches ? this.Ao(t) : this.vo()
        }
        save(t) {
            this._o.save(t)
        }
        recover(t) {
            this._o.recover(t)
        }
        Ao(t) {
            this._o = new wn(t, pn.Ro, (t) => {
                this.vo(t)
            })
        }
        vo(t) {
            ;(this._o = new fn(pn.Ro)),
                t &&
                    csArray.prototype.forEach.call(t, (t) => {
                        this._o.save(t)
                    })
        }
    }
    ;(pn.Ro = 16777216),
        (function (t) {
            ;(t.PORTRAIT = "Portrait"), (t.LANDSCAPE = "Landscape")
        })(rn || (rn = {})),
        (function (t) {
            ;(t.PORTRAIT_PRIMARY = "portrait-primary"),
                (t.PORTRAIT_SECONDARY = "portrait-secondary"),
                (t.LANDSCAPE_PRIMARY = "landscape-primary"),
                (t.LANDSCAPE_SECONDARY = "landscape-secondary")
        })(hn || (hn = {})),
        (function (t) {
            ;(t[(t.PORTRAIT = 0)] = "PORTRAIT"),
                (t[(t.PORTRAIT_REVERSE = 180)] = "PORTRAIT_REVERSE"),
                (t[(t.LANDSCAPE = -90)] = "LANDSCAPE"),
                (t[(t.LANDSCAPE_REVERSE = 90)] = "LANDSCAPE_REVERSE")
        })(on || (on = {})),
        (function (t) {
            function s() {
                return "orientation" in screen
            }
            function i() {
                return "orientation" in window
            }
            ;(t.isScreenOrientationApiSupported = s),
                (t.isDeprecatedScreenOrientationApiSupported = i)
            const e = s()
                ? function () {
                      switch (screen.orientation.type) {
                          case hn.PORTRAIT_PRIMARY:
                          case hn.PORTRAIT_SECONDARY:
                              return rn.PORTRAIT
                          case hn.LANDSCAPE_PRIMARY:
                          case hn.LANDSCAPE_SECONDARY:
                              return rn.LANDSCAPE
                          default:
                              return rn.PORTRAIT
                      }
                  }
                : i()
                ? function () {
                      switch (window.orientation) {
                          case on.PORTRAIT:
                          case on.PORTRAIT_REVERSE:
                              return rn.PORTRAIT
                          case on.LANDSCAPE:
                          case on.LANDSCAPE_REVERSE:
                              return rn.LANDSCAPE
                          default:
                              return rn.PORTRAIT
                      }
                  }
                : function () {
                      return rn.LANDSCAPE
                  }
            t.getCurrentOrientation = function () {
                return e()
            }
        })(cn || (cn = {}))
    class mn {
        constructor() {
            ;(this.So = null), (this.To = null), (this.Ms = !1)
        }
        start() {
            this.Ms || ((this.Ms = !0), this.onScreenPotentiallyChanged())
        }
        stop() {
            this.Ms && ((this.Ms = !1), (this.So = null), (this.To = null))
        }
        setOnScreenChangedCallback(t) {
            this.Io = t
        }
        onScreenPotentiallyChanged() {
            var t
            if (!this.Ms) return
            const s = cn.getCurrentOrientation(),
                { screenWidth: i, screenHeight: e } = this.Po(s)
            if (i !== this.So || e !== this.To) {
                ;(this.So = i), (this.To = e)
                const s = {
                    type: fs.SCREEN_RESIZE,
                    args: [i, e],
                    date: pt.now(),
                }
                null === (t = this.Io) || void 0 === t || t.call(this, s)
            }
        }
        Po(t) {
            let s, i
            const e = Vi.screenWidth(),
                n = Vi.screenHeight()
            return (
                t === rn.PORTRAIT
                    ? ((s = e), (i = n))
                    : ((s = Math.max(e, n)), (i = Math.min(e, n))),
                { screenWidth: s, screenHeight: i }
            )
        }
    }
    class En {
        constructor(t, s) {
            ;(this.ne = t), (this.us = s), (this.bo = "cssrm://"), (this.Vo = 0)
        }
        beforeSerializeAttributes(t, s) {
            if (this.us.isSensitive(t)) return s
            if (m(t) || (d(t) && f(csNodeparentNode.apply(t)))) {
                let i = s
                const e = t.getAttribute("src")
                if (
                    null !== e &&
                    e.length > 0 &&
                    (ve(e) || this.ne.isOnlineAssetsActivated())
                )
                    return (
                        this.Vo++, this.Co(t.src, this.Vo), this.Oo(s, this.Vo)
                    )
                if (
                    null !== t.getAttribute("srcset") &&
                    this.ne.isOnlineAssetsActivated()
                ) {
                    const e = Re(t.srcset),
                        n = this.Vo + 1
                    for (const t of e) this.Vo++, this.Co(Ut(t), this.Vo)
                    i = this.ko(s, n, e)
                }
                return i
            }
            return p(t) &&
                "" !== t.getAttribute("href") &&
                this.ne.isOnlineAssetsActivated()
                ? (this.Vo++, this.$o(t.href, this.Vo), this.Lo(s, this.Vo))
                : null !== t.getAttribute("style")
                ? this.xo(s)
                : s
        }
        serializeTextNode(t, s, i) {
            t.parentElement && E(t.parentElement) && (s.data = this.Mo(s.data))
        }
        serializeTextMutation(t, s) {
            return csNodeparentNode.apply(t) && E(csNodeparentNode.apply(t))
                ? this.Mo(s)
                : s
        }
        serializeAttributeMutationValue(t, s, i) {
            if (this.us.isSensitive(t)) return s
            if (m(t) || (d(t) && f(csNodeparentNode.apply(t)))) {
                if ("src" === i && (ve(s) || this.ne.isOnlineAssetsActivated()))
                    return this.Vo++, this.Co(s, this.Vo), this.bo + this.Vo
                if ("srcset" === i && this.ne.isOnlineAssetsActivated()) {
                    const t = Re(s),
                        i = this.Vo + 1
                    for (const s of t) this.Vo++, this.Co(Ut(s), this.Vo)
                    return this.Do(i, s, t).value
                }
            }
            return p(t) && "href" === i && this.ne.isOnlineAssetsActivated()
                ? (this.Vo++, this.$o(s, this.Vo), this.bo + this.Vo)
                : "style" === i
                ? this.Mo(s)
                : s
        }
        Mo(t) {
            const s = csArray.from(new Set(ge(t)))
            if (
                this.Uo(s) ||
                (this.ne.isOnlineAssetsActivated() && this.zo(s))
            ) {
                let e = t
                for (const t of s)
                    (this.ne.isOnlineAssetsActivated() || ve(t)) &&
                        (this.Vo++,
                        (e = csString.prototype.replace.call(
                            e,
                            t,
                            this.bo + this.Vo
                        ))),
                        ve(t)
                            ? this.Co(t, this.Vo)
                            : this.ne.isOnlineAssetsActivated() &&
                              ((i = t) && yt(i, ".css")
                                  ? this.$o(t, this.Vo)
                                  : this.Co(t, this.Vo))
                return e
            }
            var i
            return t
        }
        Uo(t) {
            return csArray.prototype.some.call(t, (t) => ve(t))
        }
        zo(t) {
            return csArray.prototype.some.call(t, (t) => !ve(t))
        }
        xo(t) {
            return csArray.prototype.map.call(t, (t) => {
                if ("style" !== t.name) return t
                const s = document.createAttribute(t.name)
                return (s.value = this.Mo(t.value)), s
            })
        }
        Oo(t, s) {
            return csArray.prototype.map.call(t, (t) => {
                if ("src" !== t.name) return t
                const i = document.createAttribute(t.name)
                return (i.value = this.bo + s), i
            })
        }
        ko(t, s, i) {
            return csArray.prototype.map.call(t, (t) =>
                "srcset" !== t.name ? t : this.Do(s, t.value, i)
            )
        }
        Do(t, s, i) {
            let e = t
            const n = document.createAttribute("srcset")
            n.value = s
            for (const t of i)
                (n.value = csString.prototype.replace.call(
                    n.value,
                    t,
                    this.bo + e
                )),
                    e++
            return n
        }
        Lo(t, s) {
            const i = []
            for (const e of t) {
                const t = document.createAttribute(e.name)
                if ((csArray.prototype.push.call(i, t), "href" === e.name)) {
                    const n = document.createAttribute("data-cs-original-href")
                    ;(n.value = e.value),
                        csArray.prototype.push.call(i, n),
                        (t.value = this.bo + s)
                } else t.value = e.value
            }
            return i
        }
        Co(t, s) {
            this.ne.processStaticResource({ id: s, input: t })
        }
        $o(t, s) {
            this.ne.processStaticCssLinkResource({ id: s, input: t })
        }
    }
    !(function (t) {
        t[(t.NOT_EXIST = 2)] = "NOT_EXIST"
    })(an || (an = {}))
    class yn extends si {
        constructor(t, s, i) {
            super(),
                (this.ne = t),
                (this.Fo = s),
                (this.Bo = i),
                (this.Ho = {}),
                (this.qo = new Set()),
                (this.ci = !1)
        }
        onStart() {
            this.ne.start()
        }
        onStop() {
            this.ne.stop()
        }
        initState() {
            this.ne.isStaticResourceManagerSupported() &&
                ((this.jo = this.Bo.getRequestParameters()),
                (this.Go = `${this.Fo}/exist?${it.toQuery(this.jo)}`),
                (this.Zo = `${this.Fo}/putTag?${it.toQuery(this.jo)}`),
                (this.Wo = de(async () => {
                    this.ci
                        ? this.Wo()
                        : ((this.ci = !0), await this.Ko(), (this.ci = !1))
                }, 300)),
                this.ne.sendStaticResource((t) => {
                    this.qo.has(t.hash) ||
                        (this.qo.add(t.hash), (this.Ho[t.hash] = t), this.Wo())
                }))
        }
        onIframeStaticResource(t) {
            this.ne.isStaticResourceManagerSupported() &&
                !this.qo.has(t.hash) &&
                (this.qo.add(t.hash), (this.Ho[t.hash] = t), this.Wo())
        }
        async Ko() {
            const t = this.Ho
            this.Ho = {}
            const s = await this.Yo(t)
            if (!s.length) return
            const i = this.Qo(s)
            await Promise.all(
                csArray.prototype.map.call(i, (t) =>
                    window.fetch(this.Zo, { method: "POST", body: t })
                )
            )
        }
        async Jo(t) {
            try {
                const s = Object.keys(t)
                if (!s.length) return []
                const i = {
                        projectId: this.jo.pid,
                        filter: an.NOT_EXIST,
                        hashes: s,
                        touch: !0,
                    },
                    e = await window.fetch(this.Go, {
                        method: "POST",
                        body: csJSON.stringify(i),
                    })
                return await e.json()
            } catch (t) {
                return []
            }
        }
        async Yo(t) {
            const s = []
            try {
                const i = await this.Jo(t)
                csArray.prototype.forEach.call(i, (i) => {
                    const e = t[i]
                    e
                        ? csArray.prototype.push.call(s, e)
                        : Jt.warn("SRM: received unknown hash: " + i)
                })
            } catch (t) {
                Jt.warn(`SRM Service,getUnknownHashes error: ${t.message} `)
            }
            return s
        }
        Qo(t) {
            let s = 0
            const i = [new FormData()]
            for (const e of t) {
                const { blob: t, hash: n } = e,
                    r = i.length - 1
                if (((s += t.size), s < 8388608)) i[r].append("", t, n)
                else {
                    const e = new FormData()
                    e.append("", t, n),
                        (s = t.size),
                        csArray.prototype.push.call(i, e)
                }
            }
            return i
        }
    }
    class An {
        constructor() {
            this.Xo = []
        }
        setRegexRules(t) {
            this.Xo = csArray.prototype.map.call(t, (t) => this.tc(t))
        }
        evaluateUrl(t) {
            return csArray.prototype.some.call(this.Xo, (s) => {
                var i, e
                const n = this.sc(t, s)
                return (null == s ? void 0 : s.notOperator)
                    ? !(null === (i = s.regex) || void 0 === i
                          ? void 0
                          : i.test(n))
                    : null === (e = s.regex) || void 0 === e
                    ? void 0
                    : e.test(n)
            })
        }
        sc(t, s) {
            const i = Ht(t)
            return i
                ? s.ignoreQueryParams && s.ignoreURIFragments
                    ? `${i.origin}${i.pathname}`
                    : s.ignoreQueryParams
                    ? `${i.origin}${i.pathname}${i.hash}`
                    : s.ignoreURIFragments
                    ? `${i.origin}${i.pathname}${i.search}`
                    : t
                : t
        }
        ic(t) {
            return t.ignoreCaseSensitivity ? "i" : ""
        }
        tc(t) {
            switch (t.operator) {
                case en.NOT_START:
                    t.notOperator = !0
                case en.START:
                    t.regex = new RegExp(`^${t.value}`, this.ic(t))
                    break
                case en.NOT_END:
                    t.notOperator = !0
                case en.END:
                    t.regex = new RegExp(`${t.value}$`, this.ic(t))
                    break
                case en.NOT_CONTAIN:
                    t.notOperator = !0
                case en.CONTAIN:
                    t.regex = new RegExp(`${t.value}`, this.ic(t))
                    break
                case en.NOT_EXACT:
                    t.notOperator = !0
                case en.EXACT:
                    t.regex = new RegExp(`^${t.value}$`, this.ic(t))
                    break
                default:
                    Jt.warn(`buildRegexWithRule, unknown type: ${t.operator}`)
            }
            return t
        }
    }
    const gn = {
        now: () =>
            void 0 !== window.performance && window.performance.now
                ? window.performance.timing.navigationStart +
                  Math.round(window.performance.now())
                : csDate.now(),
    }
    class vn {
        constructor(t, s = 100) {
            ;(this.ec = t),
                (this.nc = s),
                (this.rc = "original-resource-name"),
                (this.hc = !1),
                (this.Ms = !1),
                (this.oc = !1),
                (this.cc = "SHA-256"),
                (this.ac = {}),
                (this.lc = null)
        }
        init() {
            "Promise" in window &&
                "function" == typeof window.Promise &&
                this.ec.isSupported() &&
                (this.hc = !0)
        }
        enableOnlineAssets() {
            this.oc = !0
        }
        isOnlineAssetsActivated() {
            return this.oc
        }
        isSupported() {
            return this.hc
        }
        async processStaticResource(t) {
            var s
            try {
                if (!this.hc) return
                let i
                if (ve(t.input)) {
                    const s = Ne(t.input)
                    if (!s) return
                    i = s
                } else {
                    const s = await window.fetch(t.input)
                    i = await s.blob()
                }
                const e = await i.arrayBuffer(),
                    n = Oe(await crypto.subtle.digest(this.cc, e)),
                    r = ve(t.input) ? void 0 : t.input
                this.fc(t.id, n, r),
                    null === (s = this.wc) ||
                        void 0 === s ||
                        s.call(this, { hash: n, blob: i })
            } catch {}
        }
        async processStaticCssLinkResource(t) {
            try {
                if (!this.hc) return
                const s = await this.mc(t.input)
                this.fc(t.id, s.get(Ut(t.input)).hash, t.input), this.Ec(s)
            } catch {}
        }
        isStaticResourceManagerSupported() {
            return this.hc
        }
        onEvent(t) {
            this.zs = t
        }
        sendStaticResource(t) {
            this.wc = t
        }
        flushEvents() {
            var t
            if (!Object.keys(this.ac).length) return
            this.lc && clearTimeout(this.lc)
            const s = {
                type: fs.RESOURCE_HASHES,
                date: gn.now(),
                args: [this.ac],
            }
            ;(this.lc = null),
                (this.ac = {}),
                null === (t = this.zs) || void 0 === t || t.call(this, s)
        }
        start() {
            this.Ms || (this.Ms = !0)
        }
        stop() {
            this.Ms && ((this.Ms = !1), (this.oc = !1), this.flushEvents())
        }
        fc(t, s, i) {
            let e = s
            i && (e += `?${this.rc}=${i}`),
                (this.ac[t] = e),
                this.lc && clearTimeout(this.lc),
                (this.lc = window.setTimeout(() => this.flushEvents(), this.nc))
        }
        async mc(t) {
            const s = new Map(),
                i = [{ resourceRawPath: t, resourceAbsolutePath: Ut(t) }]
            for (; i.length > 0; ) {
                const t = csArray.prototype.pop.call(i)
                if (
                    !this.isOnlineAssetsActivated() &&
                    null !== t.resourceAbsolutePath &&
                    !ve(t.resourceAbsolutePath)
                )
                    s.set(t.resourceAbsolutePath, null)
                else if (void 0 === s.get(t.resourceAbsolutePath))
                    try {
                        if (
                            null === t.resourceRawPath ||
                            csString.prototype.indexOf.call(
                                t.resourceRawPath,
                                ".css"
                            ) > 0
                        ) {
                            if (!t.data) {
                                const s = await fetch(t.resourceAbsolutePath)
                                t.data = await s.text()
                            }
                            t.nestedResources ||
                                (t.nestedResources = csArray.from(
                                    new Set(ge(t.data))
                                ))
                            let r = !1,
                                h = !1
                            for (const o of t.nestedResources) {
                                const c = ve(o)
                                        ? o
                                        : t.resourceAbsolutePath
                                        ? ((e = o),
                                          (n = t.resourceAbsolutePath),
                                          new csURL(e, n).href)
                                        : Ut(o),
                                    a = s.get(c)
                                if (void 0 !== a) {
                                    if (null !== a) {
                                        const s = this.yc(a, o)
                                        t.data = csString.prototype.replaceAll.call(
                                            t.data,
                                            o,
                                            s
                                        )
                                    }
                                    continue
                                }
                                const u =
                                    void 0 !==
                                    csArray.prototype.find.call(
                                        i,
                                        (t) => t.resourceAbsolutePath === c
                                    )
                                u ||
                                    ((r = !0),
                                    h ||
                                        (csArray.prototype.push.call(i, t),
                                        (h = !0)),
                                    csArray.prototype.push.call(i, {
                                        resourceRawPath: o,
                                        resourceAbsolutePath: c,
                                    }))
                            }
                            if (!r) {
                                const i = await this.Ac(t.data)
                                s.set(t.resourceAbsolutePath, {
                                    hash: i.hash,
                                    blob: i.blob,
                                })
                            }
                        } else {
                            let i
                            if (ve(t.resourceAbsolutePath)) {
                                const e = Ne(t.resourceAbsolutePath)
                                if (!e) {
                                    s.set(t.resourceAbsolutePath, null)
                                    continue
                                }
                                i = e
                            } else {
                                const s = await fetch(t.resourceAbsolutePath)
                                i = await s.blob()
                            }
                            const e = await this.gc(i)
                            s.set(t.resourceAbsolutePath, { hash: e, blob: i })
                        }
                    } catch {
                        s.set(t.resourceAbsolutePath, null)
                    }
            }
            var e, n
            return s
        }
        yc(t, s) {
            let i = `cs://resources/${t.hash}`
            return ve(s) || (i += `?${this.rc}=${s}`), i
        }
        async Ac(t) {
            const s = new Blob([t], { type: "text/css" }),
                i = await s.arrayBuffer()
            return { blob: s, hash: Oe(await crypto.subtle.digest(this.cc, i)) }
        }
        async gc(t) {
            const s = await t.arrayBuffer()
            return Oe(await crypto.subtle.digest(this.cc, s))
        }
        Ec(t) {
            t.forEach((t) => {
                var s
                t &&
                    (null === (s = this.wc) ||
                        void 0 === s ||
                        s.call(this, { hash: t.hash, blob: t.blob }))
            })
        }
    }
    class _n {
        constructor() {
            ;(this.vc = []), (this._c = 1)
        }
        identifyNodes(t, s) {
            const i = [
                document.createTreeWalker(t, NodeFilter.SHOW_ALL, null, !1),
            ]
            let e = !1
            for (; i.length > 0; ) {
                const t = csArray.prototype.pop.call(i)
                let n = t.root
                for (; null !== n; )
                    if (e && s && s.get(n) > 0) {
                        let s = t.nextSibling()
                        for (; null === s && null !== t.parentNode(); )
                            s = t.nextSibling()
                        n = s
                    } else
                        (n.__contentsquare_identifier = this._c),
                            (this._c += 1),
                            u(n) && csElementshadowRoot.apply(n)
                                ? csArray.prototype.push.call(
                                      i,
                                      document.createTreeWalker(
                                          csElementshadowRoot.apply(n),
                                          NodeFilter.SHOW_ALL,
                                          null,
                                          !1
                                      )
                                  )
                                : R(n) && this.Rc(n),
                            (n = t.nextNode()),
                            (e = !0)
            }
        }
        getId(t) {
            return t.__contentsquare_identifier
        }
        static getId(t) {
            return t.__contentsquare_identifier
        }
        getIds(t) {
            const s = new Set(),
                i = document.createNodeIterator(
                    t,
                    NodeFilter.SHOW_ALL,
                    null,
                    !1
                )
            let e
            for (; (e = i.nextNode()); ) {
                const t = e.__contentsquare_identifier
                if ((t && s.add(t), u(e) && csElementshadowRoot.apply(e))) {
                    const t = csElementshadowRoot.apply(e)
                    this.getIds(t).forEach((t) => s.add(t))
                }
            }
            return s
        }
        onDocumentIdentified(t) {
            csArray.prototype.push.call(this.vc, t)
        }
        Rc(t) {
            for (const s of this.vc) s(t)
        }
    }
    class Rn {
        constructor() {
            ;(this.Sc = new Map()), (this.Tc = {}), (this.Ic = !1)
        }
        start() {}
        stop() {
            this.flushEvents(), this.Sc.clear()
        }
        serializeTextNode(t, s) {
            const i = this.setReferenceId(s.data)
            return (s.data = `cstextref://${i}`), s
        }
        serializeCDATASectionNode(t, s) {
            const i = this.setReferenceId(s.data)
            return (s.data = `cstextref://${i}`), s
        }
        onEvent(t) {
            this.zs = t
        }
        flushEvents() {
            const t = this.Pc()
            t && this.zs(t)
        }
        getPendingEvents() {
            const t = this.Pc()
            return t ? [t] : []
        }
        getReferenceId(t) {
            return this.Sc.get(t)
        }
        setReferenceId(t) {
            return this.bc(t)
        }
        Pc() {
            if (0 === Object.keys(this.Tc).length) return
            const t = { type: fs.TEXT_REF, date: pt.now(), args: [this.Tc] }
            return (this.Tc = {}), t
        }
        bc(t) {
            let s = this.Sc.get(t)
            return (
                s ||
                ((s = this.Sc.size + 1),
                this.Sc.set(t, s),
                (this.Tc[s] = t),
                this.Ic ||
                    ((this.Ic = !0),
                    Ws(() => {
                        ;(this.Ic = !1), this.flushEvents()
                    })),
                s)
            )
        }
    }
    var Sn
    Sn = Lt.Element
    const Tn =
        window.csElementmatches ||
        window.csElementmatchesSelector ||
        window.csElementmozMatchesSelector ||
        window.csElementmsMatchesSelector ||
        window.csElementoMatchesSelector ||
        window.csElementwebkitMatchesSelector
    class In {
        constructor(t, s, i) {
            var e
            ;(this.cs = t),
                (this.us = s),
                (this.se = i),
                (this.zs = Z),
                (this.Ms = !1),
                (this.Vc = new Set()),
                (this.Cc = Pi()),
                (this.Nc = (t) => this.inputHandler(t)),
                (this.Oc = (t, s, i, e) => {
                    if (i && this.Ms && t.isConnected) {
                        const s = this.cs.getId(t)
                        s &&
                            this.kc(t) &&
                            Ws(() => {
                                this.$c(t, s)
                            })
                    }
                    return e.apply(t, [s])
                }),
                this.Lc(),
                this.xc(),
                this.Mc(),
                null === (e = this.se) ||
                    void 0 === e ||
                    e.onInputNodeToEncrypt((t) => {
                        this.zs(t)
                    })
        }
        start() {
            this.Ms ||
                ((this.Ms = !0),
                vs({
                    type: "keyup",
                    boundElement: document,
                    listener: this.Nc,
                }),
                vs({
                    type: "change",
                    boundElement: document,
                    listener: this.Nc,
                }))
        }
        stop() {
            this.Ms &&
                ((this.Ms = !1),
                _s({
                    type: "keyup",
                    boundElement: document,
                    listener: this.Nc,
                }),
                _s({
                    type: "change",
                    boundElement: document,
                    listener: this.Nc,
                }),
                this.Vc.forEach((t) => {
                    _s({ type: "change", boundElement: t, listener: this.Nc })
                }),
                this.Vc.clear())
        }
        serializeElementNode(t, s) {
            if (this.Ms) {
                if (!this.kc(t)) return
                Ws(() => {
                    this.$c(t, s.csId)
                })
            }
        }
        onEvent(t) {
            this.zs = t
        }
        $c(t, s) {
            var i, e, n
            if (this.Cc.has(t)) return
            if ((this.Cc.add(t), this.Dc(t))) {
                const i = {
                    type: fs.INPUT_SELECT,
                    args: [s, t.selectedIndex],
                    date: pt.now(),
                }
                return void this.zs(i)
            }
            if (this.Uc(t)) {
                const i = {
                    type: fs.INPUT_CHECKABLE,
                    args: [s, t.checked],
                    date: pt.now(),
                }
                return void this.zs(i)
            }
            const r = this.zc(t),
                h = this.Fc(t)
            if (r || h) {
                const r = null !== (i = t.value) && void 0 !== i ? i : ""
                if (
                    null === (e = this.se) || void 0 === e
                        ? void 0
                        : e.shouldEncrypt(t)
                )
                    return void (
                        null === (n = this.se) ||
                        void 0 === n ||
                        n.registerInputNodeToEncrypt({
                            targetId: s,
                            targetValue: r,
                            date: pt.now(),
                        })
                    )
                const o = h ? "0" : "•",
                    c = {
                        type: fs.INPUT_TEXT,
                        args: [s, csString.prototype.replace.call(r, /\S/g, o)],
                        date: pt.now(),
                    }
                this.zs(c)
            }
        }
        inputHandler(t) {
            const s = Ls(t),
                i = this.cs.getId(s)
            i &&
                this.kc(s) &&
                s.isConnected &&
                Ws(() => {
                    this.$c(s, i)
                })
        }
        afterSerializeShadowRoot(t) {
            this.Vc.has(t) ||
                (vs({ type: "change", listener: this.Nc, boundElement: t }),
                this.Vc.add(t))
        }
        Lc() {
            const t = Object.getOwnPropertyDescriptor(
                HTMLInputElement.prototype,
                "value"
            )
            if (!(null == t ? void 0 : t.configurable)) return
            const s = t.set,
                i = this
            ;(t.set = function (t) {
                const e = t !== this.value
                return i.Oc(this, t, e, s)
            }),
                Object.defineProperty(HTMLInputElement.prototype, "value", t)
        }
        xc() {
            const t = Object.getOwnPropertyDescriptor(
                HTMLInputElement.prototype,
                "checked"
            )
            if (!(null == t ? void 0 : t.configurable)) return
            const s = t.set,
                i = this
            ;(t.set = function (t) {
                const e = t !== this.checked
                return i.Oc(this, t, e, s)
            }),
                Object.defineProperty(HTMLInputElement.prototype, "checked", t)
        }
        Mc() {
            const t = Object.getOwnPropertyDescriptor(
                HTMLSelectElement.prototype,
                "selectedIndex"
            )
            if (!(null == t ? void 0 : t.configurable)) return
            const s = t.set,
                i = this
            ;(t.set = function (t) {
                const e = t !== this.selectedIndex
                return i.Oc(this, t, e, s)
            }),
                Object.defineProperty(
                    HTMLSelectElement.prototype,
                    "selectedIndex",
                    t
                )
        }
        Dc(t) {
            return Tn.call(t, In.Bc)
        }
        zc(t) {
            return Tn.call(t, In.Hc)
        }
        Fc(t) {
            return Tn.call(t, In.qc)
        }
        Uc(t) {
            return Tn.call(t, In.jc)
        }
        kc(t) {
            return (
                !this.us.isSensitive(t) &&
                !this.us.isSensitiveChild(t) &&
                (y(t) || _(t) || A(t))
            )
        }
    }
    ;(In.Hc = csArray.prototype.join.call(
        [
            "textarea",
            "input:not([type])",
            'input[type="text"]',
            'input[type="email"]',
            'input[type="search"]',
            'input[type="tel"]',
            'input[type="url"]',
            'input[type="password"]',
        ],
        ","
    )),
        (In.qc = 'input[type="number"]'),
        (In.jc = csArray.prototype.join.call(
            ['input[type="checkbox"]', 'input[type="radio"]'],
            ","
        )),
        (In.Bc = "select"),
        ss([xs()], In.prototype, "inputHandler", null)
    const Pn = "v2/recording",
        bn = ["setCapturedElementsSelector"],
        Vn = ["setPIISelectors"],
        Cn = ["isRecording"],
        Nn = [
            "replay:resourceManager:enableForOnlineResource:nextPageviewOnly",
            "cssrm:onlineAssets:activateForNextPageview",
        ],
        On = ["replay:resourceManager:getStatus", "cssrm:getStatus"]
    class kn {
        constructor(
            t,
            s,
            i,
            e,
            n,
            r,
            h,
            o,
            c,
            a,
            u,
            l,
            d,
            f,
            w,
            p,
            m,
            E,
            y,
            A,
            g,
            v,
            _
        ) {
            ;(this.Gc = t),
                (this.W = s),
                (this.$ = i),
                (this.Zc = e),
                (this.Hh = n),
                (this.jo = r),
                (this.Wc = h),
                (this.L = o),
                (this.Yi = c),
                (this.X = a),
                (this.us = u),
                (this.Qi = l),
                (this.Ji = d),
                (this.Xi = f),
                (this.Or = w),
                (this.te = p),
                (this.Ls = m),
                (this.Kc = E),
                (this.Yc = y),
                (this.Qc = A),
                (this.hr = g),
                (this.Jc = v),
                (this.Xc = _),
                (this.ne = null),
                (this.ta = null)
        }
        init() {
            const t = [],
                s = new pn("csPersisted")
            this.sa(s)
            const i = new Xs()
            this.Bi = new Js()
            const e = new _n(),
                n = new Ji(this.us)
            ;(this.ia = new ue(this.L, this.$)), this.ia.init()
            const r = new Te()
            csArray.prototype.push.call(t, r)
            const h = new be(this.hr, e),
                o = [new Xe(), n, this.ia, r]
            let c = null
            if (this.$.useStaticResourceManager) {
                const s = new ke(window.crypto)
                s.init(),
                    (this.ne = new vn(s)),
                    this.ne.init(),
                    csArray.prototype.push.call(t, this.ne),
                    this.ne.isStaticResourceManagerSupported() &&
                        ((c = new En(this.ne, this.us)),
                        csArray.prototype.push.call(o, c),
                        (this.ta = new yn(
                            this.ne,
                            this.$.getStaticResourceManagerUri(),
                            this.jo
                        )))
            }
            const a = new dn(),
                u = new tn(e, a)
            u.init(),
                csArray.prototype.push.call(t, u),
                u.isAdoptedStyleSheetsSupported() &&
                    csArray.prototype.push.call(o, u)
            const l = new Rn()
            csArray.prototype.push.call(o, l), csArray.prototype.push.call(t, l)
            const d = new In(e, this.us, this.se)
            let f
            csArray.prototype.push.call(o, d),
                (f = this.ea() ? new Qe(o, e) : new Je(o))
            const w = new le(
                    i,
                    this.jo,
                    {
                        getRequestParameters: () => ({
                            let: this.recordingService.getRecordingLastEventTimestamp(),
                        }),
                    },
                    {
                        getRequestParameters: () => ({
                            rst: this.recordingService.getRecordingStartTimestamp(),
                        }),
                    },
                    {
                        getRequestParameters: () => ({
                            rt: csArray.prototype.join.call(
                                this.W.getRecordingStates(),
                                ","
                            ),
                        }),
                    }
                ),
                p = new Ve(`${this.$.getRecordingUri()}/${Pn}`),
                m = new An()
            ;(this.$n = new un(this.Hh, this.$, this.X, m)),
                this.$n.init(),
                (this.Os = new Wi(f, e, this.ia, this.se)),
                this.Os.setAnonymization(this.$n.shouldUseAnonymization()),
                (this.Zi = new zs(e, this.us)),
                this.Zi.init()
            const E = new Ys(this.Os, h, r, this.Ls, e, this.us)
            ;(this.ee = new ji(s, p, this.ie)),
                csArray.prototype.push.call(t, new Yi(e, this.us, r, a)),
                csArray.prototype.push.call(t, new Ie(window)),
                csArray.prototype.push.call(
                    t,
                    new pe(window.location, this.L, new mn())
                ),
                (this.recordingService = new qi(
                    this.$,
                    this.Bi,
                    w,
                    i,
                    a,
                    E,
                    this.Zi,
                    d,
                    new xe(this.Or, e, this.us),
                    this.Yi,
                    this.W,
                    this.Qi,
                    this.Ji,
                    this.Xi,
                    this.te,
                    this.se,
                    this.ie,
                    this.ee,
                    this.ne,
                    t,
                    p
                )),
                (this.na = new me(
                    this.Zi,
                    E,
                    new we(this.$),
                    this.recordingService,
                    this.Os,
                    this.$n,
                    this.Ls
                )),
                this.Kc.addListener(this.recordingService),
                this.Yc.addListener(this.recordingService),
                this.Yc.addListener(this.na),
                this.ta && this.Yc.addListener(this.ta),
                h.init(),
                this.na.init(),
                this.recordingService.init(),
                this.Wc.register(
                    Cn,
                    () =>
                        this.W.isReplayRecorded() &&
                        !this.Qc.isUrlExcludedForSessionReplay()
                ),
                this.Wc.register(bn, (t) => {
                    this.ia.setWhitelistedElementsSelector(t),
                        this.Ls.emitRecordingStatusChange()
                }),
                this.Wc.register(Vn, (t) => {
                    this.us.setPIISelectors(t),
                        this.Ls.emitRecordingStatusChange()
                }),
                this.Wc.register(Nn, () => {
                    this.recordingService.activateOnlineAssetsOnNextPageview(),
                        this.Ls.emitRecordingStatusChange()
                }),
                this.Wc.register(On, () =>
                    this.recordingService.getStaticResourceManagerStatus()
                ),
                this.Gc.enableRecordingStatus(
                    this.recordingService,
                    this.us,
                    this.$n,
                    this.ia,
                    this.W,
                    this.se
                )
        }
        onAfterNaturalPageView() {
            var t
            null === (t = this.ta) || void 0 === t || t.initState()
        }
        onStartTracking() {
            this.ee.recover(),
                this.Os.setAnonymization(this.$n.shouldUseAnonymization()),
                this.W.isReplayRecorded() &&
                    !this.Qc.isUrlExcludedForSessionReplay() &&
                    (this.W.isTemporarilyRecorded() &&
                        this.recordingService.blockSendingEventsFromQuotaService(),
                    this.ra())
        }
        onArtificialPageViewEnd() {
            this.recordingService.clearStates(),
                !this.W.isReplayRecorded() ||
                    this.Qc.isUrlExcludedForSessionReplay() ||
                    this.W.isTemporarilyRecorded() ||
                    this.ee.sendLastMessageBeacon()
        }
        onAfterArtificialPageView() {
            this.Os.setAnonymization(this.$n.shouldUseAnonymization()),
                this.W.isReplayRecorded() &&
                !this.Qc.isUrlExcludedForSessionReplay()
                    ? (this.W.isTemporarilyRecorded() &&
                          this.recordingService.blockSendingEventsFromQuotaService(),
                      this.ha())
                    : this.oa()
        }
        onBeforeSessionRenewal() {
            this.recordingService.clearStates(), this.oa()
        }
        onOptout() {
            this.oa()
        }
        onReplayUnanonymizationConsentGranted() {
            this.Os.setAnonymization(this.$n.shouldUseAnonymization()),
                this.recordingService.triggerUnanonymizationConsentGranted(),
                this.Ls.emitRecordingStatusChange()
        }
        onReplayUnanonymizationConsentWithdrawn() {
            this.Os.setAnonymization(this.$n.shouldUseAnonymization()),
                this.recordingService.triggerUnanonymizationConsentWithdrawn(),
                this.Ls.emitRecordingStatusChange()
        }
        onRecordingStateChange(t, s) {
            t === ii.NOT_RECORDED && s === ei.ETR_OFF
                ? (this.recordingService.clearEvents(), this.oa())
                : (this.ie.setQueryParams({
                      rt: csArray.prototype.join.call(
                          this.W.getRecordingStates(),
                          ","
                      ),
                  }),
                  this.recordingService.allowSendingEventsFromQuotaService(),
                  this.Os.isDOMSerializationInProgress() ||
                      this.recordingService.pushEvents())
        }
        onInitialDomStart() {
            this.recordingService.blockSendingEventsFromSerialization(),
                this.ee.blockSendingLastMessage()
        }
        onInitialDomDone(t) {
            this.recordingService.allowSendingEventsFromSerialization(),
                this.recordingService.addInitialDom(t),
                this.ee.allowSendingLastMessage(),
                this.Zi.start(),
                this.recordingService.pushEvents()
        }
        onAfterReplayRecordingConsentGranted() {
            this.W.isReplayRecorded() &&
                !this.Qc.isUrlExcludedForSessionReplay() &&
                (this.W.isTemporarilyRecorded() &&
                    this.recordingService.blockSendingEventsFromQuotaService(),
                this.ra(),
                this.recordingService.triggerRecordingForSessionGranted())
        }
        onAfterReplayRecordingConsentWithdrawn() {
            this.recordingService.isRecording() &&
                (this.recordingService.triggerRecordingForSessionWithdrawn(),
                this.recordingService.clearStates(),
                this.oa())
        }
        ra() {
            var t
            this.recordingService.updateStaticResourceManagerOnlineAssets(),
                this.na.start(),
                this.recordingService.start(),
                null === (t = this.ta) || void 0 === t || t.start(),
                this.ee.start(),
                this.Ls.emitRecordingStatusChange()
        }
        oa() {
            var t
            this.na.stop(),
                this.recordingService.stop(),
                null === (t = this.ta) || void 0 === t || t.stop(),
                this.ee.stop(),
                this.Ls.emitRecordingStatusChange()
        }
        ha() {
            this.oa(), this.ra()
        }
        sa(t) {
            this.ie = this.Jc.create(
                `${this.$.getRecordingUri()}/${Pn}`,
                !0,
                "byteArray",
                t
            )
        }
        ea() {
            return (
                ln.isAsyncSerializationSupported() &&
                this.$.asyncSerializerEnabled
            )
        }
        ca() {
            return (
                !!this.$.encryptionPublicKey &&
                this.$.encryptionPublicKeyId > 0 &&
                this.aa.isSupported() &&
                this.ua.isSupported()
            )
        }
    }
    var $n, Ln
    ss(
        [$s("Recording.onStartTracking")],
        kn.prototype,
        "onStartTracking",
        null
    ),
        ss([$s("onInitialDomDone")], kn.prototype, "onInitialDomDone", null),
        (function (t) {
            ;(t[(t.NOT_NEEDED = 1)] = "NOT_NEEDED"),
                (t[(t.NOT_EXPRESSED = 2)] = "NOT_EXPRESSED"),
                (t[(t.WITHDRAWN = 3)] = "WITHDRAWN"),
                (t[(t.GRANTED = 4)] = "GRANTED")
        })($n || ($n = {})),
        (function (t) {
            ;(t.isReplayConsentNeeded = function (t) {
                return t.replayConsentRequiredForSession
            }),
                (t.isRecordingBlockedByConsent = function (t) {
                    return (
                        t.recordingState ===
                            ii.BLOCKED_BY_CONSENT_NOT_EXPRESSED ||
                        t.recordingState === ii.BLOCKED_BY_CONSENT_WITHDRAWN
                    )
                }),
                (t.isRecordingWithDrawn = function (t) {
                    return t.recordingState === ii.BLOCKED_BY_CONSENT_WITHDRAWN
                })
        })(Ln || (Ln = {}))
    class xn {
        constructor(t, s, i, e) {
            ;(this.Z = t),
                (this.W = s),
                (this.$ = i),
                (this.da = e),
                (this.fa = !1)
        }
        isNaturalPageViewSent() {
            return this.fa
        }
        setNaturalPageViewSent(t) {
            this.fa = t
        }
        getTrackingContext() {
            const t = this.W.getSession()
            if (!t) return null
            const s = this.getSessionKey()
            if (!s) return null
            const i = this.wa(t),
                e = this.pa(),
                n = this.ma(),
                r = this.Ea()
            return {
                projectId: e,
                sessionKey: s,
                pageNumber: i,
                pageViewType: n,
                isRecording: this.ya(),
                uxaDomain: r,
                recordingConsentState: this.Aa(t),
            }
        }
        getSessionKey() {
            const t = this.Z.getVisitor()
            return t ? `${t.id}.${t.visitsCount}` : null
        }
        Aa(t) {
            return Ln.isReplayConsentNeeded(this.$)
                ? t.recordingState === ii.BLOCKED_BY_CONSENT_NOT_EXPRESSED
                    ? $n.NOT_EXPRESSED
                    : t.recordingState === ii.BLOCKED_BY_CONSENT_WITHDRAWN
                    ? $n.WITHDRAWN
                    : $n.GRANTED
                : $n.NOT_NEEDED
        }
        wa(t) {
            return t.pageNumber
        }
        pa() {
            return this.$.projectId
        }
        ma() {
            return this.da.getPageViewType()
        }
        Ea() {
            return this.$.uxaDomain
        }
        ya() {
            return this.W.isReplayRecorded()
        }
    }
    class Mn {
        constructor(t) {
            ;(this.ga = t), (this.va = [])
        }
        handleCommand(t) {
            if (It(t) && (this._a(t), this.ga.isNaturalPageViewSent())) {
                const s = this.ga.getTrackingContext()
                null !== s && this.Ra(t, s)
            }
        }
        _a(t) {
            csArray.prototype.push.call(this.va, t)
        }
        executeRegisteredCallbacks() {
            const t = this.ga.getTrackingContext()
            null !== t &&
                csArray.prototype.map.call(this.va, (s) => this.Ra(s, t))
        }
        Ra(t, s) {
            setTimeout(() => {
                t(s)
            })
        }
    }
    class Dn {
        constructor(t) {
            ;(this.ga = t), (this.Sa = [])
        }
        handleCommand(t) {
            return this.ga.isNaturalPageViewSent()
                ? this.Ta(t)
                : void this.Ia(t)
        }
        Ta(t) {
            const s = this.ga.getSessionKey()
            return this.Kh(t) && null !== s && this.Ra(t.callback, s), s
        }
        Ia(t) {
            this.Kh(t) && csArray.prototype.push.call(this.Sa, t.callback)
        }
        flushPendingCallbacks() {
            const t = this.ga.getSessionKey()
            null !== t &&
                csArray.prototype.forEach.call(this.Sa, (s) => {
                    this.Ra(s, t)
                }),
                (this.Sa = [])
        }
        Kh(t) {
            return t && "function" == typeof t.callback
        }
        Ra(t, s) {
            setTimeout(() => {
                t(s)
            })
        }
    }
    class Un {
        constructor(t, s) {
            ;(this.Pa = t), (this.ga = s)
        }
        onTrackingContextRequestCallback(t) {
            const s = this.ga.getTrackingContext()
            null !== s &&
                this.Pa.sendToChildren(Zt.TrackingContextResultMessage, {
                    ...t,
                    trackingContext: s,
                })
        }
        onIframeIntegrationCallback(t) {
            if (!this.ga.isNaturalPageViewSent()) return
            const s = this.ga.getTrackingContext()
            null !== s &&
                ((t.trackingContext = s),
                this.Pa.sendToChildren(Zt.IntegrationCallback, t))
        }
        sendAfterPageViewCallbackToChildren() {
            const t = this.ga.getTrackingContext()
            if (null === t) return
            const s = { trackingContext: t, initiator: jt.AfterPageView }
            this.Pa.sendToChildren(Zt.IntegrationCallback, s)
        }
    }
    class zn {
        constructor(t) {
            this.ga = t
        }
        handleCommand(t, s) {
            Rt(t) && It(s) && this.Ra(t, s)
        }
        Ra(t, s) {
            setTimeout(() => {
                const i = this.ga.getTrackingContext()
                if (i) {
                    const e = (function (t, s) {
                        const {
                                isRecording: i,
                                pageNumber: e,
                                projectId: n,
                                uxaDomain: r,
                            } = t,
                            h = /^(.+)\.(\d+)$/.exec(t.sessionKey)
                        let o
                        if (i && h) {
                            const [, t, i] = h
                            ;(o = `${r}/quick-playback/index.html?pid=${n}&uu=${t}&sn=${i}&pvid=${e}&recordingType=cs`),
                                s.withTimestamp &&
                                    (o +=
                                        "&t=" +
                                        (pt.now() - s.recordingStartTimestamp))
                        }
                        return { replayLink: o, isRecording: i }
                    })(i, t)
                    s(e)
                }
            })
        }
    }
    class Fn {
        constructor() {
            this.va = new Set()
        }
        handleCommand(t, s) {
            return It(t)
                ? this.va.has(t)
                    ? null
                    : (this.va.add(t),
                      s && ((this.fo = s), this.ba(t, s)),
                      () => this.va.delete(t))
                : null
        }
        executeCallbacks(t) {
            this.Va(t) && ((this.fo = t), this.va.forEach((s) => this.ba(s, t)))
        }
        ba(t, s) {
            setTimeout(() => {
                try {
                    t(s)
                } catch (t) {}
            })
        }
        Va(t) {
            const {
                isRecording: s,
                recordingStartTimestamp: i,
                etrState: e,
            } = t
            return (
                this.fo &&
                (this.fo.isRecording !== s ||
                    this.fo.recordingStartTimestamp !== i ||
                    this.fo.etrState !== e)
            )
        }
    }
    const Bn = ["afterPageView"],
        Hn = ["getSessionKey"],
        qn = ["onRecordingStateChange"],
        jn = ["replay:link:generate"]
    class Gn {
        constructor(t, s, i, e, n, r, h, o) {
            ;(this.Z = t),
                (this.W = s),
                (this.Wc = i),
                (this.Ca = e),
                (this.Pa = n),
                (this.$ = r),
                (this.da = h),
                (this.Gc = o)
        }
        init() {
            ;(this.ga = new xn(this.Z, this.W, this.$, this.da)),
                (this.Na = new Mn(this.ga)),
                (this.Oa = new Dn(this.ga)),
                (this.ka = new Fn()),
                (this.$a = new zn(this.ga)),
                (this.La = new Un(this.Pa, this.ga)),
                this.Ca.addListener(this.La),
                this.Wc.register(Hn, (t) => this.Oa.handleCommand(t)),
                this.Wc.register(Bn, (t) => this.Na.handleCommand(t)),
                this.Wc.register(qn, (t) => {
                    this.ka.handleCommand(t, this.Gc.getRecordingStatus())
                }),
                this.Wc.register(jn, (t, s) => {
                    this.kn &&
                        this.$a.handleCommand(
                            {
                                ...t,
                                recordingStartTimestamp: this.Gc.getRecordingStatus()
                                    .recordingStartTimestamp,
                            },
                            s
                        )
                })
        }
        onAfterNaturalPageView() {
            this.ga.setNaturalPageViewSent(!0),
                this.Oa.flushPendingCallbacks(),
                this.Na.executeRegisteredCallbacks(),
                this.La.sendAfterPageViewCallbackToChildren()
        }
        onAfterArtificialPageView() {
            this.Na.executeRegisteredCallbacks(),
                this.La.sendAfterPageViewCallbackToChildren()
        }
        onRecordingStateChange() {
            this.ka.executeCallbacks(this.Gc.getRecordingStatus())
        }
        onRecordingStatusChange() {
            this.ka.executeCallbacks(this.Gc.getRecordingStatus())
        }
        setRecordingService(t) {
            this.kn = t
        }
    }
    ss([fe()], Gn.prototype, "onRecordingStateChange", null),
        ss([fe()], Gn.prototype, "onRecordingStatusChange", null)
    class Zn {
        constructor(t, s) {
            ;(this.key = csString.prototype.slice.call(t, 0, 512)),
                (this.value = _t(s)
                    ? csString.prototype.slice.call(s, 0, 255)
                    : s)
        }
        static isValid(t, s) {
            return _t(t) && (_t(s) || vt(s))
        }
    }
    class Wn extends si {
        constructor(t, s) {
            super(), (this.xa = t), (this.L = s), (this.Ma = [])
        }
        onStart() {
            csArray.prototype.forEach.call(this.Ma, (t) =>
                this.trackDynamicVariable(t.key, t.value)
            ),
                (this.Ma = [])
        }
        onStop() {}
        trackDynamicVariable(t, s) {
            this.isStarted
                ? Zn.isValid(t, s) &&
                  this.xa.add(
                      new Zn(this.L.anonymizePII(t), this.L.anonymizePII(s))
                  )
                : csArray.prototype.push.call(this.Ma, { key: t, value: s })
        }
    }
    class Kn {
        constructor(t) {
            ;(this.Zc = t), (this.xa = [])
        }
        add(t) {
            csArray.prototype.push.call(this.xa, t), this.setBatchReadyCall()
        }
        clear() {
            this.xa = []
        }
        onBatchReady(t) {
            this.Da = t
        }
        getRequestParameters() {
            const t = {}
            for (const s of this.xa) t[s.key] = s.value
            return {
                dv: this.Zc.compressSync(csJSON.stringify(t), "base64"),
                ct: this.Zc.algorithm,
            }
        }
        setBatchReadyCall() {
            this.Da()
        }
    }
    ss(
        [fe(), ts("dynamicVariablesBatchReady")],
        Kn.prototype,
        "setBatchReadyCall",
        null
    )
    const Yn = ["trackDynamicVariable"]
    class Qn {
        constructor(t, s, i, e, n, r) {
            ;(this.Wc = t),
                (this.W = s),
                (this.$ = i),
                (this.jo = e),
                (this.Zc = n),
                (this.L = r),
                (this.N = new nt(this.$.getTrackerUri(), "dvar")),
                (this.xa = new Kn(this.Zc)),
                (this.Ua = new Wn(this.xa, this.L))
        }
        init() {
            this.N.setRequestParametersProviders(this.jo, this.xa),
                this.W.setDynamicVariablesService(this.Ua),
                this.xa.onBatchReady(() => this.N.send()),
                this.N.after(() => this.xa.clear()),
                this.Wc.register(Yn, ({ key: t, value: s } = {}) => {
                    this.Ua.trackDynamicVariable(t, s)
                })
        }
        onStartTracking() {
            this.Ua.start()
        }
    }
    class Jn {
        constructor(t, s) {
            ;(this.id = t), (this.revenue = s)
        }
        static from(t) {
            const s = new Jn(t.id, parseFloat(t.revenue))
            return (
                isNaN(parseFloat(t.tax)) || (s.tax = parseFloat(t.tax)),
                isNaN(parseFloat(t.shipping)) ||
                    (s.shipping = parseFloat(t.shipping)),
                _t(t.currency) &&
                    t.currency.length <= 10 &&
                    (s.currency = t.currency),
                s
            )
        }
        hasValidRevenue() {
            return !isNaN(this.revenue) && this.revenue >= 0
        }
        static isValid(t) {
            return (
                Tt(t) &&
                gt(t.revenue) &&
                _t(t.currency) &&
                t.currency.length <= 10 &&
                (!Tt(t.id) || _t(t.id))
            )
        }
    }
    class Xn {
        constructor(t, s, i, e) {
            ;(this.id = t),
                (this.name = s),
                (this.price = i),
                (this.quantity = e)
        }
        static from(t) {
            if (!Xn.za(t)) return null
            const s = new Xn(
                t.id,
                t.name,
                parseFloat(t.price),
                parseInt(t.quantity, 10)
            )
            return (
                St(t.sku) && (s.sku = t.sku),
                St(t.category) && (s.category = t.category),
                St(t.merchant) &&
                    t.merchant.length > 0 &&
                    (s.merchant = t.merchant.slice(0, 100)),
                s
            )
        }
        static za(t) {
            return (
                Tt(t) &&
                _t(t.id) &&
                _t(t.name) &&
                gt(parseFloat(t.price)) &&
                vt(parseInt(t.quantity, 10)) &&
                (!St(t.sku) || _t(t.sku)) &&
                (!St(t.category) || _t(t.category)) &&
                (!St(t.merchant) || _t(t.merchant))
            )
        }
    }
    class tr {
        constructor(t, s, i) {
            ;(this.L = t), (this.Fa = s), (this.Yi = i), this.clear()
        }
        addTransaction(t) {
            const s = this.L.anonymizeFields(t, ["id"])
            this.Ba = Jn.from(s)
        }
        getTransaction() {
            return this.Ba
        }
        sendTransaction() {
            null !== this.Fa &&
                null !== this.Yi &&
                this.Yi.isSessionValid() &&
                (this.Ba.hasValidRevenue()
                    ? this.Fa.send()
                    : Jt.warn(
                          "Transaction Service: unable to send transaction with invalid parameters"
                      ))
        }
        addItem(t) {
            if (It(t)) return
            const s = this.L.anonymizeFields(t, [
                    "id",
                    "name",
                    "sku",
                    "category",
                ]),
                i = Xn.from(s)
            null !== i && csArray.prototype.push.call(this.Ha, i)
        }
        getItems() {
            return this.Ha
        }
        clear() {
            ;(this.Ba = Jn.from({ revenue: NaN })), (this.Ha = [])
        }
        getRequestParameters() {
            const t = {
                id: this.Ba.id ? `${this.Ba.id}` : "",
                revenue: `${this.Ba.revenue}`,
            }
            return (
                St(this.Ba.tax) && (t.tax = `${this.Ba.tax}`),
                St(this.Ba.shipping) && (t.shipping = `${this.Ba.shipping}`),
                St(this.Ba.currency) && (t.cu = `${this.Ba.currency}`),
                (t.items = window.csJSON.stringify(this.Ha)),
                t
            )
        }
    }
    class sr {
        constructor(t, s) {
            ;(this.qa = t), (this.Yi = s), (this.ja = null)
        }
        addToCart(t) {
            const s = {}
            _t(t.sku) && (s.sku = csString.prototype.slice.call(t.sku, 0, 100)),
                _t(t.merchant) &&
                    (s.merchant = csString.prototype.slice.call(
                        t.merchant,
                        0,
                        100
                    )),
                (s.sku || s.merchant) && ((this.ja = s), this.sendCartItem())
        }
        getCartItem() {
            return this.ja
        }
        sendCartItem() {
            this.Yi.isSessionValid() && this.qa.send()
        }
        clear() {
            this.ja = null
        }
        getRequestParameters() {
            if (!this.ja) return {}
            const t = {}
            return (
                _t(this.ja.sku) &&
                    this.ja.sku.length > 0 &&
                    (t.sku = this.ja.sku),
                _t(this.ja.merchant) &&
                    this.ja.merchant.length > 0 &&
                    (t.me = this.ja.merchant),
                t
            )
        }
    }
    const ir = ["ecommerce:addToCart", "ec:cart:add"],
        er = ["ecommerce:addTransaction", "ec:transaction:create"],
        nr = ["ecommerce:addItem", "ec:transaction:items:add"],
        rr = ["ecommerce:send", "ec:transaction:send"]
    class hr {
        constructor(t, s, i, e, n, r, h) {
            ;(this.$ = t),
                (this.Bo = s),
                (this.Z = i),
                (this.Wc = e),
                (this.L = n),
                (this.Yi = r),
                (this.X = h)
        }
        init() {
            const t = new nt(this.$.getTrackerUri(), "transaction"),
                s = new nt(this.$.getTrackerUri(), "addtocart"),
                i = new tr(this.L, t, this.Yi),
                e = new sr(s, this.Yi),
                n = new le(this.Bo, this.Z, this.X, i)
            t.setRequestParametersProviders(n),
                t.after(() => {
                    i.clear()
                })
            const r = new le(this.Bo, this.Z, this.X, e)
            s.setRequestParametersProviders(r),
                s.after(() => {
                    e.clear()
                }),
                this.Wc.register(er, (t) => {
                    i.addTransaction(t)
                }),
                this.Wc.register(nr, (t) => i.addItem(t)),
                this.Wc.register(rr, () => i.sendTransaction()),
                this.Wc.register(ir, (t) => {
                    e.addToCart(t)
                })
        }
    }
    class or {
        constructor(t) {
            this.ir = t.performance
        }
        getRequestParameters() {
            if (this.Ga()) return {}
            const t = this.Za()
            return {
                str: t.startRender,
                di: t.domInteractive,
                dc: t.domComplete,
                fl: t.fullyLoaded,
            }
        }
        Za() {
            const t = this.ir.timing
            return {
                startRender: "" + (t.domLoading - t.requestStart),
                domInteractive: "" + (t.domInteractive - t.requestStart),
                domComplete: "" + (t.domComplete - t.requestStart),
                fullyLoaded: "" + (t.loadEventEnd - t.requestStart),
            }
        }
        Ga() {
            return !(
                this.ir &&
                this.ir.timing &&
                this.ir.timing.loadEventEnd > 0
            )
        }
    }
    var cr, ar
    function ur(t) {
        return void 0 !== t.tgt
    }
    !(function (t) {
        ;(t[(t.RESIZE = 0)] = "RESIZE"),
            (t[(t.SCROLL = 1)] = "SCROLL"),
            (t[(t.MOUSEMOVE = 2)] = "MOUSEMOVE"),
            (t[(t.MOUSEDOWN = 3)] = "MOUSEDOWN"),
            (t[(t.MOUSEUP = 4)] = "MOUSEUP"),
            (t[(t.CLICK = 5)] = "CLICK"),
            (t[(t.MOUSEOVER = 6)] = "MOUSEOVER"),
            (t[(t.MOUSEOUT = 7)] = "MOUSEOUT"),
            (t[(t.CHANGE = 10)] = "CHANGE"),
            (t[(t.FOCUSIN = 11)] = "FOCUSIN"),
            (t[(t.FOCUSOUT = 12)] = "FOCUSOUT"),
            (t[(t.TAP = 14)] = "TAP"),
            (t[(t.KEYDOWN = 15)] = "KEYDOWN"),
            (t[(t.KEYUP = 16)] = "KEYUP"),
            (t[(t.COMMAND = 17)] = "COMMAND"),
            (t[(t.SUBMIT = 18)] = "SUBMIT"),
            (t[(t.PERFORMANCE = 19)] = "PERFORMANCE"),
            (t[(t.DRAG = 20)] = "DRAG"),
            (t[(t.FLICK = 21)] = "FLICK"),
            (t[(t.KEYBOARD_NAVIGATION = 22)] = "KEYBOARD_NAVIGATION"),
            (t[(t.ZOOM = 23)] = "ZOOM"),
            (t[(t.VIEWPORT_SCALE = 24)] = "VIEWPORT_SCALE"),
            (t[(t.TEXT_HIGHLIGHT = 25)] = "TEXT_HIGHLIGHT"),
            (t[(t.DEAD_CLICK = 30)] = "DEAD_CLICK"),
            (t[(t.DEAD_ZOOM = 31)] = "DEAD_ZOOM"),
            (t[(t.PAGE_RELOAD = 32)] = "PAGE_RELOAD"),
            (t[(t.THRASHED_CURSOR = 33)] = "THRASHED_CURSOR"),
            (t[(t.BLANK_PAGE = 34)] = "BLANK_PAGE")
    })(cr || (cr = {})),
        (function (t) {
            ;(t.SUCCESS = "success"),
                (t.FAILURE = "failure"),
                (t.ATTEMPT = "attempt")
        })(ar || (ar = {}))
    class lr {
        isEventTypeSupported(t) {
            return (
                -1 !==
                csArray.prototype.indexOf.call(this.supportedEventTypes, t)
            )
        }
        enhanceAnalysisEvent(t, s) {
            return this.isEventTypeSupported(s.type)
                ? this.baseEnhanceAnalysisEvent(t, s)
                : s
        }
    }
    class dr extends lr {
        constructor(t) {
            super(),
                (this.Wa = t),
                (this.supportedEventTypes = [
                    cr.MOUSEDOWN,
                    cr.MOUSEUP,
                    cr.CLICK,
                    cr.MOUSEOVER,
                    cr.TAP,
                ])
        }
        baseEnhanceAnalysisEvent(t, s) {
            const {
                path: i,
                targetLink: e,
            } = this.Wa.getEventTargetPathAndTargetLink(t)
            return (s.tgt = i), (s.tgtLk = e), s
        }
    }
    class fr {
        static build(t, s, i) {
            return csArray.prototype.reduce.call(
                i,
                (s, i) => i.enhanceAnalysisEvent(t, s),
                s
            )
        }
    }
    class wr extends lr {
        constructor(t) {
            super(),
                (this.Wa = t),
                (this.supportedEventTypes = [
                    cr.MOUSEDOWN,
                    cr.MOUSEUP,
                    cr.CLICK,
                    cr.MOUSEOVER,
                    cr.TAP,
                    cr.DRAG,
                    cr.FLICK,
                ])
        }
        baseEnhanceAnalysisEvent(t, s) {
            return s.tgt || (s.tgt = this.Wa.getEventTargetPath(t)), s
        }
    }
    class pr {
        constructor(t, s, i, e) {
            ;(this.$ = t),
                (this.Wa = s),
                (this.Or = i),
                (this.Ka = e),
                (this.Ya = []),
                this.$.eMerchandisingEnabled &&
                    csArray.prototype.push.call(this.Ya, new dr(this.Wa)),
                csArray.prototype.push.call(this.Ya, new wr(this.Wa))
        }
        processGesture(t, s) {
            switch (t.type) {
                case $e.TAP:
                    this.Qa(s)
                    break
                case $e.FLICK:
                    this.Ja(t, s)
                    break
                case $e.DRAG:
                    this.Xa(t, s)
            }
        }
        Qa(t) {
            const s = { type: cr.TAP, ts: 0, x: 0, y: 0, tgt: "" },
                i = fr.build(t, s, this.Ya)
            i.tgt !== j.INVALID_ELEMENT && this.zs(i)
        }
        Xa(t, s) {
            var i, e
            const n = { type: cr.DRAG, ts: 0, fd: t.direction, tgt: "" }
            ;(null === (i = this.Ka) || void 0 === i
                ? void 0
                : i.collectGestureDistance) && (n.distance = t.distance),
                (null === (e = this.Ka) || void 0 === e
                    ? void 0
                    : e.collectGestureVelocity) && (n.velocity = t.velocity)
            const r = fr.build(s, n, this.Ya)
            r.tgt !== j.INVALID_ELEMENT && this.zs(r)
        }
        Ja(t, s) {
            var i, e
            const n = { type: cr.FLICK, ts: 0, fd: t.direction, tgt: "" }
            ;(null === (i = this.Ka) || void 0 === i
                ? void 0
                : i.collectGestureDistance) && (n.distance = t.distance),
                (null === (e = this.Ka) || void 0 === e
                    ? void 0
                    : e.collectGestureVelocity) && (n.velocity = t.velocity)
            const r = fr.build(s, n, this.Ya)
            r.tgt !== j.INVALID_ELEMENT && this.zs(r)
        }
        onEvent(t) {
            this.zs = t
        }
        start() {
            this.Or.subscribe(pr.kr, (t, s) => this.processGesture(t, s))
        }
        stop() {
            this.Or.unsubscribe(pr.kr)
        }
    }
    ;(pr.kr = "AnalysisGestureTracker"),
        ss([xs()], pr.prototype, "processGesture", null)
    var mr
    !(function (t) {
        t.getRelativePosition = function (t) {
            const s = Ls(t)
            if (
                !(
                    s &&
                    u(s) &&
                    It(s.getBoundingClientRect) &&
                    Tt(t.pageX) &&
                    Tt(t.pageY)
                )
            )
                return { xRel: -1, yRel: -1, valid: !1 }
            const i = s.getBoundingClientRect()
            let e = t.pageX - i.left - Vi.windowOffsetX(),
                n = t.pageY - i.top - Vi.windowOffsetY()
            s !== document.documentElement &&
                ((e += s.scrollLeft), (n += s.scrollTop))
            const r = Math.max(s.scrollWidth, i.width),
                h = Math.max(s.scrollHeight, i.height)
            return {
                xRel: Math.round((e / r) * 65535),
                yRel: Math.round((n / h) * 65535),
                valid: !0,
            }
        }
    })(mr || (mr = {}))
    class Er extends lr {
        constructor(t, s) {
            super(),
                (this.V = t),
                (this.Wa = s),
                (this.supportedEventTypes = [cr.MOUSEMOVE]),
                (this.tu = "")
        }
        baseEnhanceAnalysisEvent(t, s) {
            const { valid: i, xRel: e, yRel: n } = mr.getRelativePosition(t)
            if (i) {
                const i = this.Wa.getEventTargetPath(t)
                i !== j.INVALID_ELEMENT &&
                    ((s.xRel = e),
                    (s.yRel = n),
                    i !== this.tu || this.V.iframesTracking
                        ? ((this.tu = i), (s.tgtHM = i))
                        : (s.tgtHM = ""))
            } else this.tu = ""
            return s
        }
    }
    class yr extends lr {
        constructor() {
            super(...arguments),
                (this.supportedEventTypes = [cr.CHANGE]),
                (this.su = [
                    "text",
                    "email",
                    "number",
                    "search",
                    "tel",
                    "url",
                    "password",
                ])
        }
        baseEnhanceAnalysisEvent(t, s) {
            const i = Ls(t)
            return (
                y(i) &&
                    csArray.prototype.indexOf.call(this.su, i.type) >= 0 &&
                    (s.isBlank = "" === i.value),
                s
            )
        }
    }
    class Ar {
        constructor(t, s, i) {
            ;(this.V = t),
                (this.Wa = s),
                (this.iu = i),
                (this.eu = "select, select *, input, textarea"),
                (this.nu = "select, select *, input, textarea"),
                (this.ru =
                    "a, a *, button, button *, select, select *, input, textarea"),
                (this.hu = "input, select, textarea"),
                (this.ou = 150),
                (this.au = 400),
                (this.lu = !1),
                (this.du = de((t, s) => this.scrollListener(t, s), this.ou)),
                (this.fu = de((t) => this.resizeListener(t), this.ou)),
                (this.wu = Ss((t) => this.mouseMoveListener(t), this.au)),
                (this.pu = [
                    {
                        boundElement: window,
                        type: "resize",
                        listener: () => this.fu(),
                    },
                    {
                        boundElement: document,
                        type: "scroll",
                        listener: (t) => this.du(t),
                    },
                    {
                        boundElement: window,
                        type: "mousemove",
                        listener: (t) => {
                            this.wu(
                                (function (t) {
                                    return (
                                        t.composedPath &&
                                            Object.defineProperty(
                                                t,
                                                "__csOriginalTarget",
                                                {
                                                    value: t.composedPath()[0],
                                                    writable: !1,
                                                    enumerable: !1,
                                                }
                                            ),
                                        t
                                    )
                                })(t)
                            )
                        },
                    },
                    {
                        boundElement: document,
                        type: "mousedown",
                        listener: (t) => this.mouseDownListener(t),
                    },
                    {
                        boundElement: document,
                        type: "mouseup",
                        listener: (t) => this.mouseUpListener(t),
                    },
                    {
                        boundElement: document,
                        type: "click",
                        listener: (t) => this.clickListener(t),
                    },
                ]),
                (this.mu = [
                    {
                        type: "change",
                        listener: this.iu.on(this.nu, (t) =>
                            this.changeListener(t)
                        ),
                    },
                ]),
                (this.Eu = [
                    {
                        boundElement: document,
                        type: "mouseover",
                        listener: this.iu.on(this.ru, (t) =>
                            this.mouseOverListener(t)
                        ),
                    },
                    {
                        boundElement: document,
                        type: "mouseout",
                        listener: this.iu.on(this.ru, (t) =>
                            this.mouseOutListener(t)
                        ),
                    },
                    {
                        boundElement: document,
                        type: "focusin",
                        listener: this.iu.on(this.eu, (t) =>
                            this.focusInListener(t)
                        ),
                    },
                    {
                        boundElement: document,
                        type: "focusout",
                        listener: this.iu.on(this.eu, (t) =>
                            this.focusOutListener(t)
                        ),
                    },
                    {
                        boundElement: document,
                        type: "keyup",
                        listener: this.iu.on(this.hu, (t) =>
                            this.keyUpListener(t)
                        ),
                    },
                    {
                        boundElement: document,
                        type: "keydown",
                        listener: this.iu.on(this.hu, (t) =>
                            this.keyDownListener(t)
                        ),
                    },
                    {
                        boundElement: document,
                        type: "copy",
                        listener: this.iu.on(this.hu, (t) =>
                            this.copyListener(t)
                        ),
                    },
                    {
                        boundElement: document,
                        type: "cut",
                        listener: this.iu.on(this.hu, (t) =>
                            this.cutListener(t)
                        ),
                    },
                    {
                        boundElement: document,
                        type: "paste",
                        listener: this.iu.on(this.hu, (t) =>
                            this.pasteListener(t)
                        ),
                    },
                    ...csArray.prototype.map.call(this.mu, (t) => ({
                        ...t,
                        boundElement: document,
                    })),
                ]),
                (this.Ya = []),
                (this.Ns = {}),
                (this.ls = new Set()),
                (this.yu = (t, s) => {
                    switch (s) {
                        case "initial":
                            this.ls.add(t)
                            break
                        case "added":
                            this.ls.has(t) || (this.ls.add(t), this._s(t))
                            break
                        case "removed":
                            this.bs(t), this.ls.delete(t)
                    }
                }),
                bi.isSupported() && (this.Au = new ki(this.yu)),
                this.gs(),
                this.V.eMerchandisingEnabled &&
                    csArray.prototype.push.call(this.Ya, new dr(this.Wa)),
                this.V.mouseMoveHeatmapEnabled &&
                    csArray.prototype.push.call(
                        this.Ya,
                        new Er(this.V, this.Wa)
                    ),
                csArray.prototype.push.call(this.Ya, new yr(), new wr(this.Wa))
        }
        _s(t) {
            if (S(t)) {
                const t = this.gu()
                csArray.prototype.forEach.call(t, (t) => vs(t))
            } else {
                const s = this.vu()
                csArray.prototype.forEach.call(s, (s) => {
                    vs({ ...s, boundElement: t })
                })
            }
        }
        bs(t) {
            if (S(t)) {
                const t = this.gu()
                csArray.prototype.forEach.call(t, (t) => _s(t))
            } else {
                const s = this.vu()
                csArray.prototype.forEach.call(s, (s) => {
                    _s({ ...s, boundElement: t })
                })
            }
        }
        onEvent(t) {
            this.zs = t
        }
        start() {
            var t
            null === (t = this.Au) || void 0 === t || t.observe(document),
                this._s(document),
                this.ls.forEach((t) => this._s(t)),
                this.resizeListener()
        }
        stop() {
            var t
            this.bs(document),
                this.ls.forEach((t) => this.bs(t)),
                null === (t = this.Au) || void 0 === t || t.disconnect(),
                this.ls.clear()
        }
        flushPendingDebouncedListeners() {
            this.du.flushPending(), this.fu.flushPending()
        }
        vu() {
            return this.iu.isMatchesSelectorSupported()
                ? this.mu
                : (Jt.warn("Element.matches is not implemented yet"), [])
        }
        gu() {
            return this.iu.isMatchesSelectorSupported()
                ? [...this.pu, ...this.Eu]
                : (Jt.warn("Element.matches is not implemented yet"), this.pu)
        }
        resizeListener(t) {
            const s = Us.getScrollContainer(),
                i = Pt(s)
            i && (this.lu = !0)
            const e = {
                type: cr.RESIZE,
                ts: 0,
                x: i ? s.clientWidth : Vi.windowWidth(),
                y: i ? s.clientHeight : Vi.windowHeight(),
            }
            void 0 !== t && (e.d = t), this.zs(e)
        }
        scrollListener(t, s) {
            const i = Us.isEventOnScrollContainer(s)
            !this.lu && i && this.resizeListener()
            const e = {
                    type: cr.SCROLL,
                    ts: 0,
                    x: i
                        ? csEventtarget.apply(s).scrollLeft
                        : Vi.windowOffsetX(),
                    y: i
                        ? csEventtarget.apply(s).scrollTop
                        : Vi.windowOffsetY(),
                    d: t,
                },
                n = fr.build(s, e, this.Ya)
            this.zs(n)
        }
        mouseMoveListener(t) {
            const s = { type: cr.MOUSEMOVE, ts: 0, x: t.pageX, y: t.pageY },
                i = fr.build(t, s, this.Ya)
            this.zs(i)
        }
        mouseDownListener(t) {
            const s = {
                    type: cr.MOUSEDOWN,
                    ts: 0,
                    x: t.pageX,
                    y: t.pageY,
                    tgt: "",
                },
                i = fr.build(t, s, this.Ya)
            this._u(i)
        }
        mouseUpListener(t) {
            const s = {
                    type: cr.MOUSEUP,
                    ts: 0,
                    x: t.pageX,
                    y: t.pageY,
                    tgt: "",
                },
                i = fr.build(t, s, this.Ya)
            this._u(i)
        }
        clickListener(t) {
            const s = {
                    type: cr.CLICK,
                    ts: 0,
                    x: t.pageX,
                    y: t.pageY,
                    tgt: "",
                },
                i = fr.build(t, s, this.Ya)
            this._u(i)
        }
        mouseOverListener(t) {
            const s = {
                    type: cr.MOUSEOVER,
                    ts: 0,
                    x: t.pageX,
                    y: t.pageY,
                    tgt: "",
                },
                i = fr.build(t, s, this.Ya)
            this._u(i)
        }
        mouseOutListener(t) {
            const s = {
                    type: cr.MOUSEOUT,
                    ts: 0,
                    x: t.pageX,
                    y: t.pageY,
                    tgt: this.Wa.getEventTargetPath(t),
                },
                i = fr.build(t, s, this.Ya)
            this._u(i)
        }
        focusInListener(t) {
            const s = {
                    type: cr.FOCUSIN,
                    ts: 0,
                    tgt: this.Wa.getEventTargetPath(t),
                },
                i = fr.build(t, s, this.Ya)
            this._u(i)
        }
        focusOutListener(t) {
            const s = {
                    type: cr.FOCUSOUT,
                    ts: 0,
                    tgt: this.Wa.getEventTargetPath(t),
                },
                i = fr.build(t, s, this.Ya)
            this._u(i)
        }
        changeListener(t) {
            const s = {
                    type: cr.CHANGE,
                    ts: 0,
                    tgt: this.Wa.getEventTargetPath(t),
                },
                i = fr.build(t, s, this.Ya)
            this._u(i)
        }
        copyListener(t) {
            const s = {
                type: cr.COMMAND,
                ts: 0,
                tgt: this.Wa.getEventTargetPath(t),
                key: Ps.COPY,
            }
            this._u(s)
        }
        cutListener(t) {
            const s = {
                type: cr.COMMAND,
                ts: 0,
                tgt: this.Wa.getEventTargetPath(t),
                key: Ps.CUT,
            }
            this._u(s)
        }
        pasteListener(t) {
            const s = {
                type: cr.COMMAND,
                ts: 0,
                tgt: this.Wa.getEventTargetPath(t),
                key: Ps.PASTE,
            }
            this._u(s)
        }
        keyUpListener(t) {
            const s = {
                type: cr.KEYUP,
                ts: 0,
                tgt: this.Wa.getEventTargetPath(t),
                key: this.Ru(t),
            }
            this._u(s)
        }
        keyDownListener(t) {
            const s = {
                type: cr.KEYDOWN,
                ts: 0,
                tgt: this.Wa.getEventTargetPath(t),
                key: this.Ru(t),
            }
            this._u(s)
        }
        Ru(t) {
            const s = this.Ns[t.key]
            return void 0 === s ? Is.ALPHANUMERICAL : s
        }
        _u(t) {
            ur(t) && t.tgt !== j.INVALID_ELEMENT && this.zs(t)
        }
        gs() {
            ;(this.Ns[" "] = Is.SPACE),
                (this.Ns.Spacebar = Is.SPACE),
                (this.Ns.Enter = Is.ENTER),
                (this.Ns.Backspace = Is.BACKSPACE),
                (this.Ns.Delete = Is.DELETE),
                (this.Ns.ArrowUp = Is.ARROWUP),
                (this.Ns.ArrowDown = Is.ARROWDOWN),
                (this.Ns.ArrowLeft = Is.ARROWLEFT),
                (this.Ns.ArrowRight = Is.ARROWRIGHT),
                (this.Ns.Up = Is.ARROWUP),
                (this.Ns.Down = Is.ARROWDOWN),
                (this.Ns.Left = Is.ARROWLEFT),
                (this.Ns.Right = Is.ARROWRIGHT),
                (this.Ns.CapsLock = Is.CAPSLOCK),
                (this.Ns.Shift = Is.SHIFT),
                (this.Ns.Tab = Is.TAB)
        }
    }
    ss(
        [ts("Event handler type: resize")],
        Ar.prototype,
        "resizeListener",
        null
    ),
        ss(
            [ts("Event handler type: scroll")],
            Ar.prototype,
            "scrollListener",
            null
        ),
        ss(
            [ts("Event handler type: mouseMove"), xs()],
            Ar.prototype,
            "mouseMoveListener",
            null
        ),
        ss(
            [ts("Event handler type: mouseDown"), xs()],
            Ar.prototype,
            "mouseDownListener",
            null
        ),
        ss(
            [ts("Event handler type: mouseUp"), xs()],
            Ar.prototype,
            "mouseUpListener",
            null
        ),
        ss(
            [ts("Event handler type: click"), xs()],
            Ar.prototype,
            "clickListener",
            null
        ),
        ss(
            [ts("Event handler type: mouseOver"), xs()],
            Ar.prototype,
            "mouseOverListener",
            null
        ),
        ss(
            [ts("Event handler type: mouseOut"), xs()],
            Ar.prototype,
            "mouseOutListener",
            null
        ),
        ss(
            [ts("Event handler type: focusIn")],
            Ar.prototype,
            "focusInListener",
            null
        ),
        ss(
            [ts("Event handler type: focusOut")],
            Ar.prototype,
            "focusOutListener",
            null
        ),
        ss(
            [ts("Event handler type: change")],
            Ar.prototype,
            "changeListener",
            null
        ),
        ss(
            [ts("Event handler type: copy")],
            Ar.prototype,
            "copyListener",
            null
        ),
        ss([ts("Event handler type: cut")], Ar.prototype, "cutListener", null),
        ss(
            [ts("Event handler type: paste")],
            Ar.prototype,
            "pasteListener",
            null
        ),
        ss(
            [ts("Event handler type: keyup")],
            Ar.prototype,
            "keyUpListener",
            null
        ),
        ss(
            [ts("Event handler type: keydown")],
            Ar.prototype,
            "keyDownListener",
            null
        )
    class gr {
        constructor() {
            ;(this.Su = 100),
                (this.Tu = 0),
                (this.Iu = Vi.documentHeight()),
                (this.Pu = {
                    boundElement: document,
                    type: "scroll",
                    listener: (t) => this.maxScrollRateListener(t),
                })
        }
        onEvent(t) {
            this.zs = t
        }
        start() {
            vs(this.Pu), this.reset()
        }
        stop() {
            _s(this.Pu)
        }
        reset() {
            this.Iu = Vi.documentHeight()
            const t = Us.getScrollContainer()
            if (null === t) this.Tu = this.bu(Vi.documentHeight())
            else {
                const s = this.Vu(t)
                this.Tu = this.Cu(t, s)
            }
            this.zs()
        }
        maxScrollRateListener(t) {
            let s, i
            if (Us.isEventOnScrollContainer(t)) {
                const e = csEventtarget.apply(t),
                    n = this.Vu(e)
                ;(s = this.Nu(e, n)), (i = this.Cu(e, n))
            } else (s = Vi.documentHeight()), (i = this.bu(s))
            ;(i > this.Tu || s > this.Iu) &&
                ((this.Tu = i), s > this.Iu && (this.Iu = s), this.zs())
        }
        bu(t) {
            const s = Math.round((this.Ou() / t) * 100)
            return Math.min(s, this.Su)
        }
        Ou() {
            const t = Vi.windowHeight()
            return Vi.windowOffsetY() + t
        }
        Cu(t, s) {
            const i =
                    t.scrollTop +
                    t.clientHeight +
                    t.getBoundingClientRect().top +
                    s,
                e = this.Nu(t, s),
                n = Math.round((i / e) * 100)
            return Math.min(n, this.Su)
        }
        Vu(t) {
            const s = window.getComputedStyle(t).paddingTop || "0px"
            return parseInt(s, 10)
        }
        Nu(t, s) {
            return t.scrollHeight + t.getBoundingClientRect().top + s
        }
        getRequestParameters() {
            return { sr: `${this.Tu}`, mdh: `${this.Iu}` }
        }
    }
    ss(
        [ts("MaxScrollRate handler")],
        gr.prototype,
        "maxScrollRateListener",
        null
    )
    class vr {
        constructor(
            t,
            s,
            i,
            e,
            n,
            r,
            h,
            o,
            c,
            a,
            u,
            l,
            d,
            f,
            w,
            p,
            m,
            E,
            y,
            A,
            g
        ) {
            ;(this.$ = t),
                (this.ku = s),
                (this.Or = i),
                (this.$u = e),
                (this.Lu = n),
                (this.xu = r),
                (this.Mu = h),
                (this.Du = o),
                (this.Yi = c),
                (this.Zt = a),
                (this.Uu = u),
                (this.zu = l),
                (this.Ae = d),
                (this.ie = f),
                (this.Fu = w),
                (this.Bu = p),
                (this.Hu = m),
                (this.qu = E),
                (this.ju = y),
                (this.Gu = A),
                (this.Zu = g),
                (this.ae = new ti()),
                (this.Wu = !1)
        }
        init() {
            var t, s, i, e, n, r, h
            this.ku.onEvent((t) => this.pe(t)),
                this.Or.onEvent((t) => this.pe(t)),
                this.$u.onEvent(() => {
                    const t = this.$u.getRequestParameters()
                    this.ie.setQueryParams(t), this.Mu.setQueryParams(t)
                }),
                this.zu.onEvent((t) => this.Ku(t)),
                this.Yu(),
                null === (t = this.Fu) ||
                    void 0 === t ||
                    t.onEvent((t) => this.pe(t)),
                null === (s = this.ju) ||
                    void 0 === s ||
                    s.onEvent((t) => this.pe(t)),
                null === (i = this.Bu) ||
                    void 0 === i ||
                    i.onEvent((t) => this.pe(t)),
                null === (e = this.Hu) ||
                    void 0 === e ||
                    e.onEvent((t) => this.pe(t)),
                this.Qu(),
                null === (n = this.qu) ||
                    void 0 === n ||
                    n.onEvent((t) => this.Ku(t)),
                null === (r = this.Gu) ||
                    void 0 === r ||
                    r.onEvent((t) => this.Ku(t)),
                null === (h = this.Zu) ||
                    void 0 === h ||
                    h.onEvent((t) => this.Ku(t))
        }
        Qu() {
            this.Mu.onBeaconSuccess(() => {
                this.xu.clearEvents()
            }),
                this.Mu.onBeaconFailure((t) => {
                    this.Ju(t)
                })
        }
        initStates() {
            const t = this.Du.getRequestParameters(),
                s = this.Lu.getRequestParameters(),
                i = this.$u.getRequestParameters()
            this.ie.setQueryParams(t),
                this.ie.setQueryParams(s),
                this.ie.setQueryParams(i),
                this.Mu.setQueryParams(t),
                this.Mu.setQueryParams(s),
                this.Mu.setQueryParams(i),
                this.Xu()
        }
        start(t) {
            var s, i, e, n, r, h, o
            t || null === (s = this.qu) || void 0 === s || s.start(),
                this.Ae.start(),
                this.ku.start(),
                this.$u.start(),
                this.Or.start(),
                null === (i = this.Fu) || void 0 === i || i.start(),
                null === (e = this.Hu) || void 0 === e || e.start(),
                t || this.zu.start(),
                null === (n = this.Bu) || void 0 === n || n.start(),
                null === (r = this.ju) || void 0 === r || r.start(),
                null === (h = this.Gu) || void 0 === h || h.start(),
                null === (o = this.Zu) || void 0 === o || o.start()
        }
        collectInitialEvents() {
            var t
            null === (t = this.Fu) || void 0 === t || t.collectInitialEvents()
        }
        onIframeAnalysisEvent(t) {
            this.$e(t)
        }
        Ku(t) {
            this.Yi.isCurrentPageviewValid() && this.$e(t)
        }
        pe(t) {
            this.Yi.isSessionValid() && this.$e(t)
        }
        $e(t) {
            this.xu.addEvent(this.tl(t)),
                this.xu.isFull() && this.sendEvents(),
                this.$.emitDebugEvents &&
                    this.ae.emit("analysisEvent", {
                        ...t,
                        typeName: cr[t.type],
                    })
        }
        tl(t) {
            return (t.ts = this.sl()), t
        }
        il() {
            this.Mu.setQueryParams({ hlm: "true" }), (this.Wu = !0)
        }
        sendLastMessageBeacon() {
            this.Mu.setQueryParams(this.Lu.getRequestParameters()),
                this.Mu.send(this.xu.stringifyEvents()),
                this.Mu.removeQueryParams(["hlm"]),
                (this.Wu = !1)
        }
        sendEvents() {
            this.xu.isEmpty() ||
                (this.ie.setQueryParams(this.Du.getRequestParameters()),
                this.ie.setQueryParams(this.Lu.getRequestParameters()),
                this.ie.send(this.xu.getEvents()),
                this.xu.clearEvents())
        }
        stop() {
            var t, s, i, e, n, r, h
            this.Ae.stop(),
                this.ku.stop(),
                this.$u.stop(),
                this.Or.stop(),
                this.zu.stop(),
                null === (t = this.Fu) || void 0 === t || t.stop(),
                null === (s = this.Bu) || void 0 === s || s.stop(),
                null === (i = this.Hu) || void 0 === i || i.stop(),
                null === (e = this.ju) || void 0 === e || e.stop(),
                this.xu.empty(),
                null === (n = this.qu) || void 0 === n || n.stop(),
                null === (r = this.Gu) || void 0 === r || r.stop(),
                null === (h = this.Zu) || void 0 === h || h.stop()
        }
        clearStates(t) {
            var s, i
            this.ku.flushPendingDebouncedListeners(),
                null === (s = this.Bu) ||
                    void 0 === s ||
                    s.flushPendingKeyboardNavigationEvent(),
                null === (i = this.Hu) ||
                    void 0 === i ||
                    i.flushPendingTextHighlightEvent(),
                t
                    ? (this.il(), this.sendLastMessageBeacon())
                    : this.sendEvents(),
                this.$u.reset(),
                this.zu.stop(),
                this.ie.removeQueryParams()
        }
        Xu() {
            this.el = pt.now()
        }
        sl() {
            return pt.now() - this.el
        }
        Yu() {
            this.Ae.onEvent((t) => {
                var s, i
                null === (s = this.Bu) ||
                    void 0 === s ||
                    s.flushPendingKeyboardNavigationEvent(),
                    null === (i = this.Hu) ||
                        void 0 === i ||
                        i.flushPendingTextHighlightEvent(),
                    t === ri.PagehideVisible
                        ? this.il()
                        : t === ri.PagehideHidden
                        ? (this.il(), this.sendLastMessageBeacon())
                        : (this.xu.isEmpty() && !this.Wu) ||
                          this.sendLastMessageBeacon()
            })
        }
        Ju(t) {
            try {
                ;(this.xu.isEmpty() && !this.Wu) ||
                    this.Zt.save({
                        requestParameters: t,
                        events: this.xu.getEvents(),
                    })
            } catch {}
        }
        pushSubmitEvent(t, s) {
            if (
                !(function (t) {
                    return (
                        t === ar.SUCCESS || t === ar.FAILURE || t === ar.ATTEMPT
                    )
                })(t)
            )
                return void Jt.warn(
                    `AnalysisEvents Service: invalid submit status: ${t}`
                )
            if (!Pt(s))
                return void Jt.warn(
                    `AnalysisEvents Service: invalid element: ${s}`
                )
            const i = {
                status: t,
                type: cr.SUBMIT,
                ts: 0,
                tgt: this.Uu.getElementPath(s),
            }
            i.tgt !== j.INVALID_ELEMENT && this.Ku(i)
        }
    }
    class _r {
        constructor(t, s) {
            ;(this.Zt = t),
                (this.ie = s),
                (this.nl = () => {
                    "visible" === document.visibilityState && this.rl()
                })
        }
        start() {
            this.rl(), this.Ai()
        }
        stop() {
            this._i()
        }
        getRecoveryStorage() {
            return this.Zt
        }
        rl() {
            const t = this.Zt.recover()
            if (null !== t) {
                const { requestParameters: s, events: i } = t
                this.ie.send(i, s)
            }
        }
        Ai() {
            document.addEventListener("visibilitychange", this.nl)
        }
        _i() {
            document.removeEventListener("visibilitychange", this.nl)
        }
    }
    class Rr {
        constructor(t) {
            this.oo = t
        }
        save(t) {
            localStorage.setItem(this.oo, csJSON.stringify(t))
        }
        clear() {
            localStorage.removeItem(this.oo)
        }
        recover() {
            const t = localStorage.getItem(this.oo)
            if (null === t) return null
            let s = null
            try {
                s = csJSON.parse(t)
            } catch {
                Jt.error(
                    `Invalid item in localStorage.\n         (key:${this.oo}; value:${t})`
                )
            } finally {
                this.clear()
            }
            return s
        }
    }
    class Sr {
        constructor(t) {
            ;(this.hl = t),
                (this.ol = (t) => this.processMetric(t)),
                (this.mi = !1)
        }
        onEvent(t) {
            this.zs = t
        }
        start() {
            this.mi ||
                ((this.mi = !0),
                this.hl.onFCP(this.ol),
                this.hl.onCLS(this.ol),
                this.hl.onFID(this.ol),
                this.hl.onLCP(this.ol),
                this.hl.onTTFB(this.ol),
                this.hl.onINP(this.ol))
        }
        stop() {
            this.mi = !1
        }
        processMetric(t) {
            if (!this.mi) return
            const s = {
                type: cr.PERFORMANCE,
                name: t.name,
                val: t.value,
                ts: 0,
            }
            this.zs(s)
        }
    }
    ss([ts("Performance metric handler")], Sr.prototype, "processMetric", null)
    var Tr,
        Ir,
        Pr,
        br,
        Vr,
        Cr = -1,
        Nr = function (t) {
            addEventListener(
                "pageshow",
                function (s) {
                    s.persisted && ((Cr = s.timeStamp), t(s))
                },
                !0
            )
        },
        Or = function () {
            return (
                window.performance &&
                performance.getEntriesByType &&
                performance.getEntriesByType("navigation")[0]
            )
        },
        kr = function () {
            var t = Or()
            return (t && t.activationStart) || 0
        },
        $r = function (t, s) {
            var i = Or(),
                e = "navigate"
            return (
                Cr >= 0
                    ? (e = "back-forward-cache")
                    : i &&
                      (document.prerendering || kr() > 0
                          ? (e = "prerender")
                          : document.wasDiscarded
                          ? (e = "restore")
                          : i.type && (e = i.type.replace(/_/g, "-"))),
                {
                    name: t,
                    value: void 0 === s ? -1 : s,
                    rating: "good",
                    delta: 0,
                    entries: [],
                    id: "v3-"
                        .concat(Date.now(), "-")
                        .concat(
                            Math.floor(8999999999999 * Math.random()) + 1e12
                        ),
                    navigationType: e,
                }
            )
        },
        Lr = function (t, s, i) {
            try {
                if (PerformanceObserver.supportedEntryTypes.includes(t)) {
                    var e = new PerformanceObserver(function (t) {
                        Promise.resolve().then(function () {
                            s(t.getEntries())
                        })
                    })
                    return (
                        e.observe(
                            Object.assign({ type: t, buffered: !0 }, i || {})
                        ),
                        e
                    )
                }
            } catch (t) {}
        },
        xr = function (t, s, i, e) {
            var n, r
            return function (h) {
                s.value >= 0 &&
                    (h || e) &&
                    ((r = s.value - (n || 0)) || void 0 === n) &&
                    ((n = s.value),
                    (s.delta = r),
                    (s.rating = (function (t, s) {
                        return t > s[1]
                            ? "poor"
                            : t > s[0]
                            ? "needs-improvement"
                            : "good"
                    })(s.value, i)),
                    t(s))
            }
        },
        Mr = function (t) {
            requestAnimationFrame(function () {
                return requestAnimationFrame(function () {
                    return t()
                })
            })
        },
        Dr = function (t) {
            var s = function (s) {
                ;("pagehide" !== s.type &&
                    "hidden" !== document.visibilityState) ||
                    t(s)
            }
            addEventListener("visibilitychange", s, !0),
                addEventListener("pagehide", s, !0)
        },
        Ur = function (t) {
            var s = !1
            return function (i) {
                s || (t(i), (s = !0))
            }
        },
        zr = -1,
        Fr = function () {
            return "hidden" !== document.visibilityState ||
                document.prerendering
                ? 1 / 0
                : 0
        },
        Br = function (t) {
            "hidden" === document.visibilityState &&
                zr > -1 &&
                ((zr = "visibilitychange" === t.type ? t.timeStamp : 0), qr())
        },
        Hr = function () {
            addEventListener("visibilitychange", Br, !0),
                addEventListener("prerenderingchange", Br, !0)
        },
        qr = function () {
            removeEventListener("visibilitychange", Br, !0),
                removeEventListener("prerenderingchange", Br, !0)
        },
        jr = function () {
            return (
                zr < 0 &&
                    ((zr = Fr()),
                    Hr(),
                    Nr(function () {
                        setTimeout(function () {
                            ;(zr = Fr()), Hr()
                        }, 0)
                    })),
                {
                    get firstHiddenTime() {
                        return zr
                    },
                }
            )
        },
        Gr = function (t) {
            document.prerendering
                ? addEventListener(
                      "prerenderingchange",
                      function () {
                          return t()
                      },
                      !0
                  )
                : t()
        },
        Zr = [1800, 3e3],
        Wr = function (t, s) {
            ;(s = s || {}),
                Gr(function () {
                    var i,
                        e = jr(),
                        n = $r("FCP"),
                        r = Lr("paint", function (t) {
                            t.forEach(function (t) {
                                "first-contentful-paint" === t.name &&
                                    (r.disconnect(),
                                    t.startTime < e.firstHiddenTime &&
                                        ((n.value = Math.max(
                                            t.startTime - kr(),
                                            0
                                        )),
                                        n.entries.push(t),
                                        i(!0)))
                            })
                        })
                    r &&
                        ((i = xr(t, n, Zr, s.reportAllChanges)),
                        Nr(function (e) {
                            ;(n = $r("FCP")),
                                (i = xr(t, n, Zr, s.reportAllChanges)),
                                Mr(function () {
                                    ;(n.value =
                                        performance.now() - e.timeStamp),
                                        i(!0)
                                })
                        }))
                })
        },
        Kr = [0.1, 0.25],
        Yr = { passive: !0, capture: !0 },
        Qr = new Date(),
        Jr = function (t, s) {
            Tr ||
                ((Tr = s),
                (Ir = t),
                (Pr = new Date()),
                sh(removeEventListener),
                Xr())
        },
        Xr = function () {
            if (Ir >= 0 && Ir < Pr - Qr) {
                var t = {
                    entryType: "first-input",
                    name: Tr.type,
                    target: Tr.target,
                    cancelable: Tr.cancelable,
                    startTime: Tr.timeStamp,
                    processingStart: Tr.timeStamp + Ir,
                }
                br.forEach(function (s) {
                    s(t)
                }),
                    (br = [])
            }
        },
        th = function (t) {
            if (t.cancelable) {
                var s =
                    (t.timeStamp > 1e12 ? new Date() : performance.now()) -
                    t.timeStamp
                "pointerdown" == t.type
                    ? (function (t, s) {
                          var i = function () {
                                  Jr(t, s), n()
                              },
                              e = function () {
                                  n()
                              },
                              n = function () {
                                  removeEventListener("pointerup", i, Yr),
                                      removeEventListener(
                                          "pointercancel",
                                          e,
                                          Yr
                                      )
                              }
                          addEventListener("pointerup", i, Yr),
                              addEventListener("pointercancel", e, Yr)
                      })(s, t)
                    : Jr(s, t)
            }
        },
        sh = function (t) {
            ;["mousedown", "keydown", "touchstart", "pointerdown"].forEach(
                function (s) {
                    return t(s, th, Yr)
                }
            )
        },
        ih = [100, 300],
        eh = 0,
        nh = 1 / 0,
        rh = 0,
        hh = function (t) {
            t.forEach(function (t) {
                t.interactionId &&
                    ((nh = Math.min(nh, t.interactionId)),
                    (rh = Math.max(rh, t.interactionId)),
                    (eh = rh ? (rh - nh) / 7 + 1 : 0))
            })
        },
        oh = function () {
            return Vr ? eh : performance.interactionCount || 0
        },
        ch = function () {
            "interactionCount" in performance ||
                Vr ||
                (Vr = Lr("event", hh, {
                    type: "event",
                    buffered: !0,
                    durationThreshold: 0,
                }))
        },
        ah = [200, 500],
        uh = 0,
        lh = function () {
            return oh() - uh
        },
        dh = [],
        fh = {},
        wh = function (t) {
            var s = dh[dh.length - 1],
                i = fh[t.interactionId]
            if (i || dh.length < 10 || t.duration > s.latency) {
                if (i)
                    i.entries.push(t),
                        (i.latency = Math.max(i.latency, t.duration))
                else {
                    var e = {
                        id: t.interactionId,
                        latency: t.duration,
                        entries: [t],
                    }
                    ;(fh[e.id] = e), dh.push(e)
                }
                dh.sort(function (t, s) {
                    return s.latency - t.latency
                }),
                    dh.splice(10).forEach(function (t) {
                        delete fh[t.id]
                    })
            }
        },
        ph = [2500, 4e3],
        mh = {},
        Eh = [800, 1800],
        yh = function t(s) {
            document.prerendering
                ? Gr(function () {
                      return t(s)
                  })
                : "complete" !== document.readyState
                ? addEventListener(
                      "load",
                      function () {
                          return t(s)
                      },
                      !0
                  )
                : setTimeout(s, 0)
        },
        Ah = function (t, s) {
            s = s || {}
            var i = $r("TTFB"),
                e = xr(t, i, Eh, s.reportAllChanges)
            yh(function () {
                var n = Or()
                if (n) {
                    var r = n.responseStart
                    if (r <= 0 || r > performance.now()) return
                    ;(i.value = Math.max(r - kr(), 0)),
                        (i.entries = [n]),
                        e(!0),
                        Nr(function () {
                            ;(i = $r("TTFB", 0)),
                                (e = xr(t, i, Eh, s.reportAllChanges))(!0)
                        })
                }
            })
        }
    class gh {
        onFCP(t) {
            Wr(t, { reportAllChanges: !0 })
        }
        onCLS(t) {
            !(function (t, s) {
                ;(s = s || {}),
                    Wr(
                        Ur(function () {
                            var i,
                                e = $r("CLS", 0),
                                n = 0,
                                r = [],
                                h = function (t) {
                                    t.forEach(function (t) {
                                        if (!t.hadRecentInput) {
                                            var s = r[0],
                                                i = r[r.length - 1]
                                            n &&
                                            t.startTime - i.startTime < 1e3 &&
                                            t.startTime - s.startTime < 5e3
                                                ? ((n += t.value), r.push(t))
                                                : ((n = t.value), (r = [t]))
                                        }
                                    }),
                                        n > e.value &&
                                            ((e.value = n),
                                            (e.entries = r),
                                            i())
                                },
                                o = Lr("layout-shift", h)
                            o &&
                                ((i = xr(t, e, Kr, s.reportAllChanges)),
                                Dr(function () {
                                    h(o.takeRecords()), i(!0)
                                }),
                                Nr(function () {
                                    ;(n = 0),
                                        (e = $r("CLS", 0)),
                                        (i = xr(t, e, Kr, s.reportAllChanges)),
                                        Mr(function () {
                                            return i()
                                        })
                                }),
                                setTimeout(i, 0))
                        })
                    )
            })(t, { reportAllChanges: !0 })
        }
        onFID(t) {
            !(function (t, s) {
                ;(s = s || {}),
                    Gr(function () {
                        var i,
                            e = jr(),
                            n = $r("FID"),
                            r = function (t) {
                                t.startTime < e.firstHiddenTime &&
                                    ((n.value =
                                        t.processingStart - t.startTime),
                                    n.entries.push(t),
                                    i(!0))
                            },
                            h = function (t) {
                                t.forEach(r)
                            },
                            o = Lr("first-input", h)
                        ;(i = xr(t, n, ih, s.reportAllChanges)),
                            o &&
                                Dr(
                                    Ur(function () {
                                        h(o.takeRecords()), o.disconnect()
                                    })
                                ),
                            o &&
                                Nr(function () {
                                    var e
                                    ;(n = $r("FID")),
                                        (i = xr(t, n, ih, s.reportAllChanges)),
                                        (br = []),
                                        (Ir = -1),
                                        (Tr = null),
                                        sh(addEventListener),
                                        (e = r),
                                        br.push(e),
                                        Xr()
                                })
                    })
            })(t, { reportAllChanges: !0 })
        }
        onLCP(t) {
            !(function (t, s) {
                ;(s = s || {}),
                    Gr(function () {
                        var i,
                            e = jr(),
                            n = $r("LCP"),
                            r = function (t) {
                                var s = t[t.length - 1]
                                s &&
                                    s.startTime < e.firstHiddenTime &&
                                    ((n.value = Math.max(
                                        s.startTime - kr(),
                                        0
                                    )),
                                    (n.entries = [s]),
                                    i())
                            },
                            h = Lr("largest-contentful-paint", r)
                        if (h) {
                            i = xr(t, n, ph, s.reportAllChanges)
                            var o = Ur(function () {
                                mh[n.id] ||
                                    (r(h.takeRecords()),
                                    h.disconnect(),
                                    (mh[n.id] = !0),
                                    i(!0))
                            })
                            ;["keydown", "click"].forEach(function (t) {
                                addEventListener(
                                    t,
                                    function () {
                                        return setTimeout(o, 0)
                                    },
                                    !0
                                )
                            }),
                                Dr(o),
                                Nr(function (e) {
                                    ;(n = $r("LCP")),
                                        (i = xr(t, n, ph, s.reportAllChanges)),
                                        Mr(function () {
                                            ;(n.value =
                                                performance.now() -
                                                e.timeStamp),
                                                (mh[n.id] = !0),
                                                i(!0)
                                        })
                                })
                        }
                    })
            })(t, { reportAllChanges: !0 })
        }
        onTTFB(t) {
            Ah(t, { reportAllChanges: !0 })
        }
        onINP(t) {
            !(function (t, s) {
                ;(s = s || {}),
                    Gr(function () {
                        var i
                        ch()
                        var e,
                            n = $r("INP"),
                            r = function (t) {
                                t.forEach(function (t) {
                                    t.interactionId && wh(t),
                                        "first-input" === t.entryType &&
                                            !dh.some(function (s) {
                                                return s.entries.some(function (
                                                    s
                                                ) {
                                                    return (
                                                        t.duration ===
                                                            s.duration &&
                                                        t.startTime ===
                                                            s.startTime
                                                    )
                                                })
                                            }) &&
                                            wh(t)
                                })
                                var s,
                                    i =
                                        ((s = Math.min(
                                            dh.length - 1,
                                            Math.floor(lh() / 50)
                                        )),
                                        dh[s])
                                i &&
                                    i.latency !== n.value &&
                                    ((n.value = i.latency),
                                    (n.entries = i.entries),
                                    e())
                            },
                            h = Lr("event", r, {
                                durationThreshold:
                                    null !== (i = s.durationThreshold) &&
                                    void 0 !== i
                                        ? i
                                        : 40,
                            })
                        ;(e = xr(t, n, ah, s.reportAllChanges)),
                            h &&
                                ("PerformanceEventTiming" in window &&
                                    "interactionId" in
                                        PerformanceEventTiming.prototype &&
                                    h.observe({
                                        type: "first-input",
                                        buffered: !0,
                                    }),
                                Dr(function () {
                                    r(h.takeRecords()),
                                        n.value < 0 &&
                                            lh() > 0 &&
                                            ((n.value = 0), (n.entries = [])),
                                        e(!0)
                                }),
                                Nr(function () {
                                    ;(dh = []),
                                        (uh = oh()),
                                        (n = $r("INP")),
                                        (e = xr(t, n, ah, s.reportAllChanges))
                                }))
                    })
            })(t, { reportAllChanges: !0 })
        }
    }
    class vh {
        constructor(t = []) {
            this.Ws = t
        }
        stringifyEvents() {
            return csJSON.stringify(this.Ws)
        }
        addEvent(t) {
            csArray.prototype.push.call(this.Ws, t)
        }
        eventsCount() {
            return this.Ws.length
        }
        clearEvents() {
            this.Ws = []
        }
        empty() {
            this.clearEvents()
        }
        isFull() {
            return this.eventsCount() >= 50
        }
        isEmpty() {
            return 0 === this.Ws.length
        }
        getEvents() {
            return this.Ws
        }
    }
    const _h = "v2/events",
        Rh = ["submit"]
    class Sh {
        constructor(t, s, i, e, n, r, h, o, c, a) {
            ;(this.$ = t),
                (this.Bo = s),
                (this.Z = i),
                (this.Uu = e),
                (this.iu = n),
                (this.Wc = r),
                (this.Yi = h),
                (this.Or = o),
                (this.Ca = c),
                (this.Jc = a)
        }
        init() {
            const t = new vh(),
                s = this.Jc.create(
                    `${this.$.getTrackerUri()}/${_h}`,
                    !0,
                    "base64"
                )
            ;(this.cl = this.al(s)),
                (this.ul = this.ll(t, this.cl.getRecoveryStorage(), s)),
                this.ul.init(),
                this.Ca.addListener(this.ul),
                this.Wc.register(Rh, (t, s) => {
                    this.ul.pushSubmitEvent(t, s)
                })
        }
        onStartTracking(t) {
            this.cl.start(), this.ul.start(t)
        }
        onAfterNaturalPageView() {
            this.ul.initStates()
        }
        onAfterArtificialPageView() {
            this.ul.initStates(), this.ul.collectInitialEvents()
        }
        onArtificialPageViewEnd() {
            this.ul.clearStates(!0)
        }
        onBeforeSessionRenewal() {
            this.ul.clearStates(), this.ul.stop(), this.cl.stop()
        }
        onOptout() {
            this.ul.stop(), this.cl.stop()
        }
        ll(t, s, i) {
            const e = new or(window),
                n = new gr(),
                r = new Ar(this.$, this.Uu, this.iu),
                h = new pr(this.$, this.Uu, this.Or),
                o = new Sr(new gh()),
                c = new fi()
            const a = new Ve(`${this.$.getTrackerUri()}/${_h}`),
                u = new le(this.Bo, this.Z)
            return new vr(
                this.$,
                r,
                h,
                n,
                e,
                t,
                a,
                u,
                this.Yi,
                s,
                this.Uu,
                o,
                c,
                i,
                undefined,
                undefined,
                undefined,
                undefined,
                undefined,
                undefined,
                undefined
            )
        }
        al(t) {
            return new _r(new Rr("csAnalysisEventsPersisted"), t)
        }
    }
    var Th
    !(function (t) {
        ;(t.Artificial = "a"), (t.Renewal = "r"), (t.Natural = "n")
    })(Th || (Th = {}))
    class Ih extends si {
        constructor(t, s, i, e) {
            super(), (this.Ls = t), (this.dl = s), (this.X = i), (this.da = e)
        }
        init() {
            this.wl()
        }
        onStart(t) {
            t ? this.pl() : this.ml()
        }
        onStop() {}
        triggerArtificialPageView(t) {
            this.isStarted ? this.El(t) : this.X.overridePath(t)
        }
        ml() {
            this.da.setPageViewType(Th.Natural),
                this.Ls.emitBeforeNaturalPageView(),
                this.dl.send(),
                this.Ls.emitAfterNaturalPageView()
        }
        pl() {
            this.da.setPageViewType(Th.Renewal),
                this.Ls.emitBeforeNaturalPageView(),
                this.dl.send(),
                this.Ls.emitAfterNaturalPageView()
        }
        El(t) {
            this.da.setPageViewType(Th.Artificial),
                this.Ls.emitArtificialPageViewEnd(),
                t && this.X.overridePath(t),
                this.Ls.emitBeforeArtificialPageView(),
                this.dl.send(),
                this.Ls.emitAfterArtificialPageView()
        }
        wl() {
            window.addEventListener("pageshow", (t) => {
                this.isStarted && t.persisted && this.El()
            })
        }
    }
    const Ph =
        window.navigator.language ||
        window.navigator.userLanguage ||
        window.navigator.browserLanguage ||
        window.navigator.systemLanguage ||
        "unknown"
    function bh() {
        return { la: Ph }
    }
    class Vh {
        constructor(t) {
            ;(this.Xc = t), (this.yl = []), (this.Al = !1)
        }
        getRequestParameters() {
            return { dr: this.gl() }
        }
        addUrlMaskingPattern(t) {
            const s = this.Xc.getUrlMaskingPattern(t)
            csArray.prototype.push.call(this.yl, s)
        }
        enableRemoveQueryString() {
            this.Al = !0
        }
        disableRemoveQueryString() {
            this.Al = !1
        }
        gl() {
            const t = this.Al ? this.Xc.removeQueryString(this.vl()) : this.vl()
            return this.Xc.anonymizeUrl(t, this.yl)
        }
        vl() {
            let t = ""
            try {
                t = window.top.document.referrer
            } catch (s) {
                if (window.parent)
                    try {
                        t = window.parent.document.referrer
                    } catch {
                        t = ""
                    }
            }
            return (
                "" === t && (t = document.referrer),
                "string" != typeof t && (t = ""),
                t
            )
        }
    }
    class Ch {
        constructor(t) {
            ;(this.W = t), (this._l = this.Rl() && "currentScript" in document)
        }
        Sl() {
            const t = document.currentScript
            if (!t) return null
            const s = window.performance.getEntriesByName(t.src, "resource")[0]
            return !s || this.Tl(s)
                ? null
                : Math.round(s.responseEnd - s.fetchStart)
        }
        Tl(t) {
            const s = t.transferSize
            return void 0 !== s
                ? 0 === s || s < t.encodedBodySize
                : t.connectStart === t.domainLookupEnd
        }
        getRequestParameters() {
            if (!this._l || 1 !== this.wa()) return {}
            const t = this.Sl()
            return null === t ? {} : { dt: `${Math.min(t, 99999)}` }
        }
        wa() {
            var t
            return (
                (null === (t = this.W.getSession()) || void 0 === t
                    ? void 0
                    : t.pageNumber) || null
            )
        }
        Rl() {
            return (
                "object" == typeof window.performance &&
                "function" == typeof window.performance.getEntriesByName
            )
        }
    }
    const Nh = ["trackPageview"],
        Oh = ["setPath"],
        kh = ["setQuery"],
        $h = ["referrer:maskUrl"],
        Lh = ["referrer:removeQueryString"],
        xh = ["referrer:keepQueryString"]
    class Mh {
        constructor(t, s, i, e, n, r, h, o, c, a, u, l) {
            ;(this.$ = t),
                (this.Wc = s),
                (this.Ls = i),
                (this.jo = e),
                (this.Z = n),
                (this.W = r),
                (this.Hh = h),
                (this.rs = o),
                (this.Xc = c),
                (this.X = a),
                (this.Qc = u),
                (this.da = l)
        }
        init() {
            const t = new nt(this.$.getTrackerUri(), "pageview")
            this.Il = new Ih(this.Ls, t, this.X, this.da)
            const i = new Vh(this.Xc)
            this.Il.init()
            const e = new le(
                this.jo,
                this.Z,
                Vi,
                i,
                this.X,
                this.Hh,
                s,
                this.rs,
                this.da,
                new Ch(this.W),
                this.Qc
            )
            t.setRequestParametersProviders(e),
                this.Wc.register(Nh, (t) =>
                    this.Il.triggerArtificialPageView(t)
                ),
                this.Wc.register(Oh, (t) => this.X.overridePath(t)),
                this.Wc.register(kh, (t) => this.X.overrideQuery(t)),
                this.Wc.register($h, (t) => i.addUrlMaskingPattern(t)),
                this.Wc.register(Lh, () => i.enableRemoveQueryString()),
                this.Wc.register(xh, () => i.disableRemoveQueryString())
        }
        start(t) {
            this.Il.start(t)
        }
        onBeforeSessionRenewal() {
            this.Il.stop()
        }
    }
    class Dh {
        constructor(t) {
            this.Wa = t
        }
        on(t, s) {
            return (i) => {
                this.Wa.hasValidEventTarget(i) && this.Pl(i, t) && s(i)
            }
        }
        Pl(t, s) {
            const i = Ls(t)
            return N.call(i, s)
        }
        isMatchesSelectorSupported() {
            return !!N
        }
    }
    class Uh {
        constructor() {}
        onLoad(t) {
            this.Yt = t
        }
        onLoadCallbackExecute() {
            this.Yt()
        }
        start() {
            const t = this.onLoadCallbackExecute.bind(this)
            this.bl(t)
        }
        bl(t) {
            function s() {
                document.removeEventListener("DOMContentLoaded", s),
                    window.removeEventListener("load", s),
                    t()
            }
            "complete" === document.readyState ||
            ("loading" !== document.readyState &&
                !document.documentElement.doScroll)
                ? setTimeout(t)
                : (document.addEventListener("DOMContentLoaded", s),
                  window.addEventListener("load", s))
        }
    }
    ss([ts("onLoad")], Uh.prototype, "onLoadCallbackExecute", null)
    class zh {
        constructor(t, s, i) {
            ;(this.$ = t), (this.Z = s), (this.W = i), (this.el = pt.now())
        }
        resetStartTime() {
            this.el = pt.now()
        }
        getSessionData() {
            const { projectId: t } = this.$,
                s = this.Z.getVisitor()
            null == s &&
                Jt.warn(
                    "Visitor is null. This happens when a snippet tries to get Session Data before the tag was initialized."
                )
            const { id: i, visitsCount: e } = null != s ? s : {},
                n = this.W.getSession()
            null === n &&
                Jt.warn(
                    "Session is null. This happens when a snippet tries to get Session Data before the tag was initialized."
                )
            const { pageNumber: r } = null != n ? n : {}
            return {
                projectId: t,
                userId: i,
                sessionNumber: e,
                pageNumber: r,
                relativeTimestamp: pt.now() - this.el,
            }
        }
    }
    const Fh = ["clearSession"],
        Bh = ["extendSession"],
        Hh = ["getSessionData"],
        qh = ["session:start:newVisitor"],
        jh = ["session:clear:visitor"]
    class Gh {
        constructor(t, s, i, e) {
            ;(this.$ = t), (this.Z = s), (this.W = i), (this.Wc = e)
        }
        init() {
            ;(this.Vl = new zh(this.$, this.Z, this.W)),
                this.Wc.register(Fh, () => this.W.removeSession()),
                this.Wc.register(Bh, () => this.W.extendSessionPeriodically(), {
                    disableApplyPending: !0,
                }),
                this.Wc.register(Hh, () => this.Vl.getSessionData(), {
                    disableApplyPending: !0,
                }),
                this.Wc.register(qh, () => this.Z.renewVitor()),
                this.Wc.register(
                    jh,
                    () => {
                        this.Z.resetVisitor()
                    },
                    { disableApplyImmediate: !0 }
                )
        }
        onBeforeNaturalPageView() {
            this.Z.createOrUpdateVisitor(), this.W.createOrUpdateSession()
        }
        onBeforeArtificialPageView() {
            this.W.abortQuotaServiceRequest(),
                this.Z.createOrUpdateVisitor(),
                this.W.createOrUpdateSession()
        }
        onAfterNaturalPageView() {
            this.Vl.resetStartTime()
        }
        onAfterArtificialPageView() {
            this.Vl.resetStartTime()
        }
        onOptout() {
            this.Z.removeVisitor(), this.W.removeSession()
        }
        onRecordingStateChange(t, s) {
            this.W.updateRecordingState(t, s)
        }
    }
    class Zh {
        constructor(t, s) {
            ;(this.W = t), (this.Z = s), (this.Cl = !1)
        }
        onSessionExpired(t) {
            this.Nl = t
        }
        isSessionValid() {
            if (this.Cl) return !0
            const t = this.W.hasValidSession()
            let s = !1
            return (
                this.W.pollCacheRefreshEvent() &&
                    (s = this.Z.isSessionRenewed()),
                (t && !s) || !this.Ol()
                    ? t
                    : ((this.kl = pt.now()),
                      (this.Cl = !0),
                      this.Nl(),
                      (this.Cl = !1),
                      this.W.hasValidSession())
            )
        }
        isCurrentPageviewValid() {
            const t = this.W.hasValidSession()
            return this.W.pollCacheRefreshEvent(!1)
                ? !this.Z.isSessionRenewed()
                : t
        }
        startNewSession() {
            this.Nl()
        }
        Ol() {
            return !St(this.kl) || pt.now() - this.kl > 6e4
        }
    }
    class Wh extends si {
        constructor(t, s, i, e, n, r, h, o) {
            super(),
                (this.X = t),
                (this.$l = s),
                (this.Ae = i),
                (this.Ll = e),
                (this.xl = n),
                (this.Ml = r),
                (this.Dl = h),
                (this.Ul = o)
        }
        init() {
            this.zl(), this.Yu(), this.Fl(), this.Bl()
        }
        collectInitialProducts() {
            this.$l.collectProductsAndAnchors(
                document,
                ({ products: t, anchors: s }) => {
                    this.Hl(s), this.Ll.send(this.ql(t))
                }
            )
        }
        startDisplayAdExposureTracking() {
            var t
            null === (t = this.Ul) || void 0 === t || t.restart()
        }
        Hl(t) {
            csArray.prototype.forEach.call(t, (t) => {
                this.Dl.pushProduct(t)
            })
        }
        onIframeEmerchandisingMessage(t) {
            this.Ll.send(t)
        }
        clearState() {
            var t, s
            this.Ml.clearState(),
                null === (t = this.Ul) || void 0 === t || t.cancleTimers(),
                null === (s = this.Ul) || void 0 === s || s.clearState(),
                this.$l.flushEvents(),
                this.xl.isEmpty() || this.jl(!1),
                this.Ll.clearState()
        }
        initStates() {
            this.Ll.initStates()
        }
        onStart() {
            var t
            this.Ae.start(),
                this.$l.start(),
                this.Ml.start(),
                null === (t = this.Ul) || void 0 === t || t.start()
        }
        onStop() {
            var t
            this.Ae.stop(),
                this.$l.stop(),
                this.Ml.stop(),
                null === (t = this.Ul) || void 0 === t || t.stop()
        }
        Fl() {
            this.Ml.onProductExposed((t) => {
                this.xl.addProductExposure(t), this.xl.isFull() && this.jl(!1)
            })
        }
        ql(t, s = [], i = []) {
            const e = {
                products: t,
                targetUrl: this.X.getAnonymizedUrl(),
                windowWidth: Vi.windowWidth(),
                windowHeight: Vi.windowHeight(),
            }
            return (
                s.length > 0 && (e.exposures = s),
                i.length > 0 && (e.contentExposures = i),
                e
            )
        }
        zl() {
            this.$l.init(),
                this.$l.onProductsDetection(({ products: t, anchors: s }) => {
                    this.xl.addProducts(t),
                        this.xl.isFull() && this.jl(!1),
                        this.Hl(s)
                })
        }
        Yu() {
            this.Ae.onEvent((t) => {
                var s
                this.Ml.clearState(),
                    null === (s = this.Ul) || void 0 === s || s.cancleTimers(),
                    this.Gl()
            })
        }
        Gl() {
            this.xl.isEmpty() || this.jl(!0)
        }
        jl(t) {
            const s = this.ql(
                this.xl.getProducts(),
                this.xl.getProductsExposure(),
                this.xl.getExposedContentItems()
            )
            t ? this.Ll.sendBeacon(s) : this.Ll.send(s)
        }
        Bl() {
            this.Ul &&
                (this.Ul.init(),
                this.Ul.onDisplayAdExposed((t) => {
                    this.xl.addExposedContentItems(t),
                        this.xl.isFull() && this.jl(!1)
                }))
        }
    }
    class Kh {
        constructor(t, s = 30, i = 0) {
            ;(this.Zl = t),
                (this.Wl = s),
                (this.Kl = i),
                (this.Yl = new oi()),
                (this.Y = !1),
                (this.Ql = 0),
                (this.Jl = () => {
                    for (this.Ql = 0; this.Yl.length; ) {
                        if (this.Ql >= this.Wl)
                            return void setTimeout(this.Jl, this.Kl)
                        const t = pt.now(),
                            s = this.Yl.pop()
                        if (!s) break
                        this.runTask(s)
                        const i = pt.now() - t
                        this.Ql += i
                    }
                    this.Y = !1
                })
        }
        schedule(t, s = !1) {
            this.Zl && !s ? (this.Yl.push(t), this.Xl()) : t()
        }
        Xl() {
            this.Y ||
                ((this.Y = !0),
                setTimeout(() => {
                    this.Jl()
                }))
        }
        runTask(t) {
            t()
        }
        runPendingTasks() {
            this.Yl.forEach((t) => {
                this.runTask(t)
            }),
                this.Yl.clear()
        }
        clearQueue() {
            this.Yl.clear()
        }
        isEmpty() {
            return 0 === this.Yl.length
        }
    }
    ss([ts("TaskScheduler"), $s("runTask")], Kh.prototype, "runTask", null),
        ss([$s("runPendingTasks")], Kh.prototype, "runPendingTasks", null)
    class Yh {
        constructor(t, s) {
            ;(this.configuration = t),
                (this.projectPathComputation = s),
                (this.hr = new Kh(!0))
        }
        collectProductsAndAnchors(t = document, s) {
            this.hr.schedule(() => {
                const i = []
                this.getAllValidAnchors(
                    this.configuration.hostnames,
                    t,
                    (t) => {
                        for (const s of t)
                            csArray.prototype.push.call(
                                i,
                                this.buildProductFromAnchor(s)
                            )
                        s({ products: i, anchors: t })
                    }
                )
            })
        }
        getAllValidAnchors(t, s = document, i) {
            const e = [],
                n = new IntersectionObserver((s) => {
                    csArray.prototype.forEach.call(s, (s) => {
                        const i = s.target
                        ;("https:" === i.protocol || "http:" === i.protocol) &&
                            "" !== i.hostname &&
                            Math.round(s.boundingClientRect.height) > 0 &&
                            Math.round(s.boundingClientRect.width) > 0 &&
                            Ft(i.hostname, t) &&
                            csArray.prototype.push.call(e, i)
                    }),
                        i(e),
                        n.disconnect()
                }),
                r = Oi.findAllElements("a", s)
            csArray.prototype.forEach.call(r, (t) => {
                n.observe(t)
            })
        }
        isAnchorValid(t, s) {
            return (
                ("https:" === t.protocol || "http:" === t.protocol) &&
                t.offsetHeight > 0 &&
                t.offsetWidth > 0 &&
                "" !== t.hostname &&
                Ft(t.hostname, s)
            )
        }
        buildProductFromAnchor(t) {
            return {
                targetPath: this.projectPathComputation.getElementPath(t),
                href: t.href,
            }
        }
    }
    ss([$s("getAllValidAnchors")], Yh.prototype, "getAllValidAnchors", null)
    class Qh extends Yh {
        constructor(t, s, i) {
            super(t, s),
                (this.ks = i),
                (this.td = { subtree: !0, childList: !0 })
        }
        init() {
            this.ur()
        }
        start() {
            this.ks.start(), this.sd()
        }
        stop() {
            this.ks.stop()
        }
        flushEvents() {
            this.ks.flushPendingMutations()
        }
        onProductsDetection(t) {
            this.nd = t
        }
        ur() {
            this.ks.init(), this.rd()
        }
        rd() {
            this.ks.onChildListMutation((t) => this.od(t)),
                this.ks.onAttachShadowMutation((t) => this.ad(t))
        }
        od(t) {
            for (let s = 0; s < t.addedNodes.length; s += 1) {
                const i = t.addedNodes[s]
                if (
                    w(i) &&
                    this.isAnchorValid(i, this.configuration.hostnames)
                ) {
                    const t = this.buildProductFromAnchor(i)
                    this.ud({ products: [t], anchors: [i] })
                } else
                    Pt(i) &&
                        this.collectProductsAndAnchors(i, (t) => {
                            this.ud(t)
                        })
            }
        }
        ad(t) {
            const { shadowRoot: s } = t
            this.collectProductsAndAnchors(s, (t) => {
                this.ud(t)
            }),
                this.ks.observe(s, this.td)
        }
        ud(t) {
            t.products.length > 0 && this.nd(t)
        }
        sd() {
            this.ks.observe(document, this.td), this.Ni(document)
        }
        Ni(t) {
            const s = bi.getAllShadowHosts(t)
            csArray.prototype.forEach.call(s, (t) => {
                csElementshadowRoot.apply(t) &&
                    this.ks.observe(csElementshadowRoot.apply(t), this.td)
            })
        }
    }
    class Jh {
        constructor(t = Jh.ld) {
            ;(this.dd = []),
                (this.wd = []),
                (this.pd = []),
                (this.md = new Qs(t))
        }
        addProducts(t) {
            this.md.addString(csJSON.stringify(t)),
                csArray.prototype.push.call(this.dd, ...t)
        }
        addProductExposure(t) {
            this.md.addString(csJSON.stringify(t)),
                csArray.prototype.push.call(this.wd, t)
        }
        addExposedContentItems(t) {
            this.md.addString(csJSON.stringify(t)),
                csArray.prototype.push.call(this.pd, ...t)
        }
        reset() {
            this.md.reset(), (this.dd = []), (this.wd = []), (this.pd = [])
        }
        isEmpty() {
            return (
                0 === this.dd.length &&
                0 === this.wd.length &&
                0 === this.pd.length
            )
        }
        isFull() {
            return this.md.isThresholdReached()
        }
        getProducts() {
            return this.dd
        }
        getProductsExposure() {
            return this.wd
        }
        getExposedContentItems() {
            return this.pd
        }
    }
    Jh.ld = 10240
    class Xh {
        static create(t, s) {
            if (!Xh.isSupported())
                throw new Error("IntersectionObserver is not supported")
            if (s && s.delay && s.delay < 100)
                throw new Error("Visibility delay should be > 100ms")
            return (
                (null == s ? void 0 : s.trackVisibility) && (t = Xh.Ed(t)),
                new IntersectionObserver(t, s)
            )
        }
        static isSupported() {
            return (
                !!window.IntersectionObserver &&
                !!window.IntersectionObserverEntry
            )
        }
        static Ed(t) {
            return (s, i) =>
                t(
                    (function (t, s) {
                        const i = t.length,
                            e = new csArray(i)
                        for (let n = 0; n < i; n += 1) e[n] = s(t[n])
                        return e
                    })(s, to),
                    i
                )
        }
    }
    function to(t) {
        return t.isVisible || !Oi.isVisibleInViewportInForeground(t.target)
            ? t
            : {
                  boundingClientRect: t.boundingClientRect,
                  intersectionRatio: t.intersectionRatio,
                  intersectionRect: t.intersectionRect,
                  isIntersecting: t.isIntersecting,
                  rootBounds: t.rootBounds,
                  target: t.target,
                  time: t.time,
                  isVisible: !0,
              }
    }
    class so {
        constructor(t) {
            ;(this.ii = t), (this.yd = []), (this.Ad = new Set())
        }
        observe(t, s) {
            if (!t.getRootNode()) throw new Error("Node has no root node")
            if (this.Ad.has(t)) return
            this.Ad.add(t)
            const i = !!(null == s ? void 0 : s.subtree),
                e = () => this.ii(t),
                n = t.parentElement || t.getRootNode(),
                r = Oi.getAncestors(t, i),
                h = new Set(r),
                o = new csMutationObserver((s) => {
                    setTimeout(() => {
                        for (const i of s)
                            if (
                                h.has(i.target) &&
                                qs(i.removedNodes, (t) => h.has(t))
                            )
                                return (
                                    e(), o.disconnect(), void this.Ad.delete(t)
                                )
                    })
                })
            if (i)
                for (const t of r) {
                    csArray.prototype.includes.call([11, 9], t.nodeType) &&
                        o.observe(t, { childList: !0, subtree: !0 })
                }
            else o.observe(n, { childList: !0 })
            csArray.prototype.push.call(this.yd, () => {
                o.disconnect()
            })
        }
        disconnect() {
            Hs(this.yd, (t) => t()), (this.yd = []), this.Ad.clear()
        }
    }
    class io {
        constructor(t) {
            ;(this.gd = new Set()),
                (this.vd = new so((t) => this._d(t))),
                (this.Ms = !1),
                (this.Ka = t ? { ...no, ...t } : no)
        }
        stop() {
            ;(this.Ms = !1), this.Rd.disconnect(), this.ks.disconnect()
        }
        start(t) {
            if (this.Ms)
                throw new Error("VisibilityObserver is already started")
            this.ii = t
            const s = {
                root: null,
                rootMargin: "0px",
                threshold: 0.5,
                trackVisibility: !0,
                delay: 300,
            }
            ;(this.Rd = Xh.create((t) => this.handleIntersection(t), s)),
                (this.ks = new vi((t) =>
                    setTimeout(() => {
                        Hs(t, (t) => this._d(t.target))
                    })
                )),
                this.wo(),
                (this.Ms = !0)
        }
        observe(t) {
            if (!this.Ms) throw new Error("Observer is stopped.")
            t[this.Sd] || ((t[this.Sd] = !0), this.watchIntersection(t))
        }
        wo() {
            ;(this.Td = Ei("isVisible")),
                (this.Sd = Ei("ObservedElement")),
                (this.Id = Ei("LinkedElement")),
                (this.Pd = Ei("Tracked"))
        }
        _d(t) {
            this.gd.add(t)
            for (const s of this.bd(t)) this.gd.add(s)
            this.recheckCssVisibilityAll()
        }
        recheckCssVisibilityAll() {
            Hs(this.gd.keys(), (t) => {
                t.isConnected &&
                    !Oi.areAncestorsHiddenByCSS(t) &&
                    t[this.Sd] &&
                    this.watchIntersection(t)
            }),
                this.gd.clear()
        }
        watchIntersection(t) {
            this.ks.unobserve(t), this.Rd.unobserve(t)
            const s = Oi.getTopAncestorHiddenByCSS(t)
            s
                ? (s !== t && (this.Vd(s, t), this.watchMutation(s)),
                  this.watchMutation(t))
                : this.Rd.observe(t)
        }
        watchMutation(t, s = !0) {
            s && delete t[this.Td], this.Rd.unobserve(t)
            this.ks.observe(t, {
                attributeFilter: ["style", "class", "hidden"],
            })
        }
        handleIntersection(t) {
            for (const s of t) {
                const t = s.target
                if (!s.isVisible) {
                    switch (
                        Oi.isVisibleInDocument(t)
                            ? eo.VisibleOutsideViewPort
                            : s.isIntersecting
                            ? eo.HiddenByAnother
                            : eo.Hidden
                    ) {
                        case eo.Hidden:
                        case eo.HiddenByAnother:
                            this.Cd(t)
                            break
                        case eo.VisibleOutsideViewPort:
                            this.onVisibilityChanged(
                                s.target,
                                eo.VisibleOutsideViewPort
                            )
                    }
                    continue
                }
                const i = null === s.target[this.Td]
                ;(s.target[this.Td] = !0),
                    i &&
                        !this.Ka.delay &&
                        this.onVisibilityChanged(s.target, eo.VisibleInViewPort)
            }
            this.Ka.delay &&
                setTimeout(() => {
                    for (const s of t) {
                        const t = s.isIntersecting && s.isVisible
                        s.target[this.Td] &&
                            t &&
                            this.onVisibilityChanged(
                                s.target,
                                eo.VisibleInViewPort
                            )
                    }
                }, this.Ka.delay)
        }
        Cd(t) {
            const s = Oi.getTopElement(t)
            this.watchMutation(t),
                s &&
                    (this.vd.observe(s),
                    this.Vd(s, t),
                    this.watchMutation(s, !1))
        }
        Vd(t, s) {
            var i
            ;(t[this.Id] =
                null !== (i = t[this.Id]) && void 0 !== i ? i : new Set()).add(
                s
            )
        }
        bd(t) {
            var s, i
            const e = []
            return (
                Hs(
                    null !==
                        (i =
                            null === (s = t[this.Id]) || void 0 === s
                                ? void 0
                                : s.values()) && void 0 !== i
                        ? i
                        : [],
                    (t) => csArray.prototype.push.call(e, t)
                ),
                e
            )
        }
        onVisibilityChanged(t, s) {
            if (s === eo.VisibleInViewPort && this.Ka.trackOnce) {
                if ((this.Rd.unobserve(t), this.ks.unobserve(t), t[this.Pd]))
                    return
                t[this.Pd] = !0
            }
            this.ii(t, s)
        }
        static isSupported() {
            return Xh.isSupported()
        }
    }
    var eo
    wi([ts()], io.prototype, "observe", null),
        wi(
            [Ts({ wait: 50 }), ts()],
            io.prototype,
            "recheckCssVisibilityAll",
            null
        ),
        wi([ts()], io.prototype, "watchIntersection", null),
        wi([ts()], io.prototype, "watchMutation", null),
        wi([ts()], io.prototype, "handleIntersection", null),
        wi([ts()], io.prototype, "onVisibilityChanged", null),
        (function (t) {
            ;(t.VisibleInViewPort = "VisibleInViewPort"),
                (t.VisibleOutsideViewPort = "VisibleOutsideViewPort"),
                (t.HiddenByAnother = "HiddenByAnother"),
                (t.Hidden = "Hidden")
        })(eo || (eo = {}))
    const no = { delay: 1e3, trackOnce: !0 }
    class ro extends si {
        constructor(t, s, i, e = new io()) {
            super(), (this.Nd = t), (this.hr = s), (this.$ = i), (this.Od = e)
        }
        onProductExposed(t) {
            this.kd = t
        }
        clearState() {
            io.isSupported() && this.isStarted && this.$d()
        }
        onStart() {
            io.isSupported() && ((this.Ld = new Map()), this.xd())
        }
        onStop() {
            io.isSupported() && (this.$d(), this.Od.stop(), this.Ld.clear())
        }
        xd() {
            try {
                this.Od.start((t, s) => {
                    s === eo.VisibleInViewPort ? this.Md(t) : this.Dd(t)
                })
            } catch (t) {
                return void Jt.error(t)
            }
            this.Nd.onElementAvailable((t) =>
                this.hr.schedule(() => this.Od.observe(t))
            )
        }
        $d() {
            this.Ld.forEach((t, s) => {
                this.Dd(s)
            }),
                this.Ld.clear()
        }
        Md(t) {
            this.Ld.set(t, pt.now())
        }
        Dd(t) {
            const s = this.Ld.get(t)
            if (void 0 === s) return
            const i = pt.now() - s
            this.Ld.delete(t),
                i < ro.EXPOSURE_DURATION_THRESHOLD || this.kd(this.Ud(t, i))
        }
        Ud(t, s) {
            const { href: i } = t
            return {
                targetPath: j.getElementPath(t, {
                    dynamicIdRegex: this.$.dynamicIdRegex,
                }),
                duration: s,
                href: i,
            }
        }
    }
    ro.EXPOSURE_DURATION_THRESHOLD = 150
    class ho {
        constructor(t) {
            this.ii = t
        }
        push(t) {
            this.zd || ((this.zd = []), setTimeout(() => this.flush())),
                csArray.prototype.push.call(this.zd, t)
        }
        flush() {
            csArray.prototype.forEach.call(this.zd, this.ii), (this.zd = void 0)
        }
    }
    ss([ts("MicrotaskBuffer.flush")], ho.prototype, "flush", null)
    class oo {
        constructor() {
            this.zd = new ho((t) => t.isConnected && this.Fd && this.Fd(t))
        }
        onElementAvailable(t) {
            this.Fd = t
        }
        pushProduct(t) {
            this.zd.push(t)
        }
        *getElements(t) {}
    }
    class co {
        constructor(t, s, i, e) {
            ;(this.ie = t), (this.Bd = s), (this.xl = i), (this.Hd = e)
        }
        initStates() {
            this.qd()
        }
        clearState() {
            this.ie.removeQueryParams()
        }
        send(t) {
            this.jd(t)
        }
        sendBeacon(t) {
            this.Gd(t)
        }
        qd() {
            const t = this.Hd.getRequestParameters()
            this.ie.setQueryParams(t), this.Bd.setQueryParams(t)
        }
        jd(t) {
            this.ie.send(t), this.xl.reset()
        }
        Gd(t) {
            this.Bd.send(csJSON.stringify(t)), this.xl.reset()
        }
    }
    const ao = "display"
    class uo {
        constructor(t, s, i, e, n, r, h, o, c) {
            ;(this.$ = t),
                (this.Uu = s),
                (this.Jc = i),
                (this.Bo = e),
                (this.rs = n),
                (this.X = r),
                (this.Ca = h),
                (this.Wc = o),
                (this.hr = c)
        }
        init() {
            const t = new Pe(this.hr),
                s = new Qh(this.$, this.Uu, t),
                i = new fi(),
                e = new Jh(),
                n = new oo(),
                r = new ro(n, this.hr, this.$),
                h = new co(
                    this.Jc.create(
                        `${this.$.getTrackerUri()}/${ao}`,
                        !0,
                        "base64"
                    ),
                    new Ve(`${this.$.getTrackerUri()}/${ao}`),
                    e,
                    new le(this.Bo, this.rs)
                )
            ;(this.Zd = new Wh(this.X, s, i, h, e, r, n, this.Ul)),
                this.Zd.init(),
                this.Ca.addListener(this.Zd)
        }
        onStartTracking() {
            this.Mi() && (this.Zd.start(), this.Zd.collectInitialProducts())
        }
        onArtificialPageViewEnd() {
            this.Zd.clearState()
        }
        onAfterNaturalPageView() {
            this.Zd.initStates()
        }
        onAfterArtificialPageView() {
            this.Zd.initStates(),
                this.Zd.collectInitialProducts(),
                this.Zd.startDisplayAdExposureTracking()
        }
        onBeforeSessionRenewal() {
            this.Zd.clearState(), this.Zd.stop()
        }
        onOptout() {
            this.Zd.stop()
        }
        Mi() {
            return !!window.IntersectionObserver
        }
    }
    var lo, fo
    function wo(t) {
        return (
            t.tagDeploymentMode === lo.DualCollectionReview ||
            t.tagDeploymentMode === lo.DualCollection
        )
    }
    ss([$s("Emerch.onStartTracking")], uo.prototype, "onStartTracking", null),
        (function (t) {
            ;(t.ContentSquare = "CONTENTSQUARE"),
                (t.LoadedByClicktale = "LOADED_BY_CLICKTALE"),
                (t.LoadClicktalePtc = "LOAD_CLICKTALE_PTC"),
                (t.DualCollectionReview = "DUAL_COLLECTION_REVIEW"),
                (t.DualCollection = "DUAL_COLLECTION"),
                (t.ContentSquareTagClickTaleEndpoints =
                    "CONTENTSQUARE_TAG_CLICKTALE_ENDPOINTS")
        })(lo || (lo = {})),
        (function (t) {
            ;(t.isRecording = function () {
                return (
                    window.ClickTaleIsRecording && window.ClickTaleIsRecording()
                )
            }),
                (t.stopRecording = function () {
                    window.ClickTaleStop && window.ClickTaleStop()
                }),
                (t.triggerLogicalPageView = function (t) {
                    window.ClickTaleLogicalWithUploadPage &&
                        window.ClickTaleLogicalWithUploadPage(t)
                }),
                (t.sendPageEvent = function (t) {
                    window.ClickTaleEvent && window.ClickTaleEvent(t)
                }),
                (t.sendEventTriggerRecording = function (t) {
                    window.ClickTaleEventTrigger &&
                        window.ClickTaleEventTrigger(t)
                })
        })(fo || (fo = {}))
    const po = "@user-identifier@"
    class mo extends si {
        constructor(t, s, i, e, n) {
            super(),
                (this.$ = t),
                (this.Wd = s),
                (this.Zc = i),
                (this.Kd = e),
                (this.Yd = n),
                (this.Qd = []),
                (this.Se = [])
        }
        onStart() {
            csArray.prototype.forEach.call(this.Qd, (t) =>
                this.trackPageEvent(t)
            ),
                (this.Qd = []),
                csArray.prototype.forEach.call(this.Se, (t) =>
                    this.trackEventTriggerRecording(t)
                ),
                (this.Se = [])
        }
        onStop() {}
        trackPageEvent(t) {
            this.isStarted
                ? mo.Jd(t) &&
                  (this.Xd(t)
                      ? this.Yd.isSupported() && this.tf(t)
                      : this.sf(t))
                : csArray.prototype.push.call(this.Qd, t)
        }
        Xd(t) {
            return W(t, po)
        }
        async tf(t) {
            if (!this.$.customHashIdEnabled) return
            const s = csString.prototype.slice.call(t, 17)
            if (!this.Yd.isValidInput(s))
                return void Jt.warn(
                    "UserIdentifier event: invalid user identifier"
                )
            const i = await this.Yd.digest(s, this.$.projectId)
            i
                ? ((this.if = { eventName: i, isETR: !1, isCustomHashId: !0 }),
                  this.ef())
                : Jt.warn("Page event: unable to compute customHashId"),
                this.$.encryptionEnabled && this.Kd.emitUserIdentifierEvent(s)
        }
        sf(t) {
            this.Kd.emitPageEvent(t),
                (this.if = { eventName: t, isETR: !1, isCustomHashId: !1 }),
                this.ef(),
                this.$.tagDeploymentMode === lo.LoadClicktalePtc &&
                    fo.sendPageEvent(t)
        }
        trackEventTriggerRecording(t) {
            this.isStarted
                ? mo.Jd(t) && (this.$.malkaEtrEnabled ? this.nf(t) : this.rf(t))
                : csArray.prototype.push.call(this.Se, t)
        }
        nf(t) {
            W(t, "@ETP@")
                ? this.Kd.emitEventTriggerRecording(t, ni.ETR_PAGE)
                : this.Kd.emitEventTriggerRecording(t, ni.ETR_SESSION),
                (this.if = { eventName: t, isETR: !0, isCustomHashId: !1 }),
                this.ef()
        }
        rf(t) {
            var s
            ;(wo((s = this.$)) ||
                s.tagDeploymentMode === lo.LoadClicktalePtc) &&
                (this.Kd.emitEventTriggerRecording(t, ni.ETR_LEGACY),
                (this.if = { eventName: t, isETR: !0, isCustomHashId: !1 }),
                this.ef(),
                this.$.tagDeploymentMode === lo.LoadClicktalePtc &&
                    fo.sendEventTriggerRecording(t))
        }
        getRequestParameters() {
            return {
                value: this.Zc.compressSync(this.if.eventName, "base64"),
                ct: this.Zc.algorithm,
                isETR: `${this.if.isETR}`,
                isCustomHashId: `${this.if.isCustomHashId}`,
            }
        }
        ef() {
            this.Wd.send()
        }
        static Jd(t) {
            return _t(t) && !!csString.prototype.trim.call(t)
        }
    }
    const Eo = ["trackPageEvent"],
        yo = ["trackEventTriggerRecording"]
    class Ao {
        constructor(t, s, i, e, n) {
            ;(this.$ = t),
                (this.Wc = s),
                (this.Zc = i),
                (this.jo = e),
                (this.Kd = n)
        }
        init() {
            const t = new nt(this.$.getTrackerUri(), "pageEvent"),
                s = new ke(window.crypto)
            s.init(),
                (this.hf = new mo(this.$, t, this.Zc, this.Kd, s)),
                t.setRequestParametersProviders(this.hf, this.jo),
                this.Wc.register(Eo, (t) => {
                    this.hf.trackPageEvent(t)
                }),
                this.Wc.register(yo, (t) => {
                    this.hf.trackEventTriggerRecording(t)
                })
        }
        onStartTracking() {
            this.hf.start()
        }
    }
    const go = document.createElement("div")
    function vo(t) {
        if (!(!!t && _t(t)))
            return (
                Jt.warn(`isValidSelector: invalid selector provided '${t}'`), !1
            )
        try {
            return N.call(go, t), !0
        } catch {
            return (
                Jt.warn(`isValidSelector: invalid selector provided '${t}'`), !1
            )
        }
    }
    const _o = ["#c1_card_info_id"]
    var Ro
    !(function (t) {
        ;(t[(t.Sensitive = 1)] = "Sensitive"),
            (t[(t.SensitiveChild = 2)] = "SensitiveChild")
    })(Ro || (Ro = {}))
    class So {
        constructor(t) {
            ;(this.$ = t),
                (this.cf = ["value", "checked", "src", "data", "alt"]),
                (this.af = ["[data-cs-mask]", "script", ..._o]),
                (this.uf = [
                    {
                        selector: "input:not([type=button]):not([type=submit])",
                        attrName: "value",
                    },
                ]),
                (this.lf = {
                    PIISelectors: [
                        ".ctHidden, textarea",
                        "#c1_card_info_id",
                        ..._o,
                    ],
                    Attributes: [
                        {
                            selector:
                                ".ctHidden, input:not([type=button]):not([type=submit])",
                            attrName: "value",
                        },
                    ],
                }),
                (this.df = []),
                (this.ff = ""),
                (this.wf = () => {}),
                wo(this.$) ||
                    ((this.ff = this.pf(this.ff, this.af)),
                    csArray.prototype.push.call(this.df, ...this.uf)),
                (this.mf = this.Ef())
        }
        Ef() {
            if (window.ResizeObserver)
                return new ResizeObserver((t) => {
                    csArray.prototype.forEach.call(t, (t) => {
                        this.wf(t)
                    })
                })
        }
        setPIISelectors(t) {
            var s
            if (t) {
                if (
                    null === (s = t.PIISelectors) || void 0 === s
                        ? void 0
                        : s.length
                ) {
                    const s = csArray.prototype.filter.call(
                        t.PIISelectors,
                        (t) => vo(t)
                    )
                    this.ff = this.pf(this.ff, s)
                }
                t.Attributes instanceof Array &&
                    csArray.prototype.forEach.call(t.Attributes, (t) => {
                        t &&
                            t.attrName &&
                            vo(t.selector) &&
                            !this.yf(t) &&
                            csArray.prototype.push.call(this.df, t)
                    })
            }
        }
        getPIISelectors() {
            return { PIISelectors: [this.ff], Attributes: this.df }
        }
        initCTPII() {
            var t, s
            if (
                ((this.ff = this.pf(this.ff, this.lf.PIISelectors)),
                !(null ===
                    (s =
                        null ===
                            (t =
                                null === window || void 0 === window
                                    ? void 0
                                    : window.ClickTaleSettings) || void 0 === t
                            ? void 0
                            : t.DOM) || void 0 === s
                    ? void 0
                    : s.PII))
            )
                return
            const i = csArray.prototype.filter.call(
                window.ClickTaleSettings.DOM.PII.Text,
                (t) => vo(t)
            )
            ;(this.ff = this.pf(this.ff, i)),
                csArray.prototype.push.call(this.df, ...this.lf.Attributes),
                csArray.prototype.forEach.call(
                    window.ClickTaleSettings.DOM.PII.Attributes,
                    (t) => {
                        t.attr &&
                            vo(t.rule) &&
                            csArray.prototype.push.call(this.df, {
                                selector: t.rule,
                                attrName: t.attr,
                            })
                    }
                )
        }
        isSensitiveAttribute(t, s) {
            return (
                (this.isSensitive(t) &&
                    -1 !== csArray.prototype.indexOf.call(this.cf, s)) ||
                this.Af(t, s, this.df)
            )
        }
        isSensitive(t) {
            return t.__contentsquare_sensitive === Ro.Sensitive
        }
        isSensitiveChild(t) {
            return t.__contentsquare_sensitive === Ro.SensitiveChild
        }
        identifySensitiveNodes(t) {
            if (!u(t) && !R(t)) return
            this.gf(t)
            const s = bi.getAllShadowHosts(t)
            csArray.prototype.forEach.call(
                s,
                (t) =>
                    csElementshadowRoot.apply(t) &&
                    this.gf(csElementshadowRoot.apply(t))
            )
        }
        unidentifySensitiveNodes(t) {
            if (!u(t) && !R(t)) return
            this.vf(t)
            const s = bi.getAllShadowHosts(t)
            csArray.prototype.forEach.call(
                s,
                (t) =>
                    csElementshadowRoot.apply(t) &&
                    this.vf(csElementshadowRoot.apply(t))
            )
        }
        onSensitiveElementResize(t) {
            this.wf = t
        }
        disconnectResizeObserver() {
            var t
            null === (t = this.mf) || void 0 === t || t.disconnect()
        }
        vf(t) {
            const s = document.createNodeIterator(
                t,
                NodeFilter.SHOW_ELEMENT,
                null,
                !1
            )
            let i
            for (; (i = s.nextNode()); )
                "__contentsquare_sensitive" in i &&
                    delete i.__contentsquare_sensitive
        }
        gf(t) {
            if (this._f(t)) return this.Rf(t), void this.Sf(t)
            if (this.Tf(t, this.ff)) this.If(t), this.Sf(t)
            else {
                Hs(
                    window.csquerySelectorAll[t.nodeType].call(t, this.ff),
                    (t) => {
                        this.If(t), this.Sf(t)
                    }
                )
            }
        }
        If(t) {
            ;(t.__contentsquare_sensitive = Ro.Sensitive), this.Pf(t)
        }
        Pf(t) {
            this.mf && u(t) && !g(t) && this.mf.observe(t)
        }
        Rf(t) {
            t.__contentsquare_sensitive = Ro.SensitiveChild
        }
        Sf(t) {
            const s = document.createNodeIterator(
                t,
                NodeFilter.SHOW_ELEMENT,
                null,
                !1
            )
            let i = s.nextNode()
            for (t === i && (i = s.nextNode()); i; )
                this.Rf(i), (i = s.nextNode())
        }
        _f(t) {
            return (
                !(
                    !csNodeparentNode.apply(t) ||
                    (!u(csNodeparentNode.apply(t)) &&
                        !R(csNodeparentNode.apply(t))) ||
                    (!this.isSensitive(csNodeparentNode.apply(t)) &&
                        !this.isSensitiveChild(csNodeparentNode.apply(t)))
                ) ||
                (T(t) &&
                    (this.isSensitive(t.host) || this.isSensitiveChild(t.host)))
            )
        }
        Tf(t, s) {
            return u(t) && N.call(t, s)
        }
        Af(t, s, i) {
            return csArray.prototype.some.call(
                i,
                (i) =>
                    t.hasAttribute(s) &&
                    csString.prototype.indexOf.call(i.attrName, s) > -1 &&
                    N.call(t, i.selector)
            )
        }
        pf(t, s) {
            if (0 === s.length) return t
            if (0 === t.length) return csArray.prototype.join.call(s, ",")
            const i = csString.prototype.split.call(t, ",")
            for (const t of s) {
                const s = csString.prototype.split.call(t, ",")
                for (const t of s)
                    -1 === csArray.prototype.indexOf.call(i, t) &&
                        csArray.prototype.push.call(i, t)
            }
            return csArray.prototype.join.call(i, ",")
        }
        yf(t) {
            return csArray.prototype.some.call(
                this.df,
                (s) => s.selector === t.selector && s.attrName === t.attrName
            )
        }
    }
    class To {
        constructor(t) {
            this.Wc = t
        }
        init() {
            this.bf(To.Vf, Ct), this.bf(To.Cf, Vt)
        }
        bf(t, s) {
            this.Wc.register([t], (t, i) => {
                _t(t) && (_t(i) || bt(i)) && Jt.error(i, `${s}${t}`)
            })
        }
    }
    ;(To.Cf = "logSnippetError"), (To.Vf = "logImplementationSnippetError")
    class Io {
        constructor(t, s, i, e) {
            ;(this.$ = t), (this.Pa = s), (this.Gc = i), (this.Ca = e)
        }
        init() {
            this.Pa.onChildMessage((t, s, i) =>
                this.Ca.emitIframeEvent(t, s, i)
            ),
                this.Pa.setRecordingStatusCallback(() =>
                    this.Gc.getRecordingStatus()
                )
        }
        onStartTracking() {
            this.$.iframesTracking && this.Pa.start()
        }
        onOptout() {
            this.$.iframesTracking && this.Pa.stop()
        }
        onRecordingStatusChange() {
            this.$.iframesTracking &&
                this.Pa.onRecordingStatusChange(this.Gc.getRecordingStatus())
        }
    }
    class Po extends si {
        constructor(t, s) {
            super(),
                (this.$ = t),
                (this.us = s),
                (this.Nf = 0),
                (this.Of = new Map()),
                (this.kf = {
                    boundElement: window,
                    type: "message",
                    listener: (t) => this.$f(t),
                })
        }
        onChildMessage(t) {
            this.Lf = t
        }
        setRecordingStatusCallback(t) {
            this.xf = t
        }
        onRecordingStatusChange(t) {
            const s = Wt.buildBaseMessage(
                Zt.RecordingStatus,
                Gt.Parent,
                this.$.projectId
            )
            ;(s.content = t),
                this.Of.forEach((t) => {
                    !this.Mf(t) && t.port && Wt.sendChannelMessage(t.port, s)
                })
        }
        sendToChildren(t, s) {
            const i = Wt.buildBaseMessage(t, Gt.Parent, this.$.projectId)
            ;(i.content = s), this.Df(i)
        }
        onStart() {
            vs(this.kf, !1), this.Uf()
        }
        onStop() {
            this.zf(), _s(this.kf, !1), this.Ff()
        }
        Uf() {
            const t = this.Bf()
            this.Hf(t),
                csArray.prototype.forEach.call(t, (t) => {
                    if (null === this.qf(t)) {
                        const s = { iframe: t }
                        this.Of.set(this.Nf, s), (this.Nf += 1)
                    }
                }),
                this.jf()
        }
        Bf() {
            return csArray.prototype.filter.call(
                Oi.findAllElements("iframe"),
                (t) => this.Gf(t)
            )
        }
        Hf(t) {
            this.Of.forEach((s, i) => {
                s.iframe &&
                    -1 === csArray.prototype.indexOf.call(t, s.iframe) &&
                    this.Zf(i, s)
            })
        }
        Zf(t, s) {
            s.port && Wt.closeChannelPort(s.port), this.Of.delete(t)
        }
        Ff() {
            this.Of.forEach((t) => {
                t.port && Wt.closeChannelPort(t.port)
            }),
                this.Of.clear()
        }
        qf(t) {
            let s = null
            return (
                this.Of.forEach((i, e) => {
                    null === s && i.iframe === t && (s = e)
                }),
                s
            )
        }
        Gf(t) {
            return t.id !== i && (!t.src || Ft(zt(t.src), this.$.hostnames))
        }
        Df(t) {
            this.Of.forEach((s) => {
                s.port && Wt.sendChannelMessage(s.port, t)
            })
        }
        jf() {
            this.Of.forEach((t, s) => {
                if (t.iframe.contentWindow) {
                    const i = this.Wf(s)
                    Wt.sendPostMessage(t.iframe.contentWindow, "*", i)
                }
            })
        }
        zf() {
            const t = this.Kf()
            this.Of.forEach((s) => {
                s.port
                    ? Wt.sendChannelMessage(s.port, t)
                    : s.iframe.contentWindow &&
                      Wt.sendPostMessage(s.iframe.contentWindow, "*", t)
            })
        }
        Wf(t) {
            return Wt.buildBaseMessage(
                Zt.Discovery,
                Gt.Parent,
                this.$.projectId,
                t
            )
        }
        Kf() {
            return Wt.buildBaseMessage(Zt.Stop, Gt.Parent, this.$.projectId)
        }
        Yf(t, s) {
            const i = this.Of.get(t)
            void 0 !== i
                ? ((i.port = s),
                  (i.port.onmessage = (t) => {
                      this.Qf(t, i)
                  }))
                : Jt.error(
                      `Parent received channel messaging initialization from unknow child id : ${t} (${this.Nf})`
                  )
        }
        Jf(t) {
            if (!t.port) return
            const s = Wt.buildBaseMessage(
                    Zt.RecordingStatus,
                    Gt.Parent,
                    this.$.projectId
                ),
                i = this.xf()
            this.Mf(t) &&
                ((i.isRecording = !1), (i.isMutationTrackerStarted = !1)),
                (s.content = i),
                Wt.sendChannelMessage(t.port, s)
        }
        Qf(t, s) {
            if (void 0 === s)
                return void Jt.error(
                    `Parent received channelMessage from unknown child : ${csJSON.stringify(
                        t.data
                    )}`
                )
            const i = t.data.type,
                e = t.data.content
            i === Zt.EndOfBufferedMessages
                ? this.Jf(s)
                : this.Lf(s.iframe, i, e)
        }
        $f(t) {
            if (
                Wt.isMessageValid(
                    t,
                    Gt.Child,
                    this.$.projectId,
                    this.$.hostnames
                )
            )
                switch (t.data.type) {
                    case Zt.Discovery:
                        if (void 0 === t.data.id) return void this.Uf()
                        if (
                            t.ports &&
                            1 === t.ports.length &&
                            this.Of.has(t.data.id)
                        )
                            return void this.Yf(t.data.id, t.ports[0])
                        Jt.error(
                            `Parent received wrong channelMessage initialization : (${
                                t.origin
                            }) : ${csJSON.stringify(t.data)}`
                        )
                        break
                    case Zt.ChildLogMessage:
                        this.Lf(null, Zt.ChildLogMessage, t.data.content)
                        break
                    default:
                        Jt.warn(
                            `Parent received unexpected postMessage type from child (${
                                t.origin
                            }) : ${csJSON.stringify(t.data)}`
                        )
                }
        }
        Mf(t) {
            return (
                this.us.isSensitive(t.iframe) ||
                this.us.isSensitiveChild(t.iframe)
            )
        }
    }
    class bo {
        compute(t, s) {
            const i = this.Xf(s.x) - this.Xf(t.x),
                e = this.Xf(s.y) - this.Xf(t.y),
                n = s.time - t.time
            return {
                duration: n,
                distance: this.tw(i, e),
                direction: this.iw(i, e),
                velocity: this.ew(i, e, n),
            }
        }
        computePinchMetrics(t, s) {
            const i = this.Xf(s.x) - this.Xf(t.x),
                e = this.Xf(s.y) - this.Xf(t.y)
            return { duration: s.time - t.time, distance: this.tw(i, e) }
        }
        getScale(t, s) {
            return Math.abs(s / t - 1)
        }
        Xf(t) {
            return t / window.devicePixelRatio
        }
        tw(t, s) {
            return Math.round(Math.sqrt(t * t + s * s))
        }
        ew(t, s, i) {
            const e = i / 1e3,
                n = t / e,
                r = s / e
            return Math.round(Math.abs(n) + Math.abs(r))
        }
        iw(t, s) {
            return Math.abs(t) > Math.abs(s)
                ? t > 0
                    ? Le.RIGHT
                    : Le.LEFT
                : s > 0
                ? Le.DOWN
                : Le.UP
        }
    }
    class Vo {
        constructor() {
            ;(this.nw = {}), (this.rw = new bo()), this.hw()
        }
        onGesture(t) {
            this.ow = t
        }
        isValidTouchEvent(t) {
            return "touches" in t && "changedTouches" in t
        }
        processActionDown(t) {
            if (!this.cw(t)) return
            this.aw(t) && this.hw()
            const s = {
                x: t.touches[0].clientX,
                y: t.touches[0].clientY,
                time: pt.now(),
            }
            if (1 === t.touches.length)
                (this.nw.startPinchTime = s.time), (this.nw.firstTouch = s)
            else if (
                2 === t.touches.length &&
                ((this.nw.secondTouch = {
                    x: t.touches[1].clientX,
                    y: t.touches[1].clientY,
                    time: pt.now(),
                }),
                this.nw.firstTouch && this.nw.secondTouch)
            ) {
                const t = this.rw.computePinchMetrics(
                    this.nw.firstTouch,
                    this.nw.secondTouch
                )
                this.uw = t.distance
            }
            csArray.prototype.push.call(this.lw, s), (this.fw = Ls(t))
        }
        processActionMove() {
            this.pw = !0
        }
        processActionUp(t) {
            if (this.mw(t)) {
                if (
                    (csArray.prototype.push.call(this.lw, {
                        x: t.changedTouches[0].clientX,
                        y: t.changedTouches[0].clientY,
                        time: pt.now(),
                    }),
                    this.Ew(t) && this.nw.startPinchTime)
                ) {
                    const s = {
                            x: t.touches[0].clientX,
                            y: t.touches[0].clientY,
                            time: this.nw.startPinchTime,
                        },
                        i = {
                            x: t.changedTouches[0].clientX,
                            y: t.changedTouches[0].clientY,
                            time: pt.now(),
                        }
                    this.nw.firstTouch &&
                        ((this.nw.firstTouch = s), (this.nw.secondTouch = i)),
                        this.yw(t)
                }
                this.uw || (this.Aw() && this.gw(t))
            }
        }
        hw() {
            ;(this.lw = []),
                (this.fw = null),
                (this.pw = !1),
                (this.uw = null),
                (this._w = !0)
        }
        gw(t) {
            const s = this.rw.compute(this.lw[0], this.lw[1])
            this._w = t.isTrusted
            const i = this.pw ? this.Rw(s) : this.Sw(s)
            this.ow(i, t)
        }
        yw(t) {
            if (!this.nw.firstTouch || !this.nw.secondTouch) return
            const s = this.rw.computePinchMetrics(
                this.nw.firstTouch,
                this.nw.secondTouch
            )
            this._w = t.isTrusted
            const i = this.Tw(s)
            i && this.ow(i, t)
        }
        Tw(t) {
            if (!this.uw) return
            if (this.rw.getScale(this.uw, t.distance) < 0.1) return
            return {
                type: this.uw > t.distance ? $e.PINCH_IN : $e.PINCH_OUT,
                target: this.fw,
                distance: t.distance,
                isTrusted: this._w,
            }
        }
        Rw(t) {
            return {
                type: t.velocity < 100 ? $e.DRAG : $e.FLICK,
                target: this.fw,
                velocity: t.velocity,
                distance: t.distance,
                direction: t.direction,
                isTrusted: this._w,
            }
        }
        Sw(t) {
            return {
                type: t.duration < 1e3 ? $e.TAP : $e.LONG_PRESS,
                target: this.fw,
                isTrusted: this._w,
            }
        }
        aw(t) {
            return 1 === t.touches.length
        }
        Aw() {
            return 2 === this.lw.length
        }
        cw(t) {
            return t.touches.length > 0
        }
        mw(t) {
            return t.changedTouches.length > 0
        }
        Ew(t) {
            return (
                this.pw &&
                !!this.uw &&
                1 === t.changedTouches.length &&
                1 === t.touches.length
            )
        }
    }
    class Co {
        constructor() {
            this.subscriptions = {}
        }
        subscribe(t, s) {
            ;(this.subscriptions[t] = s),
                1 === Object.keys(this.subscriptions).length &&
                    this.onStartTracking()
        }
        unsubscribe(t) {
            delete this.subscriptions[t],
                0 === Object.keys(this.subscriptions).length &&
                    this.onStopTracking()
        }
    }
    class No extends Co {
        constructor(t) {
            super(),
                (this.Iw = t),
                (this.Nn = [
                    {
                        boundElement: document,
                        type: "touchstart",
                        listener: (t) => this.$e(t),
                    },
                    {
                        boundElement: document,
                        type: "touchmove",
                        listener: (t) => this.$e(t),
                    },
                    {
                        boundElement: document,
                        type: "touchend",
                        listener: (t) => this.$e(t),
                    },
                ]),
                (this.Pw = new Vo()),
                this.Pw.onGesture((t, s) => this.bw(t, s))
        }
        bw(t, s) {
            for (const i in this.subscriptions) {
                ;(0, this.subscriptions[i])(t, s)
            }
        }
        onStartTracking() {
            this.canDetectGesture() &&
                csArray.prototype.forEach.call(this.Nn, (t) => vs(t))
        }
        onStopTracking() {
            this.canDetectGesture() &&
                csArray.prototype.forEach.call(this.Nn, (t) => _s(t))
        }
        canDetectGesture() {
            return void 0 !== window.devicePixelRatio
        }
        $e(t) {
            this.Iw.tryToExecute("process gesture event", () => {
                if (this.Pw.isValidTouchEvent(t))
                    switch (t.type) {
                        case "touchstart":
                            this.Pw.processActionDown(t)
                            break
                        case "touchmove":
                            this.Pw.processActionMove()
                            break
                        case "touchend":
                            this.Pw.processActionUp(t)
                    }
            })()
        }
        static isSwipe(t) {
            return t.type === $e.FLICK || t.type === $e.DRAG
        }
    }
    class Oo extends si {
        constructor(t, s) {
            super(), (this.ie = t), (this.Vw = s), (this.Cw = 0)
        }
        onStart() {
            Jt.isPerfLoggingActive() &&
                (this.Nw = window.setInterval(() => this.Ow(), Oo.kw))
        }
        onStop() {
            Jt.isPerfLoggingActive() && (this.Ow(), clearInterval(this.Nw))
        }
        Ow() {
            if (bs.isEmpty() || this.Cw >= Oo.$w) return
            const t = bs.getAll()
            this.Cw++
            const s = { a: Oo.Lw, l: Oo.xw, ...this.Vw.getRequestParameters() },
                i = csArray.prototype.map.call(t, (t) => ({ ...t, ...s }))
            this.ie.send(i), bs.clear()
        }
    }
    ;(Oo.Lw = "uxa"), (Oo.xw = "perf"), (Oo.kw = 5e3), (Oo.$w = 5)
    class ko {
        constructor(t, s, i) {
            ;(this.$ = t), (this.Vw = s), (this.Jc = i)
        }
        init() {
            this.Mw = new Oo(this.Jc.create(this.$.getLoggerUri(), !0), this.Vw)
        }
        onStartTracking() {
            this.Mw.start()
        }
        onOptout() {
            this.Mw.stop()
        }
    }
    class $o {
        constructor() {
            this.Dw = !1
        }
        enableRecordingStatus(t, s, i, e, n, r) {
            ;(this.Dw = !0),
                (this.kn = t),
                (this.us = s),
                (this.$n = i),
                (this.ia = e),
                (this.W = n),
                (this.se = r)
        }
        getRecordingStatus() {
            var t, s, i, e
            return this.Dw
                ? {
                      isRecording: this.kn.isRecording(),
                      isMutationTrackerStarted: this.kn.isMutationTrackerStarted(),
                      PIISelectors: this.us.getPIISelectors(),
                      capturedElementSelector: this.ia.getWhitelistedElementsSelector(),
                      useAnonymization: this.$n.shouldUseAnonymization(),
                      encryptionSelectors:
                          null === (t = this.se) || void 0 === t
                              ? void 0
                              : t.getEncryptionSelectors(),
                      activateOnlineAssetsOnNextStart:
                          null ===
                              (s = this.kn.getStaticResourceManagerStatus()) ||
                          void 0 === s
                              ? void 0
                              : s.onlineAssets.enabledForChildrenOnNextStart,
                      recordingStartTimestamp: parseInt(
                          this.kn.getRecordingStartTimestamp(),
                          10
                      ),
                      etrState:
                          null !==
                              (e =
                                  null === (i = this.W.getSession()) ||
                                  void 0 === i
                                      ? void 0
                                      : i.etrState) && void 0 !== e
                              ? e
                              : ei.ETR_OFF,
                  }
                : {
                      isRecording: !1,
                      recordingStartTimestamp: 0,
                      etrState: ei.ETR_OFF,
                  }
        }
    }
    class Lo {
        constructor() {
            this.Uw = Th.Natural
        }
        setPageViewType(t) {
            this.Uw = t
        }
        getPageViewType() {
            return this.Uw
        }
        getRequestParameters() {
            return { pvt: this.Uw }
        }
    }
    class xo {
        constructor(t) {
            this.Yi = t
        }
        onAfterVisitorRenewal() {
            this.Yi.startNewSession()
        }
    }
    class Mo {
        constructor(
            t,
            s,
            i,
            e,
            n,
            r,
            h,
            o,
            c,
            a,
            u,
            l,
            d,
            f,
            w,
            p,
            m,
            E,
            y,
            A,
            g,
            v,
            _,
            R,
            S
        ) {
            ;(this.Bo = t),
                (this.Zc = s),
                (this.Z = i),
                (this.W = e),
                (this.Ls = n),
                (this.Wc = r),
                (this.zw = h),
                (this.$ = o),
                (this.Fw = c),
                (this.Bw = a),
                (this.Hw = u),
                (this.Hh = l),
                (this.L = d),
                (this.Uu = f),
                (this.Xc = w),
                (this.X = p),
                (this.qw = m),
                (this.Kd = E),
                (this.Ca = y),
                (this.rs = A),
                (this.jw = g),
                (this.Qc = v),
                (this.Gw = _),
                (this.hr = R),
                (this.Jc = S),
                (this.Zw = (t = !1) => {
                    this.Ww.start(t), this.Kw.start()
                })
        }
        start() {
            if ((this.Fw.init(), this.Bw.init(), this.Bw.isActive())) return
            let t, s, i, e, n, r, h, o, c, a, u, l, d, f, w
            this.hr.schedule(() => {
                ;(l = new Zh(this.W, this.Z)),
                    (w = new xo(l)),
                    (u = new Dh(this.Uu)),
                    (f = new No(Jt)),
                    (t = new Sh(
                        this.$,
                        this.Bo,
                        this.Z,
                        this.Uu,
                        u,
                        this.Wc,
                        l,
                        f,
                        this.Ca,
                        this.Jc
                    )),
                    (s = new Qn(
                        this.Wc,
                        this.W,
                        this.$,
                        this.Bo,
                        this.Zc,
                        this.L
                    )),
                    (d = new So(this.$)),
                    (a = new $o())
                const p = new Po(this.$, d)
                ;(c = new Io(this.$, p, a, this.Ca)), c.init()
                const m = new Lo()
                ;(i = new Gn(
                    this.Z,
                    this.W,
                    this.Wc,
                    this.Ca,
                    p,
                    this.$,
                    m,
                    a
                )),
                    (e = new hr(
                        this.$,
                        this.Bo,
                        this.Z,
                        this.Wc,
                        this.L,
                        l,
                        this.X
                    )),
                    (this.Ww = new Mh(
                        this.$,
                        this.Wc,
                        this.Ls,
                        this.Bo,
                        this.Z,
                        this.W,
                        this.Hh,
                        this.rs,
                        this.Xc,
                        this.X,
                        this.Qc,
                        m
                    )),
                    (n = new Gh(this.$, this.Z, this.W, this.Wc)),
                    (r = new Ao(this.$, this.Wc, this.Zc, this.Bo, this.Kd)),
                    (h = new To(this.Wc)),
                    (o = new ko(this.$, new At(this.$, this.L), this.Jc)),
                    (this.Kw = new Uh())
            }),
                this.hr.schedule(() => {
                    this.Hw.init()
                }),
                this.hr.schedule(() => {
                    i.init()
                }),
                this.hr.schedule(() => {
                    s.init()
                }),
                this.hr.schedule(() => {
                    e.init()
                }),
                this.hr.schedule(() => {
                    this.jw.init()
                }),
                this.hr.schedule(() => {
                    this.Ww.init()
                }),
                this.hr.schedule(() => {
                    n.init()
                }),
                this.hr.schedule(() => {
                    r.init()
                }),
                this.hr.schedule(() => {
                    this.qw.init()
                }),
                this.hr.schedule(() => {
                    h.init()
                }),
                this.hr.schedule(() => {
                    o.init()
                }),
                this.hr.schedule(() => {
                    this.Gw.init()
                }),
                this.hr.schedule(() => {
                    this.Ls.addListener(n),
                        this.Ls.addListener(this.zw),
                        this.Ls.addListener(t),
                        this.Ls.addListener(this.Hw),
                        this.Ls.addListener(i),
                        this.Ls.addListener(this.jw),
                        this.Ls.addListener(this.Ww),
                        this.Ls.addListener(r),
                        this.Ls.addListener(s),
                        this.Ls.addListener(c),
                        this.Ls.addListener(o),
                        this.Ls.addListener(w)
                }),
                ln.isRecordingSupported() &&
                    this.hr.schedule(() => {
                        const t = new kn(
                            a,
                            this.W,
                            this.$,
                            this.Zc,
                            this.Hh,
                            this.Bo,
                            this.Wc,
                            this.L,
                            l,
                            this.X,
                            d,
                            this.Qi,
                            this.Ji,
                            this.Xi,
                            f,
                            this.te,
                            this.Ls,
                            this.Kd,
                            this.Ca,
                            this.Qc,
                            this.hr,
                            this.Jc,
                            this.Xc
                        )
                        t.init(),
                            this.Ls.addListener(t),
                            i.setRecordingService(t.recordingService)
                    }),
                this.$.eMerchandisingEnabled &&
                    this.hr.schedule(() => {
                        const t = new uo(
                            this.$,
                            this.Uu,
                            this.Jc,
                            this.Bo,
                            this.rs,
                            this.X,
                            this.Ca,
                            this.Wc,
                            this.hr
                        )
                        t.init(), this.Ls.addListener(t)
                    }),
                this.hr.schedule(() => {
                    t.init()
                }),
                this.hr.schedule(() => {
                    l.onSessionExpired(() => {
                        this.Ls.emitBeforeSessionRenewal(),
                            this.Yw(!0),
                            this.Ls.emitAfterSessionRenewal()
                    }),
                        this.Yw()
                })
        }
        Yw(t = !1) {
            this.Wc.start(),
                this.Kw.onLoad(() => {
                    this.Ls.emitStartTracking(t)
                }),
                (wo(this.$) && !t) || this.Zw(t)
        }
    }
    class Do {
        constructor(t, s, i, e, n, r, h, o) {
            ;(this.$ = t),
                (this.Z = s),
                (this.ns = i),
                (this.Qw = e),
                (this.Jw = n),
                (this.Xw = r),
                (this.tp = h),
                (this.sp = o)
        }
        compute(t) {
            var s, i
            this.$.crossDomainTracking && !this.$.cookielessTrackingEnabled
                ? this.$.crossDomainSingleIframeTracking
                    ? null === (s = this.tp) ||
                      void 0 === s ||
                      s.start(() => this.ip(t))
                    : null === (i = this.Xw) ||
                      void 0 === i ||
                      i.applyUpToDate(() => this.ip(t))
                : this.ip(t)
        }
        ip(t) {
            this.Jw.handle(),
                this.Qw.clear(),
                this.ep()
                    ? (this.Qw.restoreClearedVisitor(), t(!0))
                    : (this.ns.exclude(this.$), t(!1))
        }
        ep() {
            const t = Y.boolean(this.$.sampleRate)
            return (
                this.sp.isForceIncluded() ||
                (!this.ns.isExcluded() && this.Z.doesVisitorExist()) ||
                (!this.ns.isExcluded() && t)
            )
        }
    }
    var Uo
    !(function (t) {
        t.generate = function () {
            const t =
                    navigator.userAgent +
                    navigator.language +
                    navigator.platform,
                s = csString.prototype.slice.call(
                    (function (t) {
                        let s = 0
                        for (let i = 0; i < t.length; i += 1)
                            s =
                                csString.prototype.charCodeAt.call(t, i) +
                                (s << 6) +
                                (s << 16) -
                                s
                        return Math.abs(s)
                    })(t).toString(16),
                    -4
                )
            let i = new csDate().getTime()
            const e = "xxxxxxxx-hhhh-axxx-yxxx-xxxxxxxxxxxx".replace(
                /[xy]/g,
                (t) => {
                    const s = (i + 16 * Math.random()) % 16 | 0
                    return (
                        (i = Math.floor(i / 16)),
                        ("x" === t ? s : (7 & s) | 8).toString(16)
                    )
                }
            )
            return csString.prototype.replace.call(e, "hhhh", s)
        }
    })(Uo || (Uo = {}))
    class zo {
        constructor(t, s, i, e) {
            ;(this.$ = t),
                (this.np = s),
                (this.W = i),
                (this.Ls = e),
                (this.rp = 1e4)
        }
        createOrUpdateVisitor() {
            let t = this.getVisitor()
            null === t && ((t = this.hp()), this.W.removeSession()),
                this.op(t),
                this.setVisitor(t)
        }
        hp() {
            return {
                id: Uo.generate(),
                visitsCount: 0,
                appliedTrackingDraw: this.$.lastTrackingDraw,
                creationTimestamp: mt(),
                lastVisitTimestamp: 0,
                hitTimestamp: 0,
                expires: pt.now() + this.$.visitorCookieTimeout,
                allowSubdomains: this.$.allowSubdomains,
            }
        }
        op(t) {
            const s = mt()
            this.W.doesSessionExist() ||
                ((t.visitsCount += 1), (t.lastVisitTimestamp = s)),
                (t.hitTimestamp = s),
                (t.appliedTrackingDraw = this.$.lastTrackingDraw),
                (this.cp = t.visitsCount)
        }
        getRequestParameters() {
            const t = this.getVisitor()
            return t
                ? { uu: t.id, sn: `${t.visitsCount}`, hd: `${t.hitTimestamp}` }
                : {}
        }
        getVisitor() {
            return this.np.get()
        }
        setVisitor(t) {
            this.np.set(t)
        }
        doesVisitorExist() {
            return null !== this.np.get()
        }
        resetVisitor() {
            this.ap(), this.Ls.emitAfterVisitorCleared()
        }
        removeVisitor() {
            this.np.remove()
        }
        hasAllowSubdomainsChanged() {
            const t = this.getVisitor()
            if (!t) return !1
            return t.allowSubdomains !== this.$.allowSubdomains
        }
        handleSubdomainChange() {
            this.np.handleSubdomainChange()
        }
        isSessionRenewed() {
            const t = this.getVisitor()
            return null !== t && void 0 !== this.cp && t.visitsCount !== this.cp
        }
        up() {
            return !St(this.lp) || pt.now() - this.lp > this.rp
        }
        renewVitor() {
            this.up()
                ? ((this.lp = pt.now()),
                  this.ap(),
                  this.Ls.emitAfterVisitorRenewal())
                : Jt.warn(
                      "session:start:newVisitor is trying to renew visitor under time limit"
                  )
        }
        ap() {
            this.Ls.emitBeforeVisitorRenewal(), this.removeVisitor()
        }
    }
    const Fo = "_cs_s",
        Bo = 18e5,
        Ho = /^(\d+\.[013567TBW](\.[01])?)(\.\d+)?$/,
        qo = "."
    var jo
    !(function (t) {
        ;(t[(t.NOT_FOUND = 0)] = "NOT_FOUND"),
            (t[(t.EXPIRED = 1)] = "EXPIRED"),
            (t[(t.FOUND = 2)] = "FOUND")
    })(jo || (jo = {}))
    class Go {
        constructor(t, s, i) {
            ;(this.$ = t),
                (this.dp = s),
                (this.fp = i),
                (this.Eo = null),
                (this.wp = !1)
        }
        get(t) {
            const s = this.getRawSession(t)
            return this.isValid(s) ? Go.fromString(s) : null
        }
        getRawSession(t) {
            if (t) {
                const t = this.pp()
                return Go.mp(t)
            }
            const { sessionString: s, status: i } = this.Ep(),
                e = Go.mp(s)
            if (i !== jo.EXPIRED) return e
            if (this.$.cookielessTrackingEnabled) return null
            const n = this.pp()
            if (!n) return null
            const r = csString.prototype.split.call(n, qo)
            if (!Go.yp(r)) return n
            const h = r[r.length - 1],
                o = parseInt(h, 10)
            return isNaN(o) || this.Ap(o), e
        }
        onCookieToSet(t) {
            this.gp = t
        }
        onCookieToRemove(t) {
            this.vp = t
        }
        set(t, s = 18e5) {
            var i
            const e = pt.now() + s
            let n = this.toString(t)
            ;(n += `${qo}${e}`),
                this._p(n, e),
                this.$.cookielessTrackingEnabled
                    ? this.fp.setItem(Fo, n)
                    : (this.dp.set(Fo, n, s),
                      null === (i = this.gp) ||
                          void 0 === i ||
                          i.call(this, Fo, n, s))
        }
        remove() {
            var t
            this.$.cookielessTrackingEnabled
                ? this.fp.removeItem(Fo)
                : (this.dp.delete(Fo),
                  null === (t = this.vp) || void 0 === t || t.call(this, Fo)),
                this.Rp()
        }
        handleSubdomainChange() {
            if (this.$.cookielessTrackingEnabled) return
            const t = this.get(!0)
            t &&
                (this.$.allowSubdomains
                    ? this.dp.delete(Fo, hs.CURRENT_DOMAIN)
                    : this.dp.delete(Fo, this.dp.getRootDomain()),
                this.set(t))
        }
        isValid(t) {
            return null !== t && Go.isValidSessionString(t)
        }
        toString(t) {
            return csArray.prototype.join.call(
                [t.pageNumber, t.recordingState, t.etrState],
                qo
            )
        }
        _p(t, s) {
            this.Eo = { sessionString: t, expires: s }
        }
        Ep() {
            return this.Eo
                ? this.Eo && pt.now() <= this.Eo.expires
                    ? { sessionString: this.Eo.sessionString, status: jo.FOUND }
                    : {
                          sessionString: this.Eo.sessionString,
                          status: jo.EXPIRED,
                      }
                : { sessionString: this.pp(), status: jo.NOT_FOUND }
        }
        Rp() {
            this.Eo = null
        }
        Ap(t) {
            this.Eo && ((this.Eo.expires = t), (this.wp = !0))
        }
        isCacheRefreshed() {
            return this.wp
        }
        resetCacheRefreshed() {
            this.wp = !1
        }
        pp() {
            if (this.$.cookielessTrackingEnabled) {
                const t = this.fp.getItem(Fo)
                return !t || this.Sp(t) ? null : t
            }
            const t = this.dp.get(Fo)
            return !t || this.Sp(t) ? null : t
        }
        Sp(t) {
            const s = csString.prototype.split.call(t, qo)
            if (!Go.yp(s)) return !1
            const i = parseInt(s[s.length - 1], 10)
            return !isNaN(i) && pt.now() > i
        }
        static yp(t) {
            return 13 === t[t.length - 1].length
        }
        static mp(t) {
            var s
            if (!t) return null
            const i =
                null === (s = csString.prototype.match.call(t, Ho)) ||
                void 0 === s
                    ? void 0
                    : s[1]
            return null != i ? i : null
        }
        static fromRawString(t) {
            const s = Go.mp(t)
            return null !== s ? Go.fromString(s) : null
        }
        static fromString(t) {
            var s
            const [i, e, n] = csString.prototype.split.call(t, qo)
            return {
                recordingState: e,
                etrState: null !== (s = n) && void 0 !== s ? s : ei.ETR_OFF,
                pageNumber: parseInt(i, 10),
            }
        }
        static isValidSessionString(t) {
            return Ho.test(t)
        }
    }
    var Zo
    !(function (t) {
        ;(t[(t.NO = 0)] = "NO"),
            (t[(t.WITHDRAWN = 1)] = "WITHDRAWN"),
            (t[(t.GRANTED = 2)] = "GRANTED")
    })(Zo || (Zo = {}))
    class Wo {
        constructor(t, s) {
            ;(this.Tp = t),
                (this.Ip = s),
                (this.Pp = null),
                (this.bp = 0),
                (this.Vp = Zo.NO)
        }
        setDynamicVariablesService(t) {
            this.Cp = t
        }
        createOrUpdateSession() {
            this.Np(), (this.Op = pt.now()), (this.bp = 0)
            let t = this.kp()
            null === t
                ? ((t = this.$p()), this.Lp(t), this.xp(t))
                : ((t = this.Ip.sanitizeSessionRecordingState(t)),
                  this.Lp(t),
                  (t.recordingState = this.Ip.updateRecordingState(t))),
                this.setSession(t)
        }
        grantReplayRecording(t) {
            ;(t.recordingState = this.Ip.getDisabledRecordingState()),
                (t.recordingState = this.Ip.computeInitialRecordingStateFromRecordingConsentGranted(
                    t
                )),
                this.setSession(t)
        }
        grantReplayRecordingBeforeSessionStart() {
            this.Vp = Zo.GRANTED
        }
        withdrawnReplayRecording(t) {
            ;(t.recordingState = this.Ip.getConsentWithdrawnRecordingState()),
                this.setSession(t)
        }
        withdrawnReplayRecordingBeforeSessionStart() {
            this.Vp = Zo.WITHDRAWN
        }
        xp(t) {
            this.Vp === Zo.WITHDRAWN
                ? ((t.recordingState = this.Ip.getConsentWithdrawnRecordingState()),
                  this.setSession(t))
                : this.Vp === Zo.GRANTED
                ? (t.recordingState = this.Ip.computeInitialRecordingStateFromRecordingConsentGranted(
                      t
                  ))
                : (t.recordingState = this.Ip.computeInitialRecordingState(t)),
                (this.Vp = Zo.NO)
        }
        $p() {
            return {
                pageNumber: 0,
                recordingState: this.Ip.getDisabledRecordingState(),
                etrState: ei.ETR_OFF,
            }
        }
        Lp(t) {
            t.pageNumber += 1
        }
        isReplayRecorded() {
            const t = this.getSession()
            return !!t && this.Ip.isReplayRecorded(t)
        }
        isTemporarilyRecorded() {
            const t = this.getSession()
            return (
                (null == t ? void 0 : t.recordingState) ===
                ii.TEMPORARILY_RECORDED
            )
        }
        abortQuotaServiceRequest() {
            this.Ip.abortQuotaServiceRequest()
        }
        getRequestParameters() {
            const t = {},
                s = this.getSession()
            return null !== s && (t.pn = `${s.pageNumber}`), t
        }
        getSession() {
            return this.Tp.get()
        }
        kp() {
            return this.Tp.get(!0)
        }
        doesSessionExist() {
            return null !== this.Tp.get()
        }
        setSession(t) {
            this.Tp.set(t)
        }
        removeSession() {
            this.Tp.remove()
        }
        getRecordingStates() {
            const t = this.getSession(),
                s = []
            return (
                t &&
                    (t.recordingState !== ii.NOT_RECORDED &&
                        csArray.prototype.push.call(s, t.recordingState),
                    t.etrState === ei.ETR_ON &&
                        csArray.prototype.push.call(s, ii.ETR_SAMPLING)),
                s
            )
        }
        updateRecordingState(t, s) {
            const i = this.getSession()
            null !== i &&
                ((i.recordingState = t), (i.etrState = s), this.setSession(i))
        }
        hasValidSession() {
            const t = this.Tp.getRawSession()
            return this.Tp.isValid(t)
        }
        handleSubdomainChange() {
            this.Tp.handleSubdomainChange()
        }
        pollCacheRefreshEvent(t = !0) {
            const s = this.Tp.isCacheRefreshed()
            return s && t && this.Tp.resetCacheRefreshed(), s
        }
        extendSessionPeriodically() {
            this.Pp || this.Mp()
        }
        Mp() {
            if (this.Dp()) return void this.Np()
            const t = this.getSession()
            if (null === t)
                return (
                    Jt.warn(
                        "extendSession is trying to extend an expired session"
                    ),
                    void this.Np()
                )
            this.Tp.set(t, Bo), this.zp(), this.Fp()
        }
        Fp() {
            this.Pp = window.setTimeout(() => {
                this.Mp()
            }, 174e4)
        }
        Dp() {
            return 1434e4 - (pt.now() + Bo - this.Op) < 0
        }
        Np() {
            this.Pp && (window.clearTimeout(this.Pp), (this.Pp = null))
        }
        zp() {
            ;(this.bp += 1),
                this.Cp.trackDynamicVariable("session_expiry_update", this.bp)
        }
    }
    class Ko {
        constructor(t, s, i) {
            ;(this.$ = t), (this.Z = s), (this.ns = i)
        }
        clear() {
            this.Bp() &&
                ((this.Hp = this.Z.getVisitor()), this.Z.removeVisitor()),
                this.qp() && this.ns.removeExclusion()
        }
        Bp() {
            return (
                this.Z.doesVisitorExist() &&
                this.Z.getVisitor().appliedTrackingDraw !==
                    this.$.lastTrackingDraw
            )
        }
        qp() {
            return this.ns.getAppliedTrackingDraw() !== this.$.lastTrackingDraw
        }
        restoreClearedVisitor() {
            this.Hp && this.Z.setVisitor(this.Hp)
        }
    }
    class Yo {
        constructor(t, s, i) {
            ;(this.Z = t), (this.W = s), (this.jp = i)
        }
        handle() {
            this.Z.hasAllowSubdomainsChanged() &&
                (this.Z.handleSubdomainChange(),
                this.W.handleSubdomainChange(),
                this.jp.handleSubdomainChange())
        }
    }
    class Qo {
        constructor() {
            this.listeners = []
        }
        addListener(t) {
            csArray.prototype.push.call(this.listeners, t)
        }
    }
    class Jo extends Qo {
        constructor(t) {
            super(), (this.hr = t)
        }
        emitBeforeNaturalPageView() {
            for (const t of this.listeners)
                t.onBeforeNaturalPageView && t.onBeforeNaturalPageView()
        }
        emitAfterNaturalPageView() {
            for (const t of this.listeners)
                t.onAfterNaturalPageView && t.onAfterNaturalPageView()
        }
        emitInitTracking() {
            for (const t of this.listeners)
                t.onInitTracking && t.onInitTracking()
        }
        emitStartTracking(t) {
            for (const s of this.listeners)
                s.onStartTracking &&
                    this.hr.schedule(() => s.onStartTracking(t))
        }
        emitArtificialPageViewEnd() {
            for (const t of this.listeners)
                if (t.onArtificialPageViewEnd)
                    try {
                        t.onArtificialPageViewEnd()
                    } catch (t) {
                        Jt.error(t)
                    }
        }
        emitBeforeArtificialPageView() {
            for (const t of this.listeners)
                t.onBeforeArtificialPageView && t.onBeforeArtificialPageView()
        }
        emitAfterArtificialPageView() {
            for (const t of this.listeners)
                t.onAfterArtificialPageView && t.onAfterArtificialPageView()
        }
        emitBeforeSessionRenewal() {
            for (const t of this.listeners)
                t.onBeforeSessionRenewal && t.onBeforeSessionRenewal()
        }
        emitAfterSessionRenewal() {
            for (const t of this.listeners)
                t.onAfterSessionRenewal && t.onAfterSessionRenewal()
        }
        emitOptout() {
            for (const t of this.listeners) t.onOptout && t.onOptout()
        }
        emitReplayUnanonymizationConsentGranted() {
            for (const t of this.listeners)
                t.onReplayUnanonymizationConsentGranted &&
                    t.onReplayUnanonymizationConsentGranted()
        }
        emitReplayUnanonymizationConsentWithdrawn() {
            for (const t of this.listeners)
                t.onReplayUnanonymizationConsentWithdrawn &&
                    t.onReplayUnanonymizationConsentWithdrawn()
        }
        emitAfterReplayRecordingConsentGranted() {
            for (const t of this.listeners)
                t.onAfterReplayRecordingConsentGranted &&
                    t.onAfterReplayRecordingConsentGranted()
        }
        emitAfterReplayRecordingConsentWithdrawn() {
            for (const t of this.listeners)
                t.onAfterReplayRecordingConsentWithdrawn &&
                    t.onAfterReplayRecordingConsentWithdrawn()
        }
        emitRecordingStateChange(t, s) {
            for (const i of this.listeners)
                i.onRecordingStateChange && i.onRecordingStateChange(t, s)
        }
        emitInitialDomStart() {
            for (const t of this.listeners)
                t.onInitialDomStart && t.onInitialDomStart()
        }
        emitInitialDomDone(t) {
            for (const s of this.listeners)
                s.onInitialDomDone && s.onInitialDomDone(t)
        }
        emitRecordingStatusChange() {
            for (const t of this.listeners)
                t.onRecordingStatusChange && t.onRecordingStatusChange()
        }
        emitBeforeVisitorRenewal() {
            for (const t of this.listeners)
                t.onBeforeVisitorRenewal && t.onBeforeVisitorRenewal()
        }
        emitAfterVisitorCleared() {
            for (const t of this.listeners)
                t.onAfterVisitorCleared && t.onAfterVisitorCleared()
        }
        emitAfterVisitorRenewal() {
            for (const t of this.listeners)
                t.onAfterVisitorRenewal && t.onAfterVisitorRenewal()
        }
    }
    ss([$s("emitStartTracking")], Jo.prototype, "emitStartTracking", null)
    const Xo = "_cs_c"
    var tc
    !(function (t) {
        ;(t[(t.NOT_REQUIRED = 0)] = "NOT_REQUIRED"),
            (t[(t.NOT_EXPRESSED = 1)] = "NOT_EXPRESSED"),
            (t[(t.GRANTED = 2)] = "GRANTED"),
            (t[(t.WITHDRAWN = 3)] = "WITHDRAWN")
    })(tc || (tc = {}))
    class sc {
        constructor(t, s, i) {
            ;(this.$ = t), (this.dp = s), (this.Gp = i)
        }
        get() {
            let t
            return (
                (t = this.$.cookielessTrackingEnabled
                    ? this.Gp.getItem(Xo)
                    : this.dp.get(Xo)),
                null === t ? t : Number(t)
            )
        }
        set(t) {
            this.$.cookielessTrackingEnabled
                ? this.Gp.setItem(Xo, csString(t))
                : this.dp.set(Xo, csString(t), K)
        }
        remove() {
            this.$.cookielessTrackingEnabled
                ? this.Gp.removeItem(Xo)
                : this.dp.delete(Xo)
        }
        handleSubdomainChange() {
            this.$.cookielessTrackingEnabled ||
                (this.$.allowSubdomains
                    ? this.dp.delete(Xo, hs.CURRENT_DOMAIN)
                    : this.dp.delete(Xo, this.dp.getRootDomain()))
        }
    }
    class ic {
        constructor(t, s, i) {
            ;(this.$ = t), (this.W = s), (this.Ls = i)
        }
        grantReplayConsent() {
            if (!Ln.isReplayConsentNeeded(this.$)) return
            const t = this.W.getSession()
            t
                ? Ln.isRecordingBlockedByConsent(t) &&
                  (this.W.grantReplayRecording(t),
                  this.Ls.emitAfterReplayRecordingConsentGranted())
                : this.W.grantReplayRecordingBeforeSessionStart()
        }
        withdrawReplayConsent() {
            if (!Ln.isReplayConsentNeeded(this.$)) return
            const t = this.W.getSession()
            t
                ? Ln.isRecordingWithDrawn(t) ||
                  (this.W.withdrawnReplayRecording(t),
                  this.Ls.emitAfterReplayRecordingConsentWithdrawn())
                : this.W.withdrawnReplayRecordingBeforeSessionStart()
        }
    }
    const ec = ["replay:consent:unanonymized:granted", "trackConsentGranted"],
        nc = ["replay:consent:unanonymized:withdrawn", "trackConsentWithdrawn"],
        rc = ["replay:consent:startForSession:granted"],
        hc = ["replay:consent:startForSession:withdrawn"]
    class oc {
        constructor(t, s, i, e, n) {
            ;(this.$ = t),
                (this.Wc = s),
                (this.Hh = i),
                (this.W = e),
                (this.Ls = n)
        }
        init() {
            ;(this.Zp = new ic(this.$, this.W, this.Ls)),
                this.Hh.setInitialConsent(),
                this.Wp()
        }
        Wp() {
            this.Wc.register(ec, () => {
                this.Hh.grantReplayAnonymizationConsent()
            }),
                this.Wc.register(nc, () => {
                    this.Hh.withdrawReplayAnonymizationConsent()
                }),
                this.Wc.register(rc, () => {
                    this.Zp.grantReplayConsent()
                }),
                this.Wc.register(hc, () => {
                    this.Zp.withdrawReplayConsent()
                })
        }
        onOptout() {
            this.Hh.removeAllConsents()
        }
        onBeforeVisitorRenewal() {
            this.Hh.removeAllConsents()
        }
        onAfterVisitorRenewal() {
            this.Hh.setInitialConsent()
        }
        onAfterVisitorCleared() {
            this.Hh.setInitialConsent()
        }
    }
    class cc {
        constructor(t, s, i) {
            ;(this.$ = t), (this.np = s), (this.Ls = i)
        }
        setInitialConsent() {
            const t = this.np.get()
            ;(null === t || this.hasConsentRequiredChanged(t)) &&
                this.setDefaultReplayAnonymization()
        }
        hasConsentRequiredChanged(t) {
            const s = this.$.consentRequired
            return (s && t === tc.NOT_REQUIRED) || (!s && t !== tc.NOT_REQUIRED)
        }
        handleSubdomainChange() {
            this.np.handleSubdomainChange()
        }
        setDefaultReplayAnonymization() {
            const t = this.$.consentRequired
                ? tc.NOT_EXPRESSED
                : tc.NOT_REQUIRED
            this.np.set(t)
        }
        grantReplayAnonymizationConsent() {
            this.$.consentRequired &&
                (this.np.set(tc.GRANTED),
                this.Ls.emitReplayUnanonymizationConsentGranted())
        }
        withdrawReplayAnonymizationConsent() {
            this.$.consentRequired &&
                (this.np.set(tc.WITHDRAWN),
                this.Ls.emitReplayUnanonymizationConsentWithdrawn())
        }
        removeAllConsents() {
            this.np.remove()
        }
        isReplayUnanonymizedAllowedByConsent() {
            return !this.$.consentRequired || this.np.get() === tc.GRANTED
        }
        getRequestParameters() {
            return { uc: `${this.np.get()}` }
        }
    }
    class ac {
        constructor(t, s, i, e, n, r, h) {
            ;(this.Ls = t),
                (this.Wc = s),
                (this.zw = i),
                (this.Fw = e),
                (this.Bw = n),
                (this.Kp = r),
                (this.Hw = h)
        }
        start() {
            this.Ls.addListener(this.Kp),
                this.Ls.addListener(this.Hw),
                this.Ls.addListener(this.zw),
                this.Hw.init(),
                this.Fw.init(),
                this.Bw.init(),
                this.Bw.isActive() || this.Wc.start()
        }
    }
    const uc = "_cs_ex",
        lc = 2592e6,
        dc = /^[0-9]+$/
    class fc {
        constructor(t, s, i) {
            ;(this.$ = t), (this.dp = s), (this.fp = i)
        }
        onCookieToSet(t) {
            this.gp = t
        }
        onCookieToRemove(t) {
            this.vp = t
        }
        get() {
            return this.$.cookielessTrackingEnabled
                ? Number(this.fp.getItem(uc))
                : Number(this.dp.get(uc))
        }
        set(t) {
            var s
            this.$.cookielessTrackingEnabled
                ? this.fp.setItem(uc, t)
                : (this.dp.set(uc, t, lc),
                  null === (s = this.gp) ||
                      void 0 === s ||
                      s.call(this, uc, t, lc))
        }
        remove() {
            var t
            this.$.cookielessTrackingEnabled
                ? this.fp.removeItem(uc)
                : (this.dp.delete(uc),
                  null === (t = this.vp) || void 0 === t || t.call(this, uc))
        }
        static isValidExclusionString(t) {
            return dc.test(t)
        }
    }
    class wc {
        constructor(t, s) {
            ;(this.Vn = t), (this.np = s)
        }
        exclude(t) {
            this.np.set(csString(t.lastTrackingDraw))
        }
        removeExclusion() {
            this.np.remove()
        }
        isExcluded() {
            return this.Yp() || this.Qp()
        }
        Yp() {
            return 0 !== this.getAppliedTrackingDraw()
        }
        getAppliedTrackingDraw() {
            return this.np.get()
        }
        Qp() {
            return csString.prototype.indexOf.call(this.Vn.href, uc) > 0
        }
    }
    class pc {
        constructor(t) {
            this.Ua = t
        }
        onOptout() {
            this.Ua.removeExclusion()
        }
    }
    var mc
    !(function (t) {
        ;(t.SessionReplay = "SR"), (t.None = "")
    })(mc || (mc = {}))
    class Ec {
        constructor(t) {
            ;(this.X = t), (this.Jp = new RegExp(".^"))
        }
        setExcludeUrlForSessionReplay(t) {
            this.Jp = new RegExp(t)
        }
        Xp() {
            return this.Jp.test(this.X.getAnonymizedUrl())
                ? mc.SessionReplay
                : mc.None
        }
        isUrlExcludedForSessionReplay() {
            return this.Xp() === mc.SessionReplay
        }
        getRequestParameters() {
            return { ex: this.Xp() }
        }
    }
    const yc = ["excludeURLforReplay"]
    class Ac {
        constructor(t, s) {
            ;(this.Ua = t), (this.Wc = s)
        }
        init() {
            this.Wc.register(yc, (t) => {
                _t(t) && this.Ua.setExcludeUrlForSessionReplay(t)
            })
        }
    }
    const gc = "_cs_inc"
    class vc {
        constructor(t, s) {
            ;(this.Vn = t), (this.dp = s)
        }
        isForceIncluded() {
            return this.tm() || this.sm()
        }
        isForceReplayRecorded() {
            return this.im(ii.GLOBAL_SAMPLING)
        }
        tm() {
            return null !== this.dp.get(gc)
        }
        im(t) {
            return this.dp.get(gc) === t
        }
        sm() {
            return csString.prototype.indexOf.call(this.Vn.href, gc) > 0
        }
    }
    const _c = "_cs_optout"
    class Rc {
        constructor(t, s, i) {
            ;(this.$ = t), (this.dp = s), (this.Gp = i)
        }
        get() {
            return this.$.cookielessTrackingEnabled
                ? this.Gp.getItem(_c)
                : this.dp.get(_c)
        }
        set(t) {
            this.$.cookielessTrackingEnabled
                ? this.Gp.setItem(_c, t)
                : this.dp.set(_c, t, K)
        }
    }
    class Sc {
        constructor(t, s, i) {
            ;(this.Ls = t), (this.Vn = s), (this.np = i)
        }
        init() {
            !this.isActive() && this.nm() && this.activate()
        }
        isActive() {
            return "1" === this.np.get()
        }
        activate() {
            this.Ls.emitOptout(), this.np.set("1")
        }
        nm() {
            return csString.prototype.indexOf.call(this.Vn.href, _c) > 0
        }
    }
    const Tc = ["optout"]
    class Ic {
        constructor(t, s) {
            ;(this.Wc = t), (this.Bw = s)
        }
        init() {
            this.Wc.register(Tc, () => {
                this.Bw.activate()
            })
        }
    }
    class Pc {
        constructor(t, s) {
            ;(this.Wc = t), (this.Ca = s)
        }
        init() {
            this.Ca.addListener(this.Wc)
        }
        onOptout() {
            this.Wc.stop()
        }
        onBeforeSessionRenewal() {
            this.Wc.stop()
        }
    }
    var bc
    !(function (t) {
        ;(t.UXA = "_uxa"), (t.WVT = "cs_wvt")
    })(bc || (bc = {}))
    class Vc extends si {
        constructor(t) {
            super(), (this.rm = t), (this.hm = {})
        }
        register(t, s, i) {
            for (const e of t)
                (this.hm[e] = { callback: s, configuration: i }), this.hm
        }
        onStart() {
            this.om(), this.am()
        }
        onStop() {
            for (const t of this.rm) window[t] = []
        }
        applyFromIntegration(t, s, i) {
            this.isStarted
                ? Jt.tryToExecute(
                      `Commands.apply.from.integration: ${i}`,
                      () => {
                          if (this.hm[t]) return this.hm[t].callback(...s)
                      }
                  )()
                : window._uxa.push([t, ...s])
        }
        onIframeCommands(t) {
            for (const s of t.commands) this.um(s.name, s.params, t.iframePath)
        }
        um(t, s, i) {
            Jt.tryToExecute(`Commands.apply.from.iframe: ${i}`, () => {
                if (this.hm[t]) return this.hm[t].callback(...s)
            })()
        }
        om() {
            for (const t of this.rm)
                window[t].forEach(([t, ...s]) => this.lm(t, s, !1))
        }
        am() {
            for (const t of this.rm)
                window[t] = { push: ([t, ...s]) => this.lm(t, s, !0) }
        }
        lm(t, s, i) {
            var e, n
            if (this.hm[t]) {
                if (
                    ((null === (e = this.hm[t].configuration) || void 0 === e
                        ? void 0
                        : e.disableApplyPending) &&
                        !i) ||
                    ((null === (n = this.hm[t].configuration) || void 0 === n
                        ? void 0
                        : n.disableApplyImmediate) &&
                        i)
                )
                    return
                try {
                    return this.hm[t].callback(...s)
                } catch (i) {
                    Jt.error(
                        `Command ${t} failed - params: ${csJSON.stringify(s)}`,
                        i
                    )
                }
            }
        }
    }
    class Cc {
        constructor(t, s, i, e) {
            ;(this.$ = t), (this.Z = s), (this.W = i), (this.dm = e)
        }
        getRequestParameters() {
            var t
            const s = { ...wt(), ...this.$.getRequestParameters() },
                i = this.W.getSession()
            i && (s.pn = `${i.pageNumber}`)
            const e = this.Z.getVisitor()
            return (
                e && ((s.sn = `${e.visitsCount}`), (s.uu = `${e.id}`)),
                (null === (t = this.dm) || void 0 === t
                    ? void 0
                    : t.hasSubProjectId()) &&
                    (s.subProjectID = `${this.dm.getSubProjectId()}`),
                s
            )
        }
    }
    class Nc {
        constructor(t, s) {
            ;(this.Wc = t), (this.V = s)
        }
        init() {
            this.Wc.register(["debugEvents"], (t) => {
                "boolean" == typeof t &&
                    this.V.updateDynamicFields("emitDebugEvents", t)
            })
        }
    }
    function Oc(t, s, i) {
        if (!St(s) && !St(i)) return t.href
        const e = St(s)
                ? (function (t) {
                      return W(t, "/") ? t : `/${t}`
                  })(s)
                : t.pathname,
            n = St(i)
                ? (function (t) {
                      return W(t, "?") || "" === t ? t : `?${t}`
                  })(i)
                : t.search
        return `${t.protocol}//${t.host}${e}${n}`
    }
    class kc {
        constructor(t, s) {
            ;(this.Vn = t), (this.Xc = s)
        }
        overridePath(t) {
            St(t) && _t(t) && (this.fm = "" === t ? void 0 : t)
        }
        overrideQuery(t) {
            St(t) && _t(t) && (this.wm = t)
        }
        computeOverriddenUrl(t) {
            return this.pm(t) ? this.getAnonymizedUrl() : t
        }
        pm(t) {
            const s = this.Em(this.Vn.href)
            return this.Em(t) === s
        }
        Em(t) {
            return (
                (s = t),
                (i = "/"),
                -1 !==
                csString.prototype.indexOf.call(s, i, s.length - i.length)
                    ? csString.prototype.slice.call(t, 0, -1)
                    : t
            )
            var s, i
        }
        getAnonymizedUrl() {
            const t = Oc(this.Vn, this.fm, this.wm)
            return this.Xc.anonymizeUrl(t, [])
        }
        getUrlProtocol() {
            return this.Vn.protocol
        }
        getRequestParameters() {
            return { url: this.getAnonymizedUrl() }
        }
    }
    class $c extends Qo {
        emitPageEvent(t) {
            for (const s of this.listeners) s.onPageEvent && s.onPageEvent(t)
        }
        emitEventTriggerRecording(t, s) {
            for (const i of this.listeners)
                i.onEventTriggerRecording && i.onEventTriggerRecording(t, s)
        }
        emitCustomJavaScriptErrorEvent(t) {
            for (const s of this.listeners)
                s.onCustomJavaScriptErrorEvent &&
                    s.onCustomJavaScriptErrorEvent(t)
        }
        emitCustomErrorEvent(t) {
            for (const s of this.listeners)
                s.onCustomErrorEvent && s.onCustomErrorEvent(t)
        }
        emitUserIdentifierEvent(t) {
            for (const s of this.listeners)
                s.onUserIdentifierEvent && s.onUserIdentifierEvent(t)
        }
    }
    class Lc {
        constructor(t, s, i, e, n) {
            ;(this.configuration = t),
                (this.ym = s),
                (this.Ls = i),
                (this.sp = e),
                (this.X = n),
                (this.Am = [])
        }
        init() {
            this.gm()
        }
        sanitizeSessionRecordingState(t) {
            return (
                t.recordingState === ii.TEMPORARILY_RECORDED &&
                    (t.recordingState = ii.NOT_RECORDED),
                t
            )
        }
        computeInitialRecordingState(t) {
            return Ln.isReplayConsentNeeded(this.configuration)
                ? ii.BLOCKED_BY_CONSENT_NOT_EXPRESSED
                : this.xp(t)
        }
        computeInitialRecordingStateFromRecordingConsentGranted(t) {
            return this.xp(t)
        }
        xp(t) {
            return ln.isRecordingSupported()
                ? ((this.Am = []),
                  Y.percentage() < this.configuration.replayRecordingRate ||
                  this.sp.isForceReplayRecorded()
                      ? csArray.prototype.push.call(this.Am, ii.GLOBAL_SAMPLING)
                      : this.configuration.malkaUrlEnabled &&
                        csArray.prototype.push.call(this.Am, ii.URL_SAMPLING),
                  this.configuration.malkaEtrEnabled &&
                      csArray.prototype.push.call(this.Am, ii.ETR_SAMPLING),
                  this.Am.length > 0
                      ? (this.vm(t), ii.TEMPORARILY_RECORDED)
                      : ii.NOT_RECORDED)
                : ii.NOT_RECORDED
        }
        updateRecordingState(t) {
            return ln.isRecordingSupported()
                ? Ln.isRecordingBlockedByConsent(t)
                    ? t.recordingState === ii.BLOCKED_BY_CONSENT_WITHDRAWN
                        ? ii.BLOCKED_BY_CONSENT_WITHDRAWN
                        : ii.BLOCKED_BY_CONSENT_NOT_EXPRESSED
                    : t.recordingState === ii.GLOBAL_SAMPLING
                    ? ii.GLOBAL_SAMPLING
                    : ((this.Am = []),
                      this.configuration.malkaUrlEnabled &&
                          (csArray.prototype.push.call(
                              this.Am,
                              ii.URL_SAMPLING
                          ),
                          this.configuration.malkaEtrEnabled &&
                              csArray.prototype.push.call(
                                  this.Am,
                                  ii.ETR_SAMPLING
                              )),
                      this.Am.length > 0
                          ? (this.vm(t), ii.TEMPORARILY_RECORDED)
                          : ii.NOT_RECORDED)
                : ii.NOT_RECORDED
        }
        vm(t) {
            var s
            const i =
                null === (s = this.Z) || void 0 === s ? void 0 : s.getVisitor()
            this.ym.send({
                recordingTypes: csArray.prototype.map.call(this.Am, Number),
                url: this.X.getAnonymizedUrl(),
                projectId: this.configuration.projectId,
                uu: (null == i ? void 0 : i.id) || "",
                sn: (null == i ? void 0 : i.visitsCount) || "",
                pn: (null == t ? void 0 : t.pageNumber) || "",
            })
        }
        abortQuotaServiceRequest() {
            this.ym.abort()
        }
        isReplayRecorded(t) {
            return (
                !Ln.isRecordingBlockedByConsent(t) &&
                (t.recordingState === ii.TEMPORARILY_RECORDED ||
                    t.recordingState === ii.GLOBAL_SAMPLING ||
                    t.recordingState === ii.URL_SAMPLING ||
                    t.etrState === ei.ETR_ON)
            )
        }
        gm() {
            this.ym.onError(() =>
                this.quotaServiceErrorHandler("NetworkError")
            ),
                this.ym.onTimeout(() => this.quotaServiceTimeoutHandler(), 3e3),
                this.ym.onLoad((t) => this.quotaServiceLoadHandler(t))
        }
        quotaServiceErrorHandler(t) {
            this._m(`error - ${t}`)
        }
        quotaServiceTimeoutHandler() {
            this._m("timeout")
        }
        _m(t) {
            let s = ii.NOT_RECORDED
            this.Rm(this.Am)
                ? ((s = ii.GLOBAL_SAMPLING),
                  Jt.warn(
                      `Quota Service: request ${t} - bypassed by GLOBAL_SAMPLING`
                  ))
                : Jt.warn(`Quota Service: request ${t}`),
                this.Ls.emitRecordingStateChange(s, ei.ETR_OFF)
        }
        quotaServiceLoadHandler(t) {
            if (200 !== t.status)
                return void this.quotaServiceErrorHandler(
                    `Status code: ${t.status}`
                )
            let s
            try {
                s = csJSON.parse(t.responseText)
            } catch (s) {
                return void this.quotaServiceErrorHandler(
                    `Unable to parse the quota service response: ${t.responseText}`
                )
            }
            const i =
                null == s.allowedRecordingTypes
                    ? void 0
                    : csArray.prototype.map.call(
                          s.allowedRecordingTypes,
                          csString
                      )
            if (!i)
                return void this.quotaServiceErrorHandler(
                    "recording types missing from quota service response"
                )
            let e = ei.ETR_OFF,
                n = ii.NOT_RECORDED
            this.Rm(i)
                ? (n = ii.GLOBAL_SAMPLING)
                : this.Sm(i) && (n = ii.URL_SAMPLING),
                this.Tm(i) && (e = ei.ETR_ON),
                this.Ls.emitRecordingStateChange(n, e)
        }
        Rm(t) {
            return csArray.prototype.some.call(
                t,
                (t) => t === ii.GLOBAL_SAMPLING
            )
        }
        Sm(t) {
            return csArray.prototype.some.call(t, (t) => t === ii.URL_SAMPLING)
        }
        Tm(t) {
            return csArray.prototype.some.call(t, (t) => t === ii.ETR_SAMPLING)
        }
        setVisitorService(t) {
            this.Z = t
        }
        getDisabledRecordingState() {
            return ii.NOT_RECORDED
        }
        getConsentWithdrawnRecordingState() {
            return ii.BLOCKED_BY_CONSENT_WITHDRAWN
        }
    }
    ss(
        [ts("Quota Service: onerror")],
        Lc.prototype,
        "quotaServiceErrorHandler",
        null
    ),
        ss(
            [ts("Quota Service: ontimeout")],
            Lc.prototype,
            "quotaServiceTimeoutHandler",
            null
        ),
        ss(
            [ts("Quota Service: onload")],
            Lc.prototype,
            "quotaServiceLoadHandler",
            null
        )
    const xc = "|iframe|"
    class Mc extends Qo {
        constructor(t, s, i, e) {
            super(), (this.Im = t), (this.Pm = s), (this.bm = i), (this.Vm = e)
        }
        emitIframeEvent(t, s, i) {
            if (this.Cm(s) && null === t)
                Jt.error(
                    `iframeEventEmitter received event ${s} with null iframe, content:${csJSON.stringify(
                        i
                    )}`
                )
            else
                switch (s) {
                    case Zt.ChildLogMessage:
                        this.Nm(i)
                        break
                    case Zt.AnalysisEvent: {
                        const s = this.Im.transformEvent(t, i)
                        this.Om(s)
                        break
                    }
                    case Zt.RecordingEvent: {
                        const s = i,
                            e = this.Vm.transformEvents(t, s)
                        if (0 === e.events.length) return
                        e.containsUserEvent
                            ? this.km(e.events)
                            : this.$m(e.events)
                        break
                    }
                    case Zt.JavascriptError:
                        this.Lm(i)
                        break
                    case Zt.ApiError:
                        this.xm(i)
                        break
                    case Zt.DetailedApiError:
                        this.Mm(i)
                        break
                    case Zt.CustomError:
                        this.Dm(i)
                        break
                    case Zt.EmerchandisingMessage: {
                        const s = this.bm.transformEvent(t, i)
                        this.Um(s)
                        break
                    }
                    case Zt.Commands: {
                        const s = this.Pm.transformEvent(t, i)
                        this.zm(s)
                        break
                    }
                    case Zt.IntegrationCallback:
                        this.Fm(i)
                        break
                    case Zt.StaticResource:
                        this.Bm(i)
                        break
                    case Zt.TrackingContextRequestMessage:
                        this.Hm(i)
                        break
                    default:
                        Jt.error(
                            `Parent received unknown data type from iframe : ${csJSON.stringify(
                                i
                            )}`
                        )
                }
        }
        Cm(t) {
            const s = [
                Zt.AnalysisEvent,
                Zt.RecordingEvent,
                Zt.EmerchandisingMessage,
                Zt.Commands,
            ]
            return -1 !== csArray.prototype.indexOf.call(s, t)
        }
        Nm(t) {
            const { message: s, errorCode: i, level: e } = t
            switch (e) {
                case st.debug:
                    Jt.debug(s, i)
                    break
                case st.warn:
                    Jt.warn(s, i)
                    break
                case st.error:
                    Jt.error(s, i)
                    break
                case st.critical:
                    Jt.critical(s, i)
            }
        }
        Om(t) {
            for (const s of this.listeners)
                s.onIframeAnalysisEvent && s.onIframeAnalysisEvent(t)
        }
        km(t) {
            for (const s of this.listeners)
                s.onIframeRecordingUserEvent && s.onIframeRecordingUserEvent(t)
        }
        $m(t) {
            for (const s of this.listeners)
                s.onIframeRecordingBrowserEvent &&
                    s.onIframeRecordingBrowserEvent(t)
        }
        Lm(t) {
            for (const s of this.listeners)
                s.onIframeJavascriptError && s.onIframeJavascriptError(t)
        }
        xm(t) {
            for (const s of this.listeners)
                s.onIframeApiError && s.onIframeApiError(t)
        }
        Mm(t) {
            for (const s of this.listeners)
                s.onIframeDetailedApiError && s.onIframeDetailedApiError(t)
        }
        Um(t) {
            for (const s of this.listeners)
                s.onIframeEmerchandisingMessage &&
                    s.onIframeEmerchandisingMessage(t)
        }
        zm(t) {
            for (const s of this.listeners)
                s.onIframeCommands && s.onIframeCommands(t)
        }
        Fm(t) {
            for (const s of this.listeners)
                s.onIframeIntegrationCallback &&
                    s.onIframeIntegrationCallback(t)
        }
        Bm(t) {
            for (const s of this.listeners)
                s.onIframeStaticResource && s.onIframeStaticResource(t)
        }
        Hm(t) {
            for (const s of this.listeners)
                s.onTrackingContextRequestCallback &&
                    s.onTrackingContextRequestCallback(t)
        }
        Dm(t) {
            for (const s of this.listeners)
                s.onIframeCustomError && s.onIframeCustomError(t)
        }
    }
    var Dc
    !(function (t) {
        t.COMPRESSION_DISABLED = "compressionDisabled"
    })(Dc || (Dc = {}))
    class Uc {
        constructor() {}
        static init(t = document.cookie) {
            var s
            const i =
                null === (s = /_cs_debug=((\w|\.|\:|=)+)/g.exec(t)) ||
                void 0 === s
                    ? void 0
                    : s[1]
            if (((this.qm = new Map()), i)) {
                const t = csString.prototype.split.call(i, ".")
                for (let s = 0; s < t.length; s++) {
                    const [i, e] = csString.prototype.split.call(t[s], "=")
                    this.qm.set(i, e || "true")
                }
            }
        }
        static getBoolean(t) {
            const s = this.getString(t)
            return null != s && "false" !== s && 0 !== parseInt(s)
        }
        static getString(t) {
            var s
            return null === (s = this.qm) || void 0 === s ? void 0 : s.get(t)
        }
        static isCompressionEnabled() {
            return !this.getBoolean(Dc.COMPRESSION_DISABLED)
        }
        static Log(t) {
            return (s, i, e) => {
                var n
                const r = i.toString(),
                    h = `${
                        null === (n = s.constructor) || void 0 === n
                            ? void 0
                            : n.name
                    }.${r}`,
                    o = e.value
                ;(function (t, s) {
                    var i
                    if (null == t) return !1
                    return (
                        t === s ||
                        !!(null ===
                            (i = csString.prototype.match.call(
                                t,
                                new RegExp("(^|,)(" + s + ")(,|$)")
                            )) || void 0 === i
                            ? void 0
                            : i.length)
                    )
                })(Uc.getString("debugLog"), t) &&
                    (e.value = function (...t) {
                        return console.log(h, ...t), o.bind(this)(...t)
                    })
            }
        }
    }
    function zc() {
        function t(t) {
            let s = t.length
            for (; --s >= 0; ) t[s] = 0
        }
        const s = 256,
            i = 286,
            e = 30,
            n = 15,
            r = new Uint8Array([
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                1,
                1,
                1,
                2,
                2,
                2,
                2,
                3,
                3,
                3,
                3,
                4,
                4,
                4,
                4,
                5,
                5,
                5,
                5,
                0,
            ]),
            h = new Uint8Array([
                0,
                0,
                0,
                0,
                1,
                1,
                2,
                2,
                3,
                3,
                4,
                4,
                5,
                5,
                6,
                6,
                7,
                7,
                8,
                8,
                9,
                9,
                10,
                10,
                11,
                11,
                12,
                12,
                13,
                13,
            ]),
            o = new Uint8Array([
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                3,
                7,
            ]),
            c = new Uint8Array([
                16,
                17,
                18,
                0,
                8,
                7,
                9,
                6,
                10,
                5,
                11,
                4,
                12,
                3,
                13,
                2,
                14,
                1,
                15,
            ]),
            a = new Array(576)
        t(a)
        const u = new Array(60)
        t(u)
        const l = new Array(512)
        t(l)
        const d = new Array(256)
        t(d)
        const f = new Array(29)
        t(f)
        const w = new Array(e)
        function p(t, s, i, e, n) {
            ;(this.static_tree = t),
                (this.extra_bits = s),
                (this.extra_base = i),
                (this.elems = e),
                (this.max_length = n),
                (this.has_stree = t && t.length)
        }
        let m, E, y
        function A(t, s) {
            ;(this.dyn_tree = t), (this.max_code = 0), (this.stat_desc = s)
        }
        t(w)
        const g = (t) => (t < 256 ? l[t] : l[256 + (t >>> 7)]),
            v = (t, s) => {
                ;(t.pending_buf[t.pending++] = 255 & s),
                    (t.pending_buf[t.pending++] = (s >>> 8) & 255)
            },
            _ = (t, s, i) => {
                t.bi_valid > 16 - i
                    ? ((t.bi_buf |= (s << t.bi_valid) & 65535),
                      v(t, t.bi_buf),
                      (t.bi_buf = s >> (16 - t.bi_valid)),
                      (t.bi_valid += i - 16))
                    : ((t.bi_buf |= (s << t.bi_valid) & 65535),
                      (t.bi_valid += i))
            },
            R = (t, s, i) => {
                _(t, i[2 * s], i[2 * s + 1])
            },
            S = (t, s) => {
                let i = 0
                do {
                    ;(i |= 1 & t), (t >>>= 1), (i <<= 1)
                } while (--s > 0)
                return i >>> 1
            },
            T = (t, s, i) => {
                const e = new Array(16)
                let r,
                    h,
                    o = 0
                for (r = 1; r <= n; r++) e[r] = o = (o + i[r - 1]) << 1
                for (h = 0; h <= s; h++) {
                    let s = t[2 * h + 1]
                    0 !== s && (t[2 * h] = S(e[s]++, s))
                }
            },
            I = (t) => {
                let s
                for (s = 0; s < i; s++) t.dyn_ltree[2 * s] = 0
                for (s = 0; s < e; s++) t.dyn_dtree[2 * s] = 0
                for (s = 0; s < 19; s++) t.bl_tree[2 * s] = 0
                ;(t.dyn_ltree[512] = 1),
                    (t.opt_len = t.static_len = 0),
                    (t.last_lit = t.matches = 0)
            },
            P = (t) => {
                t.bi_valid > 8
                    ? v(t, t.bi_buf)
                    : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf),
                    (t.bi_buf = 0),
                    (t.bi_valid = 0)
            },
            b = (t, s, i, e) => {
                const n = 2 * s,
                    r = 2 * i
                return t[n] < t[r] || (t[n] === t[r] && e[s] <= e[i])
            },
            V = (t, s, i) => {
                const e = t.heap[i]
                let n = i << 1
                for (
                    ;
                    n <= t.heap_len &&
                    (n < t.heap_len &&
                        b(s, t.heap[n + 1], t.heap[n], t.depth) &&
                        n++,
                    !b(s, e, t.heap[n], t.depth));

                )
                    (t.heap[i] = t.heap[n]), (i = n), (n <<= 1)
                t.heap[i] = e
            },
            C = (t, i, e) => {
                let n,
                    o,
                    c,
                    a,
                    u = 0
                if (0 !== t.last_lit)
                    do {
                        ;(n =
                            (t.pending_buf[t.d_buf + 2 * u] << 8) |
                            t.pending_buf[t.d_buf + 2 * u + 1]),
                            (o = t.pending_buf[t.l_buf + u]),
                            u++,
                            0 === n
                                ? R(t, o, i)
                                : ((c = d[o]),
                                  R(t, c + s + 1, i),
                                  (a = r[c]),
                                  0 !== a && ((o -= f[c]), _(t, o, a)),
                                  n--,
                                  (c = g(n)),
                                  R(t, c, e),
                                  (a = h[c]),
                                  0 !== a && ((n -= w[c]), _(t, n, a)))
                    } while (u < t.last_lit)
                R(t, 256, i)
            },
            N = (t, s) => {
                const i = s.dyn_tree,
                    e = s.stat_desc.static_tree,
                    r = s.stat_desc.has_stree,
                    h = s.stat_desc.elems
                let o,
                    c,
                    a,
                    u = -1
                for (t.heap_len = 0, t.heap_max = 573, o = 0; o < h; o++)
                    0 !== i[2 * o]
                        ? ((t.heap[++t.heap_len] = u = o), (t.depth[o] = 0))
                        : (i[2 * o + 1] = 0)
                for (; t.heap_len < 2; )
                    (a = t.heap[++t.heap_len] = u < 2 ? ++u : 0),
                        (i[2 * a] = 1),
                        (t.depth[a] = 0),
                        t.opt_len--,
                        r && (t.static_len -= e[2 * a + 1])
                for (s.max_code = u, o = t.heap_len >> 1; o >= 1; o--)
                    V(t, i, o)
                a = h
                do {
                    ;(o = t.heap[1]),
                        (t.heap[1] = t.heap[t.heap_len--]),
                        V(t, i, 1),
                        (c = t.heap[1]),
                        (t.heap[--t.heap_max] = o),
                        (t.heap[--t.heap_max] = c),
                        (i[2 * a] = i[2 * o] + i[2 * c]),
                        (t.depth[a] =
                            (t.depth[o] >= t.depth[c]
                                ? t.depth[o]
                                : t.depth[c]) + 1),
                        (i[2 * o + 1] = i[2 * c + 1] = a),
                        (t.heap[1] = a++),
                        V(t, i, 1)
                } while (t.heap_len >= 2)
                ;(t.heap[--t.heap_max] = t.heap[1]),
                    ((t, s) => {
                        const i = s.dyn_tree,
                            e = s.max_code,
                            r = s.stat_desc.static_tree,
                            h = s.stat_desc.has_stree,
                            o = s.stat_desc.extra_bits,
                            c = s.stat_desc.extra_base,
                            a = s.stat_desc.max_length
                        let u,
                            l,
                            d,
                            f,
                            w,
                            p,
                            m = 0
                        for (f = 0; f <= n; f++) t.bl_count[f] = 0
                        for (
                            i[2 * t.heap[t.heap_max] + 1] = 0,
                                u = t.heap_max + 1;
                            u < 573;
                            u++
                        )
                            (l = t.heap[u]),
                                (f = i[2 * i[2 * l + 1] + 1] + 1),
                                f > a && ((f = a), m++),
                                (i[2 * l + 1] = f),
                                l > e ||
                                    (t.bl_count[f]++,
                                    (w = 0),
                                    l >= c && (w = o[l - c]),
                                    (p = i[2 * l]),
                                    (t.opt_len += p * (f + w)),
                                    h &&
                                        (t.static_len +=
                                            p * (r[2 * l + 1] + w)))
                        if (0 !== m) {
                            do {
                                for (f = a - 1; 0 === t.bl_count[f]; ) f--
                                t.bl_count[f]--,
                                    (t.bl_count[f + 1] += 2),
                                    t.bl_count[a]--,
                                    (m -= 2)
                            } while (m > 0)
                            for (f = a; 0 !== f; f--)
                                for (l = t.bl_count[f]; 0 !== l; )
                                    (d = t.heap[--u]),
                                        d > e ||
                                            (i[2 * d + 1] !== f &&
                                                ((t.opt_len +=
                                                    (f - i[2 * d + 1]) *
                                                    i[2 * d]),
                                                (i[2 * d + 1] = f)),
                                            l--)
                        }
                    })(t, s),
                    T(i, u, t.bl_count)
            },
            O = (t, s, i) => {
                let e,
                    n,
                    r = -1,
                    h = s[1],
                    o = 0,
                    c = 7,
                    a = 4
                for (
                    0 === h && ((c = 138), (a = 3)),
                        s[2 * (i + 1) + 1] = 65535,
                        e = 0;
                    e <= i;
                    e++
                )
                    (n = h),
                        (h = s[2 * (e + 1) + 1]),
                        (++o < c && n === h) ||
                            (o < a
                                ? (t.bl_tree[2 * n] += o)
                                : 0 !== n
                                ? (n !== r && t.bl_tree[2 * n]++,
                                  t.bl_tree[32]++)
                                : o <= 10
                                ? t.bl_tree[34]++
                                : t.bl_tree[36]++,
                            (o = 0),
                            (r = n),
                            0 === h
                                ? ((c = 138), (a = 3))
                                : n === h
                                ? ((c = 6), (a = 3))
                                : ((c = 7), (a = 4)))
            },
            k = (t, s, i) => {
                let e,
                    n,
                    r = -1,
                    h = s[1],
                    o = 0,
                    c = 7,
                    a = 4
                for (0 === h && ((c = 138), (a = 3)), e = 0; e <= i; e++)
                    if (
                        ((n = h),
                        (h = s[2 * (e + 1) + 1]),
                        !(++o < c && n === h))
                    ) {
                        if (o < a)
                            do {
                                R(t, n, t.bl_tree)
                            } while (0 != --o)
                        else
                            0 !== n
                                ? (n !== r && (R(t, n, t.bl_tree), o--),
                                  R(t, 16, t.bl_tree),
                                  _(t, o - 3, 2))
                                : o <= 10
                                ? (R(t, 17, t.bl_tree), _(t, o - 3, 3))
                                : (R(t, 18, t.bl_tree), _(t, o - 11, 7))
                        ;(o = 0),
                            (r = n),
                            0 === h
                                ? ((c = 138), (a = 3))
                                : n === h
                                ? ((c = 6), (a = 3))
                                : ((c = 7), (a = 4))
                    }
            }
        let $ = !1
        const L = (t, s, i, e) => {
            _(t, 0 + (e ? 1 : 0), 3),
                ((t, s, i, e) => {
                    P(t),
                        e && (v(t, i), v(t, ~i)),
                        t.pending_buf.set(
                            t.window.subarray(s, s + i),
                            t.pending
                        ),
                        (t.pending += i)
                })(t, s, i, !0)
        }
        var x = (t) => {
                $ ||
                    ((() => {
                        let t, s, c, A, g
                        const v = new Array(16)
                        for (c = 0, A = 0; A < 28; A++)
                            for (f[A] = c, t = 0; t < 1 << r[A]; t++) d[c++] = A
                        for (d[c - 1] = A, g = 0, A = 0; A < 16; A++)
                            for (w[A] = g, t = 0; t < 1 << h[A]; t++) l[g++] = A
                        for (g >>= 7; A < e; A++)
                            for (w[A] = g << 7, t = 0; t < 1 << (h[A] - 7); t++)
                                l[256 + g++] = A
                        for (s = 0; s <= n; s++) v[s] = 0
                        for (t = 0; t <= 143; ) (a[2 * t + 1] = 8), t++, v[8]++
                        for (; t <= 255; ) (a[2 * t + 1] = 9), t++, v[9]++
                        for (; t <= 279; ) (a[2 * t + 1] = 7), t++, v[7]++
                        for (; t <= 287; ) (a[2 * t + 1] = 8), t++, v[8]++
                        for (T(a, 287, v), t = 0; t < e; t++)
                            (u[2 * t + 1] = 5), (u[2 * t] = S(t, 5))
                        ;(m = new p(a, r, 257, i, n)),
                            (E = new p(u, h, 0, e, n)),
                            (y = new p(new Array(0), o, 0, 19, 7))
                    })(),
                    ($ = !0)),
                    (t.l_desc = new A(t.dyn_ltree, m)),
                    (t.d_desc = new A(t.dyn_dtree, E)),
                    (t.bl_desc = new A(t.bl_tree, y)),
                    (t.bi_buf = 0),
                    (t.bi_valid = 0),
                    I(t)
            },
            M = (t, i, e, n) => {
                let r,
                    h,
                    o = 0
                t.level > 0
                    ? (2 === t.strm.data_type &&
                          (t.strm.data_type = ((t) => {
                              let i,
                                  e = 4093624447
                              for (i = 0; i <= 31; i++, e >>>= 1)
                                  if (1 & e && 0 !== t.dyn_ltree[2 * i])
                                      return 0
                              if (
                                  0 !== t.dyn_ltree[18] ||
                                  0 !== t.dyn_ltree[20] ||
                                  0 !== t.dyn_ltree[26]
                              )
                                  return 1
                              for (i = 32; i < s; i++)
                                  if (0 !== t.dyn_ltree[2 * i]) return 1
                              return 0
                          })(t)),
                      N(t, t.l_desc),
                      N(t, t.d_desc),
                      (o = ((t) => {
                          let s
                          for (
                              O(t, t.dyn_ltree, t.l_desc.max_code),
                                  O(t, t.dyn_dtree, t.d_desc.max_code),
                                  N(t, t.bl_desc),
                                  s = 18;
                              s >= 3 && 0 === t.bl_tree[2 * c[s] + 1];
                              s--
                          );
                          return (t.opt_len += 3 * (s + 1) + 5 + 5 + 4), s
                      })(t)),
                      (r = (t.opt_len + 3 + 7) >>> 3),
                      (h = (t.static_len + 3 + 7) >>> 3),
                      h <= r && (r = h))
                    : (r = h = e + 5),
                    e + 4 <= r && -1 !== i
                        ? L(t, i, e, n)
                        : 4 === t.strategy || h === r
                        ? (_(t, 2 + (n ? 1 : 0), 3), C(t, a, u))
                        : (_(t, 4 + (n ? 1 : 0), 3),
                          ((t, s, i, e) => {
                              let n
                              for (
                                  _(t, s - 257, 5),
                                      _(t, i - 1, 5),
                                      _(t, e - 4, 4),
                                      n = 0;
                                  n < e;
                                  n++
                              )
                                  _(t, t.bl_tree[2 * c[n] + 1], 3)
                              k(t, t.dyn_ltree, s - 1), k(t, t.dyn_dtree, i - 1)
                          })(
                              t,
                              t.l_desc.max_code + 1,
                              t.d_desc.max_code + 1,
                              o + 1
                          ),
                          C(t, t.dyn_ltree, t.dyn_dtree)),
                    I(t),
                    n && P(t)
            },
            D = (t, i, e) => (
                (t.pending_buf[t.d_buf + 2 * t.last_lit] = (i >>> 8) & 255),
                (t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & i),
                (t.pending_buf[t.l_buf + t.last_lit] = 255 & e),
                t.last_lit++,
                0 === i
                    ? t.dyn_ltree[2 * e]++
                    : (t.matches++,
                      i--,
                      t.dyn_ltree[2 * (d[e] + s + 1)]++,
                      t.dyn_dtree[2 * g(i)]++),
                t.last_lit === t.lit_bufsize - 1
            ),
            U = (t) => {
                _(t, 2, 3),
                    R(t, 256, a),
                    ((t) => {
                        16 === t.bi_valid
                            ? (v(t, t.bi_buf), (t.bi_buf = 0), (t.bi_valid = 0))
                            : t.bi_valid >= 8 &&
                              ((t.pending_buf[t.pending++] = 255 & t.bi_buf),
                              (t.bi_buf >>= 8),
                              (t.bi_valid -= 8))
                    })(t)
            },
            z = {
                _tr_init: x,
                _tr_stored_block: L,
                _tr_flush_block: M,
                _tr_tally: D,
                _tr_align: U,
            }
        var F = (t, s, i, e) => {
            let n = (65535 & t) | 0,
                r = ((t >>> 16) & 65535) | 0,
                h = 0
            for (; 0 !== i; ) {
                ;(h = i > 2e3 ? 2e3 : i), (i -= h)
                do {
                    ;(n = (n + s[e++]) | 0), (r = (r + n) | 0)
                } while (--h)
                ;(n %= 65521), (r %= 65521)
            }
            return n | (r << 16) | 0
        }
        const B = new Uint32Array(
            (() => {
                let t,
                    s = []
                for (var i = 0; i < 256; i++) {
                    t = i
                    for (var e = 0; e < 8; e++)
                        t = 1 & t ? 3988292384 ^ (t >>> 1) : t >>> 1
                    s[i] = t
                }
                return s
            })()
        )
        var H = (t, s, i, e) => {
                const n = B,
                    r = e + i
                t ^= -1
                for (let i = e; i < r; i++) t = (t >>> 8) ^ n[255 & (t ^ s[i])]
                return -1 ^ t
            },
            q = {
                2: "need dictionary",
                1: "stream end",
                0: "",
                "-1": "file error",
                "-2": "stream error",
                "-3": "data error",
                "-4": "insufficient memory",
                "-5": "buffer error",
                "-6": "incompatible version",
            },
            j = {
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_MEM_ERROR: -4,
                Z_BUF_ERROR: -5,
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                Z_BINARY: 0,
                Z_TEXT: 1,
                Z_UNKNOWN: 2,
                Z_DEFLATED: 8,
            }
        const {
                _tr_init: G,
                _tr_stored_block: Z,
                _tr_flush_block: W,
                _tr_tally: K,
                _tr_align: Y,
            } = z,
            {
                Z_NO_FLUSH: Q,
                Z_PARTIAL_FLUSH: J,
                Z_FULL_FLUSH: X,
                Z_FINISH: tt,
                Z_BLOCK: st,
                Z_OK: it,
                Z_STREAM_END: et,
                Z_STREAM_ERROR: nt,
                Z_DATA_ERROR: rt,
                Z_BUF_ERROR: ht,
                Z_DEFAULT_COMPRESSION: ot,
                Z_FILTERED: ct,
                Z_HUFFMAN_ONLY: at,
                Z_RLE: ut,
                Z_FIXED: lt,
                Z_DEFAULT_STRATEGY: dt,
                Z_UNKNOWN: ft,
                Z_DEFLATED: wt,
            } = j,
            pt = 258,
            mt = 262,
            Et = 103,
            yt = 113,
            At = 666,
            gt = (t, s) => ((t.msg = q[s]), s),
            vt = (t) => (t << 1) - (t > 4 ? 9 : 0),
            _t = (t) => {
                let s = t.length
                for (; --s >= 0; ) t[s] = 0
            }
        let Rt = (t, s, i) => ((s << t.hash_shift) ^ i) & t.hash_mask
        const St = (t) => {
                const s = t.state
                let i = s.pending
                i > t.avail_out && (i = t.avail_out),
                    0 !== i &&
                        (t.output.set(
                            s.pending_buf.subarray(
                                s.pending_out,
                                s.pending_out + i
                            ),
                            t.next_out
                        ),
                        (t.next_out += i),
                        (s.pending_out += i),
                        (t.total_out += i),
                        (t.avail_out -= i),
                        (s.pending -= i),
                        0 === s.pending && (s.pending_out = 0))
            },
            Tt = (t, s) => {
                W(
                    t,
                    t.block_start >= 0 ? t.block_start : -1,
                    t.strstart - t.block_start,
                    s
                ),
                    (t.block_start = t.strstart),
                    St(t.strm)
            },
            It = (t, s) => {
                t.pending_buf[t.pending++] = s
            },
            Pt = (t, s) => {
                ;(t.pending_buf[t.pending++] = (s >>> 8) & 255),
                    (t.pending_buf[t.pending++] = 255 & s)
            },
            bt = (t, s, i, e) => {
                let n = t.avail_in
                return (
                    n > e && (n = e),
                    0 === n
                        ? 0
                        : ((t.avail_in -= n),
                          s.set(t.input.subarray(t.next_in, t.next_in + n), i),
                          1 === t.state.wrap
                              ? (t.adler = F(t.adler, s, n, i))
                              : 2 === t.state.wrap &&
                                (t.adler = H(t.adler, s, n, i)),
                          (t.next_in += n),
                          (t.total_in += n),
                          n)
                )
            },
            Vt = (t, s) => {
                let i,
                    e,
                    n = t.max_chain_length,
                    r = t.strstart,
                    h = t.prev_length,
                    o = t.nice_match
                const c =
                        t.strstart > t.w_size - mt
                            ? t.strstart - (t.w_size - mt)
                            : 0,
                    a = t.window,
                    u = t.w_mask,
                    l = t.prev,
                    d = t.strstart + pt
                let f = a[r + h - 1],
                    w = a[r + h]
                t.prev_length >= t.good_match && (n >>= 2),
                    o > t.lookahead && (o = t.lookahead)
                do {
                    if (
                        ((i = s),
                        a[i + h] === w &&
                            a[i + h - 1] === f &&
                            a[i] === a[r] &&
                            a[++i] === a[r + 1])
                    ) {
                        ;(r += 2), i++
                        do {} while (
                            a[++r] === a[++i] &&
                            a[++r] === a[++i] &&
                            a[++r] === a[++i] &&
                            a[++r] === a[++i] &&
                            a[++r] === a[++i] &&
                            a[++r] === a[++i] &&
                            a[++r] === a[++i] &&
                            a[++r] === a[++i] &&
                            r < d
                        )
                        if (((e = pt - (d - r)), (r = d - pt), e > h)) {
                            if (((t.match_start = s), (h = e), e >= o)) break
                            ;(f = a[r + h - 1]), (w = a[r + h])
                        }
                    }
                } while ((s = l[s & u]) > c && 0 != --n)
                return h <= t.lookahead ? h : t.lookahead
            },
            Ct = (t) => {
                const s = t.w_size
                let i, e, n, r, h
                do {
                    if (
                        ((r = t.window_size - t.lookahead - t.strstart),
                        t.strstart >= s + (s - mt))
                    ) {
                        t.window.set(t.window.subarray(s, s + s), 0),
                            (t.match_start -= s),
                            (t.strstart -= s),
                            (t.block_start -= s),
                            (e = t.hash_size),
                            (i = e)
                        do {
                            ;(n = t.head[--i]), (t.head[i] = n >= s ? n - s : 0)
                        } while (--e)
                        ;(e = s), (i = e)
                        do {
                            ;(n = t.prev[--i]), (t.prev[i] = n >= s ? n - s : 0)
                        } while (--e)
                        r += s
                    }
                    if (0 === t.strm.avail_in) break
                    if (
                        ((e = bt(
                            t.strm,
                            t.window,
                            t.strstart + t.lookahead,
                            r
                        )),
                        (t.lookahead += e),
                        t.lookahead + t.insert >= 3)
                    )
                        for (
                            h = t.strstart - t.insert,
                                t.ins_h = t.window[h],
                                t.ins_h = Rt(t, t.ins_h, t.window[h + 1]);
                            t.insert &&
                            ((t.ins_h = Rt(t, t.ins_h, t.window[h + 3 - 1])),
                            (t.prev[h & t.w_mask] = t.head[t.ins_h]),
                            (t.head[t.ins_h] = h),
                            h++,
                            t.insert--,
                            !(t.lookahead + t.insert < 3));

                        );
                } while (t.lookahead < mt && 0 !== t.strm.avail_in)
            },
            Nt = (t, s) => {
                let i, e
                for (;;) {
                    if (t.lookahead < mt) {
                        if ((Ct(t), t.lookahead < mt && s === Q)) return 1
                        if (0 === t.lookahead) break
                    }
                    if (
                        ((i = 0),
                        t.lookahead >= 3 &&
                            ((t.ins_h = Rt(
                                t,
                                t.ins_h,
                                t.window[t.strstart + 3 - 1]
                            )),
                            (i = t.prev[t.strstart & t.w_mask] =
                                t.head[t.ins_h]),
                            (t.head[t.ins_h] = t.strstart)),
                        0 !== i &&
                            t.strstart - i <= t.w_size - mt &&
                            (t.match_length = Vt(t, i)),
                        t.match_length >= 3)
                    )
                        if (
                            ((e = K(
                                t,
                                t.strstart - t.match_start,
                                t.match_length - 3
                            )),
                            (t.lookahead -= t.match_length),
                            t.match_length <= t.max_lazy_match &&
                                t.lookahead >= 3)
                        ) {
                            t.match_length--
                            do {
                                t.strstart++,
                                    (t.ins_h = Rt(
                                        t,
                                        t.ins_h,
                                        t.window[t.strstart + 3 - 1]
                                    )),
                                    (i = t.prev[t.strstart & t.w_mask] =
                                        t.head[t.ins_h]),
                                    (t.head[t.ins_h] = t.strstart)
                            } while (0 != --t.match_length)
                            t.strstart++
                        } else
                            (t.strstart += t.match_length),
                                (t.match_length = 0),
                                (t.ins_h = t.window[t.strstart]),
                                (t.ins_h = Rt(
                                    t,
                                    t.ins_h,
                                    t.window[t.strstart + 1]
                                ))
                    else
                        (e = K(t, 0, t.window[t.strstart])),
                            t.lookahead--,
                            t.strstart++
                    if (e && (Tt(t, !1), 0 === t.strm.avail_out)) return 1
                }
                return (
                    (t.insert = t.strstart < 2 ? t.strstart : 2),
                    s === tt
                        ? (Tt(t, !0), 0 === t.strm.avail_out ? 3 : 4)
                        : t.last_lit && (Tt(t, !1), 0 === t.strm.avail_out)
                        ? 1
                        : 2
                )
            },
            Ot = (t, s) => {
                let i, e, n
                for (;;) {
                    if (t.lookahead < mt) {
                        if ((Ct(t), t.lookahead < mt && s === Q)) return 1
                        if (0 === t.lookahead) break
                    }
                    if (
                        ((i = 0),
                        t.lookahead >= 3 &&
                            ((t.ins_h = Rt(
                                t,
                                t.ins_h,
                                t.window[t.strstart + 3 - 1]
                            )),
                            (i = t.prev[t.strstart & t.w_mask] =
                                t.head[t.ins_h]),
                            (t.head[t.ins_h] = t.strstart)),
                        (t.prev_length = t.match_length),
                        (t.prev_match = t.match_start),
                        (t.match_length = 2),
                        0 !== i &&
                            t.prev_length < t.max_lazy_match &&
                            t.strstart - i <= t.w_size - mt &&
                            ((t.match_length = Vt(t, i)),
                            t.match_length <= 5 &&
                                (t.strategy === ct ||
                                    (3 === t.match_length &&
                                        t.strstart - t.match_start > 4096)) &&
                                (t.match_length = 2)),
                        t.prev_length >= 3 && t.match_length <= t.prev_length)
                    ) {
                        ;(n = t.strstart + t.lookahead - 3),
                            (e = K(
                                t,
                                t.strstart - 1 - t.prev_match,
                                t.prev_length - 3
                            )),
                            (t.lookahead -= t.prev_length - 1),
                            (t.prev_length -= 2)
                        do {
                            ++t.strstart <= n &&
                                ((t.ins_h = Rt(
                                    t,
                                    t.ins_h,
                                    t.window[t.strstart + 3 - 1]
                                )),
                                (i = t.prev[t.strstart & t.w_mask] =
                                    t.head[t.ins_h]),
                                (t.head[t.ins_h] = t.strstart))
                        } while (0 != --t.prev_length)
                        if (
                            ((t.match_available = 0),
                            (t.match_length = 2),
                            t.strstart++,
                            e && (Tt(t, !1), 0 === t.strm.avail_out))
                        )
                            return 1
                    } else if (t.match_available) {
                        if (
                            ((e = K(t, 0, t.window[t.strstart - 1])),
                            e && Tt(t, !1),
                            t.strstart++,
                            t.lookahead--,
                            0 === t.strm.avail_out)
                        )
                            return 1
                    } else (t.match_available = 1), t.strstart++, t.lookahead--
                }
                return (
                    t.match_available &&
                        ((e = K(t, 0, t.window[t.strstart - 1])),
                        (t.match_available = 0)),
                    (t.insert = t.strstart < 2 ? t.strstart : 2),
                    s === tt
                        ? (Tt(t, !0), 0 === t.strm.avail_out ? 3 : 4)
                        : t.last_lit && (Tt(t, !1), 0 === t.strm.avail_out)
                        ? 1
                        : 2
                )
            }
        function kt(t, s, i, e, n) {
            ;(this.good_length = t),
                (this.max_lazy = s),
                (this.nice_length = i),
                (this.max_chain = e),
                (this.func = n)
        }
        const $t = [
            new kt(0, 0, 0, 0, (t, s) => {
                let i = 65535
                for (
                    i > t.pending_buf_size - 5 && (i = t.pending_buf_size - 5);
                    ;

                ) {
                    if (t.lookahead <= 1) {
                        if ((Ct(t), 0 === t.lookahead && s === Q)) return 1
                        if (0 === t.lookahead) break
                    }
                    ;(t.strstart += t.lookahead), (t.lookahead = 0)
                    const e = t.block_start + i
                    if (
                        (0 === t.strstart || t.strstart >= e) &&
                        ((t.lookahead = t.strstart - e),
                        (t.strstart = e),
                        Tt(t, !1),
                        0 === t.strm.avail_out)
                    )
                        return 1
                    if (
                        t.strstart - t.block_start >= t.w_size - mt &&
                        (Tt(t, !1), 0 === t.strm.avail_out)
                    )
                        return 1
                }
                return (
                    (t.insert = 0),
                    s === tt
                        ? (Tt(t, !0), 0 === t.strm.avail_out ? 3 : 4)
                        : (t.strstart > t.block_start &&
                              (Tt(t, !1), t.strm.avail_out),
                          1)
                )
            }),
            new kt(4, 4, 8, 4, Nt),
            new kt(4, 5, 16, 8, Nt),
            new kt(4, 6, 32, 32, Nt),
            new kt(4, 4, 16, 16, Ot),
            new kt(8, 16, 32, 32, Ot),
            new kt(8, 16, 128, 128, Ot),
            new kt(8, 32, 128, 256, Ot),
            new kt(32, 128, 258, 1024, Ot),
            new kt(32, 258, 258, 4096, Ot),
        ]
        function Lt() {
            ;(this.strm = null),
                (this.status = 0),
                (this.pending_buf = null),
                (this.pending_buf_size = 0),
                (this.pending_out = 0),
                (this.pending = 0),
                (this.wrap = 0),
                (this.gzhead = null),
                (this.gzindex = 0),
                (this.method = wt),
                (this.last_flush = -1),
                (this.w_size = 0),
                (this.w_bits = 0),
                (this.w_mask = 0),
                (this.window = null),
                (this.window_size = 0),
                (this.prev = null),
                (this.head = null),
                (this.ins_h = 0),
                (this.hash_size = 0),
                (this.hash_bits = 0),
                (this.hash_mask = 0),
                (this.hash_shift = 0),
                (this.block_start = 0),
                (this.match_length = 0),
                (this.prev_match = 0),
                (this.match_available = 0),
                (this.strstart = 0),
                (this.match_start = 0),
                (this.lookahead = 0),
                (this.prev_length = 0),
                (this.max_chain_length = 0),
                (this.max_lazy_match = 0),
                (this.level = 0),
                (this.strategy = 0),
                (this.good_match = 0),
                (this.nice_match = 0),
                (this.dyn_ltree = new Uint16Array(1146)),
                (this.dyn_dtree = new Uint16Array(122)),
                (this.bl_tree = new Uint16Array(78)),
                _t(this.dyn_ltree),
                _t(this.dyn_dtree),
                _t(this.bl_tree),
                (this.l_desc = null),
                (this.d_desc = null),
                (this.bl_desc = null),
                (this.bl_count = new Uint16Array(16)),
                (this.heap = new Uint16Array(573)),
                _t(this.heap),
                (this.heap_len = 0),
                (this.heap_max = 0),
                (this.depth = new Uint16Array(573)),
                _t(this.depth),
                (this.l_buf = 0),
                (this.lit_bufsize = 0),
                (this.last_lit = 0),
                (this.d_buf = 0),
                (this.opt_len = 0),
                (this.static_len = 0),
                (this.matches = 0),
                (this.insert = 0),
                (this.bi_buf = 0),
                (this.bi_valid = 0)
        }
        const xt = (t) => {
                if (!t || !t.state) return gt(t, nt)
                ;(t.total_in = t.total_out = 0), (t.data_type = ft)
                const s = t.state
                return (
                    (s.pending = 0),
                    (s.pending_out = 0),
                    s.wrap < 0 && (s.wrap = -s.wrap),
                    (s.status = s.wrap ? 42 : yt),
                    (t.adler = 2 === s.wrap ? 0 : 1),
                    (s.last_flush = Q),
                    G(s),
                    it
                )
            },
            Mt = (t) => {
                const s = xt(t)
                return (
                    s === it &&
                        ((t) => {
                            ;(t.window_size = 2 * t.w_size),
                                _t(t.head),
                                (t.max_lazy_match = $t[t.level].max_lazy),
                                (t.good_match = $t[t.level].good_length),
                                (t.nice_match = $t[t.level].nice_length),
                                (t.max_chain_length = $t[t.level].max_chain),
                                (t.strstart = 0),
                                (t.block_start = 0),
                                (t.lookahead = 0),
                                (t.insert = 0),
                                (t.match_length = t.prev_length = 2),
                                (t.match_available = 0),
                                (t.ins_h = 0)
                        })(t.state),
                    s
                )
            },
            Dt = (t, s, i, e, n, r) => {
                if (!t) return nt
                let h = 1
                if (
                    (s === ot && (s = 6),
                    e < 0
                        ? ((h = 0), (e = -e))
                        : e > 15 && ((h = 2), (e -= 16)),
                    n < 1 ||
                        n > 9 ||
                        i !== wt ||
                        e < 8 ||
                        e > 15 ||
                        s < 0 ||
                        s > 9 ||
                        r < 0 ||
                        r > lt)
                )
                    return gt(t, nt)
                8 === e && (e = 9)
                const o = new Lt()
                return (
                    (t.state = o),
                    (o.strm = t),
                    (o.wrap = h),
                    (o.gzhead = null),
                    (o.w_bits = e),
                    (o.w_size = 1 << o.w_bits),
                    (o.w_mask = o.w_size - 1),
                    (o.hash_bits = n + 7),
                    (o.hash_size = 1 << o.hash_bits),
                    (o.hash_mask = o.hash_size - 1),
                    (o.hash_shift = ~~((o.hash_bits + 3 - 1) / 3)),
                    (o.window = new Uint8Array(2 * o.w_size)),
                    (o.head = new Uint16Array(o.hash_size)),
                    (o.prev = new Uint16Array(o.w_size)),
                    (o.lit_bufsize = 1 << (n + 6)),
                    (o.pending_buf_size = 4 * o.lit_bufsize),
                    (o.pending_buf = new Uint8Array(o.pending_buf_size)),
                    (o.d_buf = 1 * o.lit_bufsize),
                    (o.l_buf = 3 * o.lit_bufsize),
                    (o.level = s),
                    (o.strategy = r),
                    (o.method = i),
                    Mt(t)
                )
            }
        var Ut = (t, s) => {
                let i, e
                if (!t || !t.state || s > st || s < 0) return t ? gt(t, nt) : nt
                const n = t.state
                if (
                    !t.output ||
                    (!t.input && 0 !== t.avail_in) ||
                    (n.status === At && s !== tt)
                )
                    return gt(t, 0 === t.avail_out ? ht : nt)
                n.strm = t
                const r = n.last_flush
                if (((n.last_flush = s), 42 === n.status))
                    if (2 === n.wrap)
                        (t.adler = 0),
                            It(n, 31),
                            It(n, 139),
                            It(n, 8),
                            n.gzhead
                                ? (It(
                                      n,
                                      (n.gzhead.text ? 1 : 0) +
                                          (n.gzhead.hcrc ? 2 : 0) +
                                          (n.gzhead.extra ? 4 : 0) +
                                          (n.gzhead.name ? 8 : 0) +
                                          (n.gzhead.comment ? 16 : 0)
                                  ),
                                  It(n, 255 & n.gzhead.time),
                                  It(n, (n.gzhead.time >> 8) & 255),
                                  It(n, (n.gzhead.time >> 16) & 255),
                                  It(n, (n.gzhead.time >> 24) & 255),
                                  It(
                                      n,
                                      9 === n.level
                                          ? 2
                                          : n.strategy >= at || n.level < 2
                                          ? 4
                                          : 0
                                  ),
                                  It(n, 255 & n.gzhead.os),
                                  n.gzhead.extra &&
                                      n.gzhead.extra.length &&
                                      (It(n, 255 & n.gzhead.extra.length),
                                      It(
                                          n,
                                          (n.gzhead.extra.length >> 8) & 255
                                      )),
                                  n.gzhead.hcrc &&
                                      (t.adler = H(
                                          t.adler,
                                          n.pending_buf,
                                          n.pending,
                                          0
                                      )),
                                  (n.gzindex = 0),
                                  (n.status = 69))
                                : (It(n, 0),
                                  It(n, 0),
                                  It(n, 0),
                                  It(n, 0),
                                  It(n, 0),
                                  It(
                                      n,
                                      9 === n.level
                                          ? 2
                                          : n.strategy >= at || n.level < 2
                                          ? 4
                                          : 0
                                  ),
                                  It(n, 3),
                                  (n.status = yt))
                    else {
                        let s = (wt + ((n.w_bits - 8) << 4)) << 8,
                            i = -1
                        ;(i =
                            n.strategy >= at || n.level < 2
                                ? 0
                                : n.level < 6
                                ? 1
                                : 6 === n.level
                                ? 2
                                : 3),
                            (s |= i << 6),
                            0 !== n.strstart && (s |= 32),
                            (s += 31 - (s % 31)),
                            (n.status = yt),
                            Pt(n, s),
                            0 !== n.strstart &&
                                (Pt(n, t.adler >>> 16), Pt(n, 65535 & t.adler)),
                            (t.adler = 1)
                    }
                if (69 === n.status)
                    if (n.gzhead.extra) {
                        for (
                            i = n.pending;
                            n.gzindex < (65535 & n.gzhead.extra.length) &&
                            (n.pending !== n.pending_buf_size ||
                                (n.gzhead.hcrc &&
                                    n.pending > i &&
                                    (t.adler = H(
                                        t.adler,
                                        n.pending_buf,
                                        n.pending - i,
                                        i
                                    )),
                                St(t),
                                (i = n.pending),
                                n.pending !== n.pending_buf_size));

                        )
                            It(n, 255 & n.gzhead.extra[n.gzindex]), n.gzindex++
                        n.gzhead.hcrc &&
                            n.pending > i &&
                            (t.adler = H(
                                t.adler,
                                n.pending_buf,
                                n.pending - i,
                                i
                            )),
                            n.gzindex === n.gzhead.extra.length &&
                                ((n.gzindex = 0), (n.status = 73))
                    } else n.status = 73
                if (73 === n.status)
                    if (n.gzhead.name) {
                        i = n.pending
                        do {
                            if (
                                n.pending === n.pending_buf_size &&
                                (n.gzhead.hcrc &&
                                    n.pending > i &&
                                    (t.adler = H(
                                        t.adler,
                                        n.pending_buf,
                                        n.pending - i,
                                        i
                                    )),
                                St(t),
                                (i = n.pending),
                                n.pending === n.pending_buf_size)
                            ) {
                                e = 1
                                break
                            }
                            ;(e =
                                n.gzindex < n.gzhead.name.length
                                    ? 255 &
                                      n.gzhead.name.charCodeAt(n.gzindex++)
                                    : 0),
                                It(n, e)
                        } while (0 !== e)
                        n.gzhead.hcrc &&
                            n.pending > i &&
                            (t.adler = H(
                                t.adler,
                                n.pending_buf,
                                n.pending - i,
                                i
                            )),
                            0 === e && ((n.gzindex = 0), (n.status = 91))
                    } else n.status = 91
                if (91 === n.status)
                    if (n.gzhead.comment) {
                        i = n.pending
                        do {
                            if (
                                n.pending === n.pending_buf_size &&
                                (n.gzhead.hcrc &&
                                    n.pending > i &&
                                    (t.adler = H(
                                        t.adler,
                                        n.pending_buf,
                                        n.pending - i,
                                        i
                                    )),
                                St(t),
                                (i = n.pending),
                                n.pending === n.pending_buf_size)
                            ) {
                                e = 1
                                break
                            }
                            ;(e =
                                n.gzindex < n.gzhead.comment.length
                                    ? 255 &
                                      n.gzhead.comment.charCodeAt(n.gzindex++)
                                    : 0),
                                It(n, e)
                        } while (0 !== e)
                        n.gzhead.hcrc &&
                            n.pending > i &&
                            (t.adler = H(
                                t.adler,
                                n.pending_buf,
                                n.pending - i,
                                i
                            )),
                            0 === e && (n.status = Et)
                    } else n.status = Et
                if (
                    (n.status === Et &&
                        (n.gzhead.hcrc
                            ? (n.pending + 2 > n.pending_buf_size && St(t),
                              n.pending + 2 <= n.pending_buf_size &&
                                  (It(n, 255 & t.adler),
                                  It(n, (t.adler >> 8) & 255),
                                  (t.adler = 0),
                                  (n.status = yt)))
                            : (n.status = yt)),
                    0 !== n.pending)
                ) {
                    if ((St(t), 0 === t.avail_out))
                        return (n.last_flush = -1), it
                } else if (0 === t.avail_in && vt(s) <= vt(r) && s !== tt)
                    return gt(t, ht)
                if (n.status === At && 0 !== t.avail_in) return gt(t, ht)
                if (
                    0 !== t.avail_in ||
                    0 !== n.lookahead ||
                    (s !== Q && n.status !== At)
                ) {
                    let i =
                        n.strategy === at
                            ? ((t, s) => {
                                  let i
                                  for (;;) {
                                      if (
                                          0 === t.lookahead &&
                                          (Ct(t), 0 === t.lookahead)
                                      ) {
                                          if (s === Q) return 1
                                          break
                                      }
                                      if (
                                          ((t.match_length = 0),
                                          (i = K(t, 0, t.window[t.strstart])),
                                          t.lookahead--,
                                          t.strstart++,
                                          i &&
                                              (Tt(t, !1),
                                              0 === t.strm.avail_out))
                                      )
                                          return 1
                                  }
                                  return (
                                      (t.insert = 0),
                                      s === tt
                                          ? (Tt(t, !0),
                                            0 === t.strm.avail_out ? 3 : 4)
                                          : t.last_lit &&
                                            (Tt(t, !1), 0 === t.strm.avail_out)
                                          ? 1
                                          : 2
                                  )
                              })(n, s)
                            : n.strategy === ut
                            ? ((t, s) => {
                                  let i, e, n, r
                                  const h = t.window
                                  for (;;) {
                                      if (t.lookahead <= pt) {
                                          if (
                                              (Ct(t),
                                              t.lookahead <= pt && s === Q)
                                          )
                                              return 1
                                          if (0 === t.lookahead) break
                                      }
                                      if (
                                          ((t.match_length = 0),
                                          t.lookahead >= 3 &&
                                              t.strstart > 0 &&
                                              ((n = t.strstart - 1),
                                              (e = h[n]),
                                              e === h[++n] &&
                                                  e === h[++n] &&
                                                  e === h[++n]))
                                      ) {
                                          r = t.strstart + pt
                                          do {} while (
                                              e === h[++n] &&
                                              e === h[++n] &&
                                              e === h[++n] &&
                                              e === h[++n] &&
                                              e === h[++n] &&
                                              e === h[++n] &&
                                              e === h[++n] &&
                                              e === h[++n] &&
                                              n < r
                                          )
                                          ;(t.match_length = pt - (r - n)),
                                              t.match_length > t.lookahead &&
                                                  (t.match_length = t.lookahead)
                                      }
                                      if (
                                          (t.match_length >= 3
                                              ? ((i = K(
                                                    t,
                                                    1,
                                                    t.match_length - 3
                                                )),
                                                (t.lookahead -= t.match_length),
                                                (t.strstart += t.match_length),
                                                (t.match_length = 0))
                                              : ((i = K(
                                                    t,
                                                    0,
                                                    t.window[t.strstart]
                                                )),
                                                t.lookahead--,
                                                t.strstart++),
                                          i &&
                                              (Tt(t, !1),
                                              0 === t.strm.avail_out))
                                      )
                                          return 1
                                  }
                                  return (
                                      (t.insert = 0),
                                      s === tt
                                          ? (Tt(t, !0),
                                            0 === t.strm.avail_out ? 3 : 4)
                                          : t.last_lit &&
                                            (Tt(t, !1), 0 === t.strm.avail_out)
                                          ? 1
                                          : 2
                                  )
                              })(n, s)
                            : $t[n.level].func(n, s)
                    if (
                        ((3 !== i && 4 !== i) || (n.status = At),
                        1 === i || 3 === i)
                    )
                        return 0 === t.avail_out && (n.last_flush = -1), it
                    if (
                        2 === i &&
                        (s === J
                            ? Y(n)
                            : s !== st &&
                              (Z(n, 0, 0, !1),
                              s === X &&
                                  (_t(n.head),
                                  0 === n.lookahead &&
                                      ((n.strstart = 0),
                                      (n.block_start = 0),
                                      (n.insert = 0)))),
                        St(t),
                        0 === t.avail_out)
                    )
                        return (n.last_flush = -1), it
                }
                return s !== tt
                    ? it
                    : n.wrap <= 0
                    ? et
                    : (2 === n.wrap
                          ? (It(n, 255 & t.adler),
                            It(n, (t.adler >> 8) & 255),
                            It(n, (t.adler >> 16) & 255),
                            It(n, (t.adler >> 24) & 255),
                            It(n, 255 & t.total_in),
                            It(n, (t.total_in >> 8) & 255),
                            It(n, (t.total_in >> 16) & 255),
                            It(n, (t.total_in >> 24) & 255))
                          : (Pt(n, t.adler >>> 16), Pt(n, 65535 & t.adler)),
                      St(t),
                      n.wrap > 0 && (n.wrap = -n.wrap),
                      0 !== n.pending ? it : et)
            },
            zt = (t, s) => {
                let i = s.length
                if (!t || !t.state) return nt
                const e = t.state,
                    n = e.wrap
                if (2 === n || (1 === n && 42 !== e.status) || e.lookahead)
                    return nt
                if (
                    (1 === n && (t.adler = F(t.adler, s, i, 0)),
                    (e.wrap = 0),
                    i >= e.w_size)
                ) {
                    0 === n &&
                        (_t(e.head),
                        (e.strstart = 0),
                        (e.block_start = 0),
                        (e.insert = 0))
                    let t = new Uint8Array(e.w_size)
                    t.set(s.subarray(i - e.w_size, i), 0),
                        (s = t),
                        (i = e.w_size)
                }
                const r = t.avail_in,
                    h = t.next_in,
                    o = t.input
                for (
                    t.avail_in = i, t.next_in = 0, t.input = s, Ct(e);
                    e.lookahead >= 3;

                ) {
                    let t = e.strstart,
                        s = e.lookahead - 2
                    do {
                        ;(e.ins_h = Rt(e, e.ins_h, e.window[t + 3 - 1])),
                            (e.prev[t & e.w_mask] = e.head[e.ins_h]),
                            (e.head[e.ins_h] = t),
                            t++
                    } while (--s)
                    ;(e.strstart = t), (e.lookahead = 2), Ct(e)
                }
                return (
                    (e.strstart += e.lookahead),
                    (e.block_start = e.strstart),
                    (e.insert = e.lookahead),
                    (e.lookahead = 0),
                    (e.match_length = e.prev_length = 2),
                    (e.match_available = 0),
                    (t.next_in = h),
                    (t.input = o),
                    (t.avail_in = r),
                    (e.wrap = n),
                    it
                )
            },
            Ft = {
                deflateInit: (t, s) => Dt(t, s, wt, 15, 8, dt),
                deflateInit2: Dt,
                deflateReset: Mt,
                deflateResetKeep: xt,
                deflateSetHeader: (t, s) =>
                    t && t.state
                        ? 2 !== t.state.wrap
                            ? nt
                            : ((t.state.gzhead = s), it)
                        : nt,
                deflate: Ut,
                deflateEnd: (t) => {
                    if (!t || !t.state) return nt
                    const s = t.state.status
                    return 42 !== s &&
                        69 !== s &&
                        73 !== s &&
                        91 !== s &&
                        s !== Et &&
                        s !== yt &&
                        s !== At
                        ? gt(t, nt)
                        : ((t.state = null), s === yt ? gt(t, rt) : it)
                },
                deflateSetDictionary: zt,
                deflateInfo: "pako deflate (from Nodeca project)",
            }
        const Bt = (t, s) => Object.prototype.hasOwnProperty.call(t, s)
        var Ht = {
            assign: function (t) {
                const s = Array.prototype.slice.call(arguments, 1)
                for (; s.length; ) {
                    const i = s.shift()
                    if (i) {
                        if ("object" != typeof i)
                            throw new TypeError(i + "must be non-object")
                        for (const s in i) Bt(i, s) && (t[s] = i[s])
                    }
                }
                return t
            },
            flattenChunks: (t) => {
                let s = 0
                for (let i = 0, e = t.length; i < e; i++) s += t[i].length
                const i = new Uint8Array(s)
                for (let s = 0, e = 0, n = t.length; s < n; s++) {
                    let n = t[s]
                    i.set(n, e), (e += n.length)
                }
                return i
            },
        }
        let qt = !0
        try {
            String.fromCharCode.apply(null, new Uint8Array(1))
        } catch (t) {
            qt = !1
        }
        const jt = new Uint8Array(256)
        for (let t = 0; t < 256; t++)
            jt[t] =
                t >= 252
                    ? 6
                    : t >= 248
                    ? 5
                    : t >= 240
                    ? 4
                    : t >= 224
                    ? 3
                    : t >= 192
                    ? 2
                    : 1
        jt[254] = jt[254] = 1
        const Gt = (t, s = t.length) => {
            if (s < 65534 && t.subarray && qt)
                return String.fromCharCode.apply(
                    null,
                    t.length === s ? t : t.subarray(0, s)
                )
            let i = ""
            for (let e = 0; e < s; e++) i += String.fromCharCode(t[e])
            return i
        }
        var Zt = {
            string2buf: (t) => {
                if (
                    "function" == typeof TextEncoder &&
                    TextEncoder.prototype.encode
                )
                    return new TextEncoder().encode(t)
                let s,
                    i,
                    e,
                    n,
                    r,
                    h = t.length,
                    o = 0
                for (n = 0; n < h; n++)
                    (i = t.charCodeAt(n)),
                        55296 == (64512 & i) &&
                            n + 1 < h &&
                            ((e = t.charCodeAt(n + 1)),
                            56320 == (64512 & e) &&
                                ((i =
                                    65536 + ((i - 55296) << 10) + (e - 56320)),
                                n++)),
                        (o += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4)
                for (s = new Uint8Array(o), r = 0, n = 0; r < o; n++)
                    (i = t.charCodeAt(n)),
                        55296 == (64512 & i) &&
                            n + 1 < h &&
                            ((e = t.charCodeAt(n + 1)),
                            56320 == (64512 & e) &&
                                ((i =
                                    65536 + ((i - 55296) << 10) + (e - 56320)),
                                n++)),
                        i < 128
                            ? (s[r++] = i)
                            : i < 2048
                            ? ((s[r++] = 192 | (i >>> 6)),
                              (s[r++] = 128 | (63 & i)))
                            : i < 65536
                            ? ((s[r++] = 224 | (i >>> 12)),
                              (s[r++] = 128 | ((i >>> 6) & 63)),
                              (s[r++] = 128 | (63 & i)))
                            : ((s[r++] = 240 | (i >>> 18)),
                              (s[r++] = 128 | ((i >>> 12) & 63)),
                              (s[r++] = 128 | ((i >>> 6) & 63)),
                              (s[r++] = 128 | (63 & i)))
                return s
            },
            buf2string: (t, s) => {
                const i = s || t.length
                if (
                    "function" == typeof TextDecoder &&
                    TextDecoder.prototype.decode
                )
                    return new TextDecoder().decode(t.subarray(0, s))
                let e, n
                const r = new Array(2 * i)
                for (n = 0, e = 0; e < i; ) {
                    let s = t[e++]
                    if (s < 128) {
                        r[n++] = s
                        continue
                    }
                    let h = jt[s]
                    if (h > 4) (r[n++] = 65533), (e += h - 1)
                    else {
                        for (
                            s &= 2 === h ? 31 : 3 === h ? 15 : 7;
                            h > 1 && e < i;

                        )
                            (s = (s << 6) | (63 & t[e++])), h--
                        h > 1
                            ? (r[n++] = 65533)
                            : s < 65536
                            ? (r[n++] = s)
                            : ((s -= 65536),
                              (r[n++] = 55296 | ((s >> 10) & 1023)),
                              (r[n++] = 56320 | (1023 & s)))
                    }
                }
                return Gt(r, n)
            },
            utf8border: (t, s) => {
                ;(s = s || t.length) > t.length && (s = t.length)
                let i = s - 1
                for (; i >= 0 && 128 == (192 & t[i]); ) i--
                return i < 0 || 0 === i ? s : i + jt[t[i]] > s ? i : s
            },
        }
        var Wt = function () {
            ;(this.input = null),
                (this.next_in = 0),
                (this.avail_in = 0),
                (this.total_in = 0),
                (this.output = null),
                (this.next_out = 0),
                (this.avail_out = 0),
                (this.total_out = 0),
                (this.msg = ""),
                (this.state = null),
                (this.data_type = 2),
                (this.adler = 0)
        }
        const Kt = Object.prototype.toString,
            {
                Z_NO_FLUSH: Yt,
                Z_SYNC_FLUSH: Qt,
                Z_FULL_FLUSH: Jt,
                Z_FINISH: Xt,
                Z_OK: ts,
                Z_STREAM_END: ss,
                Z_DEFAULT_COMPRESSION: is,
                Z_DEFAULT_STRATEGY: es,
                Z_DEFLATED: ns,
            } = j
        function rs(t) {
            this.options = Ht.assign(
                {
                    level: is,
                    method: ns,
                    chunkSize: 16384,
                    windowBits: 15,
                    memLevel: 8,
                    strategy: es,
                },
                t || {}
            )
            let s = this.options
            s.raw && s.windowBits > 0
                ? (s.windowBits = -s.windowBits)
                : s.gzip &&
                  s.windowBits > 0 &&
                  s.windowBits < 16 &&
                  (s.windowBits += 16),
                (this.err = 0),
                (this.msg = ""),
                (this.ended = !1),
                (this.chunks = []),
                (this.strm = new Wt()),
                (this.strm.avail_out = 0)
            let i = Ft.deflateInit2(
                this.strm,
                s.level,
                s.method,
                s.windowBits,
                s.memLevel,
                s.strategy
            )
            if (i !== ts) throw new Error(q[i])
            if (
                (s.header && Ft.deflateSetHeader(this.strm, s.header),
                s.dictionary)
            ) {
                let t
                if (
                    ((t =
                        "string" == typeof s.dictionary
                            ? Zt.string2buf(s.dictionary)
                            : "[object ArrayBuffer]" === Kt.call(s.dictionary)
                            ? new Uint8Array(s.dictionary)
                            : s.dictionary),
                    (i = Ft.deflateSetDictionary(this.strm, t)),
                    i !== ts)
                )
                    throw new Error(q[i])
                this._dict_set = !0
            }
        }
        function hs(t, s) {
            return (
                ((s = s || {}).gzip = !0),
                (function (t, s) {
                    const i = new rs((s = s || {}))
                    if ((i.push(t, !0), i.err)) throw i.msg || q[i.err]
                    return i.result
                })(t, s)
            )
        }
        return (
            (rs.prototype.push = function (t, s) {
                const i = this.strm,
                    e = this.options.chunkSize
                let n, r
                if (this.ended) return !1
                for (
                    r = s === ~~s ? s : !0 === s ? Xt : Yt,
                        "string" == typeof t
                            ? (i.input = Zt.string2buf(t))
                            : "[object ArrayBuffer]" === Kt.call(t)
                            ? (i.input = new Uint8Array(t))
                            : (i.input = t),
                        i.next_in = 0,
                        i.avail_in = i.input.length;
                    ;

                )
                    if (
                        (0 === i.avail_out &&
                            ((i.output = new Uint8Array(e)),
                            (i.next_out = 0),
                            (i.avail_out = e)),
                        (r === Qt || r === Jt) && i.avail_out <= 6)
                    )
                        this.onData(i.output.subarray(0, i.next_out)),
                            (i.avail_out = 0)
                    else {
                        if (((n = Ft.deflate(i, r)), n === ss))
                            return (
                                i.next_out > 0 &&
                                    this.onData(
                                        i.output.subarray(0, i.next_out)
                                    ),
                                (n = Ft.deflateEnd(this.strm)),
                                this.onEnd(n),
                                (this.ended = !0),
                                n === ts
                            )
                        if (0 !== i.avail_out) {
                            if (r > 0 && i.next_out > 0)
                                this.onData(i.output.subarray(0, i.next_out)),
                                    (i.avail_out = 0)
                            else if (0 === i.avail_in) break
                        } else this.onData(i.output)
                    }
                return !0
            }),
            (rs.prototype.onData = function (t) {
                this.chunks.push(t)
            }),
            (rs.prototype.onEnd = function (t) {
                t === ts && (this.result = Ht.flattenChunks(this.chunks)),
                    (this.chunks = []),
                    (this.err = t),
                    (this.msg = this.strm.msg)
            }),
            (t, s, i) => {
                let e = hs(t)
                return (
                    (e = "base64" === s ? btoa(Gt(e)) : e.buffer), i && i(e), e
                )
            }
        )
    }
    Uc.init()
    class Fc extends Es {
        constructor(t) {
            super(t),
                (this.algorithm = ds.GZIP),
                (this.jm = zc()),
                (this.Gm = (t, s, i) => {
                    i(this.jm(t, s))
                }),
                (this.compress = Bc())
            ;("undefined" != typeof CompressionStream && Ms) ||
                ((this.compress = this.Gm),
                (this.getCompressorSourceCode = () => zc.toString()))
        }
        compressSync(t, s) {
            return this.jm(t, s)
        }
        getCompressorSourceCode() {
            return Bc.toString()
        }
    }
    function Bc() {
        return (t, s, i) => {
            const e = new Response(t).body.pipeThrough(
                    new CompressionStream("gzip")
                ),
                n = new Response(e).arrayBuffer()
            "base64" !== s
                ? n.then((t) => i(t))
                : n
                      .then((t) => {
                          return (
                              (s = t),
                              new Promise((t) => {
                                  const i = new FileReader()
                                  ;(i.onload = (s) =>
                                      t(s.target.result.split(",")[1])),
                                      i.readAsDataURL(new Blob([s]))
                              })
                          )
                          var s
                      })
                      .then((t) => i(t))
        }
    }
    class Hc extends Es {
        constructor() {
            super(...arguments), (this.algorithm = ds.UNCOMPRESSED)
        }
        compress(t, s, i) {
            i(this.compressSync(t, s))
        }
        compressSync(t, s) {
            return t
        }
        getCompressorSourceCode() {
            return function () {
                return (t, s, i) => i(t)
            }.toString()
        }
    }
    class qc {
        static create(t) {
            return this.instance
                ? this.instance
                : Uc.isCompressionEnabled()
                ? (this.instance = new Fc(t))
                : new Hc(t)
        }
    }
    class jc {
        setItem(t, s) {
            window.sessionStorage.setItem(t, s)
        }
        getItem(t) {
            return window.sessionStorage.getItem(t)
        }
        removeItem(t) {
            window.sessionStorage.removeItem(t)
        }
    }
    class Gc {
        setItem(t, s) {
            window.localStorage.setItem(t, s)
        }
        getItem(t) {
            return window.localStorage.getItem(t)
        }
        removeItem(t) {
            window.localStorage.removeItem(t)
        }
    }
    const Zc = "_cs_cvars"
    class Wc {
        constructor(t, s, i) {
            ;(this.$ = t), (this.dp = s), (this.fp = i)
        }
        onCookieToSet(t) {
            this.gp = t
        }
        onCookieToRemove(t) {
            this.vp = t
        }
        get() {
            return this.$.cookielessTrackingEnabled
                ? this.fp.getItem(Zc)
                : this.dp.get(Zc)
        }
        set(t) {
            var s
            this.$.cookielessTrackingEnabled
                ? this.fp.setItem(Zc, t)
                : (this.dp.set(Zc, t),
                  null === (s = this.gp) || void 0 === s || s.call(this, Zc, t))
        }
        remove() {
            var t
            this.$.cookielessTrackingEnabled
                ? this.fp.removeItem(Zc)
                : (this.dp.delete(Zc),
                  null === (t = this.vp) || void 0 === t || t.call(this, Zc))
        }
        static isValidCustomVarString(t) {
            return "string" == typeof t
        }
    }
    const Kc = ["visit", 2],
        Yc = ["page", 3],
        Qc = ["nextPageOnly", 4]
    class Jc {
        constructor(t, s) {
            ;(this.L = t), (this.np = s), (this.Zm = {}), (this.Wm = {})
        }
        set(t, s, i, e) {
            let n, r
            if (t > 0 && Tt(s) && Tt(i) && !It(s) && !It(i)) {
                const h = this.L.anonymizePII(csString(s)),
                    o = this.L.anonymizePII(csString(i))
                if (
                    ((n = [
                        csString.prototype.slice.call(h, 0, 512),
                        csString.prototype.slice.call(o, 0, 255),
                    ]),
                    (r = "" !== i),
                    !St(e) || csArray.prototype.indexOf.call(Kc, e) >= 0)
                ) {
                    const s = this.getCustomVariablesSession()
                    r ? (s[t] = n) : delete s[t],
                        this.setCustomVariableSession(s)
                }
                ;(!St(e) || csArray.prototype.indexOf.call(Yc, e) >= 0) &&
                    (r ? (this.Zm[t] = n) : delete this.Zm[t]),
                    St(e) &&
                        csArray.prototype.indexOf.call(Qc, e) >= 0 &&
                        (r ? (this.Wm[t] = n) : delete this.Wm[t])
            }
        }
        getCustomVariablesSession() {
            const t = this.np.get()
            if (!t) return {}
            const s = window.csJSON.parse(t)
            return null !== s && Rt(s) ? s : {}
        }
        setCustomVariableSession(t) {
            this.np.set(window.csJSON.stringify(t))
        }
        removeCustomVariablesSession() {
            this.np.remove()
        }
        removeCustomVariablesPage() {
            this.Zm = {}
        }
        getRequestParameters() {
            const t = this.getCustomVariablesSession()
            for (const t in this.Wm)
                this.Wm.hasOwnProperty(t) && (this.Zm[t] = this.Wm[t])
            for (const s in this.Zm)
                this.Zm.hasOwnProperty(s) && (t[s] = this.Zm[s])
            if (window.csJSON.stringify(t).length <= 2) return {}
            const s = { cvars: this.Km(t) }
            return (
                this.Zm &&
                    window.csJSON.stringify(this.Zm).length > 2 &&
                    (s.cvarp = this.Km(this.Zm)),
                s
            )
        }
        deleteNextPageOnlyCustomVariables() {
            if (Object.keys(this.Wm).length > 0)
                for (const t in this.Wm)
                    this.Wm[t] === this.Zm[t] &&
                        (delete this.Zm[t], delete this.Wm[t])
        }
        Km(t) {
            for (const n in t)
                if (t.hasOwnProperty(n)) {
                    const r = parseInt(n, 10),
                        h = t[n],
                        o = h[0],
                        c = h[1]
                    ;(i = 1),
                        (e = 20),
                        (!(vt((s = r)) && s >= i && s <= e) ||
                            o.length > 512 ||
                            c.length > 255) &&
                            delete t[n]
                }
            var s, i, e
            const n = (function (t) {
                let s
                for (s in t) return !1
                return !0
            })(t)
                ? []
                : t
            return window.csJSON.stringify(n)
        }
    }
    const Xc = ["setCustomVariable"]
    class ta {
        constructor(t, s) {
            ;(this.Wc = t), (this.rs = s)
        }
        init() {
            this.Wc.register(Xc, (t, s, i, e) => {
                this.rs.set(t, s, i, e)
            })
        }
        onAfterArtificialPageView() {
            this.rs.deleteNextPageOnlyCustomVariables()
        }
        onAfterNaturalPageView() {
            this.rs.deleteNextPageOnlyCustomVariables()
        }
        onOptout() {
            this.rs.removeCustomVariablesSession()
        }
        onBeforeVisitorRenewal() {
            this.rs.removeCustomVariablesSession(),
                this.rs.removeCustomVariablesPage()
        }
    }
    const sa = "_cs_id",
        ia = /^(([a-z0-9\-])+(\.[0-9]+){6})(\.(None|Lax|X)\.(0|1))?(\.[0-1])?$/
    class ea {
        constructor(t, s, i) {
            ;(this.$ = t), (this.dp = s), (this.fp = i)
        }
        onCookieToSet(t) {
            this.gp = t
        }
        onCookieToRemove(t) {
            this.vp = t
        }
        get() {
            let t
            return (
                (t = this.$.cookielessTrackingEnabled
                    ? this.fp.getItem(sa)
                    : this.dp.get(sa)),
                t ? ea.fromString(t) : null
            )
        }
        set(t) {
            var s
            const i = ea.toString(t)
            if (this.$.cookielessTrackingEnabled) this.fp.setItem(sa, i)
            else {
                const e = new csDate(t.expires)
                this.dp.set(sa, i, e),
                    null === (s = this.gp) ||
                        void 0 === s ||
                        s.call(this, sa, i, e)
            }
        }
        remove() {
            var t
            this.$.cookielessTrackingEnabled
                ? this.fp.removeItem(sa)
                : (this.dp.delete(sa),
                  null === (t = this.vp) || void 0 === t || t.call(this, sa))
        }
        handleSubdomainChange() {
            if (this.$.cookielessTrackingEnabled) return
            const t = this.get()
            t &&
                ((t.allowSubdomains = this.$.allowSubdomains),
                this.$.allowSubdomains
                    ? this.dp.delete(sa, hs.CURRENT_DOMAIN)
                    : this.dp.delete(sa, this.dp.getRootDomain()),
                this.set(t))
        }
        static fromString(t) {
            const [s, i, e, n, r, h, o, c] = csString.prototype.split.call(
                t,
                "."
            )
            return {
                id: s,
                creationTimestamp: Number(i),
                visitsCount: Number(e),
                hitTimestamp: Number(n),
                lastVisitTimestamp: Number(r),
                appliedTrackingDraw: Number(h),
                expires: Number(o),
                allowSubdomains: void 0 === c ? void 0 : !!Number(c),
            }
        }
        static toString(t) {
            return csArray.prototype.join.call(
                [
                    t.id,
                    t.creationTimestamp,
                    t.visitsCount,
                    t.hitTimestamp,
                    t.lastVisitTimestamp,
                    t.appliedTrackingDraw,
                    t.expires,
                    t.allowSubdomains ? 1 : 0,
                ],
                "."
            )
        }
        static isValidVisitorString(t) {
            return ia.test(t)
        }
    }
    class na {
        constructor(t) {
            this.L = t
        }
        getUrlMaskingPattern(t) {
            const s = [],
                i = csString.prototype.split.call(t, "/")
            for (const t of i)
                W(t, na.Ym)
                    ? csArray.prototype.push.call(s, {
                          key: t,
                          value: `CS_ANONYMIZED_${csString.prototype.toUpperCase.call(
                              csString.prototype.slice.call(t, 1)
                          )}`,
                      })
                    : csArray.prototype.push.call(s, { key: t, value: null })
            return s
        }
        anonymizeUrl(t, s) {
            let i = this.L.anonymizePII(t)
            return (
                (i = this.L.anonymizeJwt(i)), s.length > 0 ? this.Qm(i, s) : i
            )
        }
        removeQueryString(t) {
            const { path: s, queryString: i } = this.Jm(t)
            return "" !== i ? `${s}?` : s
        }
        Jm(t) {
            const s = csString.prototype.indexOf.call(t, "?")
            let i = "",
                e = ""
            return (
                -1 !== s
                    ? ((i = csString.prototype.slice.call(t, 0, s)),
                      (e = csString.prototype.slice.call(t, s, t.length)))
                    : (i = t),
                { path: i, queryString: e }
            )
        }
        Qm(t, s) {
            const { path: i, queryString: e } = this.Jm(t),
                n = csString.prototype.split.call(i, "/")
            for (const t of s) {
                const s = this.Xm(n, t)
                if (null !== s) return `${s}${e}`
            }
            return t
        }
        Xm(t, s) {
            if (t.length < s.length) return null
            let i = ""
            for (let e = 0; e < t.length; e += 1)
                if (e >= s.length) i += `${t[e]}/`
                else if (W(s[e].key, na.Ym)) i += `${s[e].value}/`
                else {
                    if (t[e] !== s[e].key) return null
                    i += `${t[e]}/`
                }
            return csString.prototype.slice.call(i, 0, -1)
        }
    }
    na.Ym = ":"
    class ra {
        constructor(t, s) {
            ;(this.Wa = t), (this.$ = s)
        }
        getEventTargetPath(t) {
            const s = Ls(t)
            return this.Wa.getElementPath(s, {
                dynamicIdRegex: this.$.dynamicIdRegex,
                ...this.$.pathComputationRules,
            })
        }
        getEventTargetPathAndTargetLink(t) {
            const s = Ls(t),
                {
                    path: i,
                    firstAnchorParent: e,
                } = this.Wa.getElementPathAndFirstAnchorParent(s, {
                    dynamicIdRegex: this.$.dynamicIdRegex,
                    ...this.$.pathComputationRules,
                })
            return { path: i, targetLink: this.tE(e) ? e.href : "" }
        }
        hasValidEventTarget(t) {
            const s = Ls(t)
            return this.Wa.isValidElement(s)
        }
        getElementPath(t) {
            return this.Wa.getElementPath(t, {
                dynamicIdRegex: this.$.dynamicIdRegex,
                ...this.$.pathComputationRules,
            })
        }
        tE(t) {
            var s
            return (
                null !== t &&
                t.hasAttribute("href") &&
                !W(
                    null !== (s = t.getAttribute("href")) && void 0 !== s
                        ? s
                        : "",
                    "#"
                )
            )
        }
    }
    class ha {
        constructor(t) {
            this.Uu = t
        }
        transformEvent(t, s) {
            const i = this.sE(t, s),
                e = this.Uu.getElementPath(t)
            return this.iE(e, i)
        }
        sE(t, s) {
            if (
                (function (t) {
                    return void 0 !== t.x && void 0 !== t.y
                })(s)
            ) {
                const i = t.getBoundingClientRect()
                ;(s.x = Math.round(i.left + s.x + Vi.windowOffsetX())),
                    (s.y = Math.round(i.top + s.y + Vi.windowOffsetY()))
            }
            return s
        }
        iE(t, s) {
            return (
                ur(s) && (s.tgt = `${t}${xc}${s.tgt}`),
                (function (t) {
                    return void 0 !== t.tgtHM
                })(s) && (s.tgtHM = `${t}${xc}${s.tgtHM}`),
                (function (t) {
                    return void 0 !== t.tgtLk
                })(s) && (s.tgtLk = `${t}${xc}${s.tgtLk}`),
                s
            )
        }
    }
    class oa {
        constructor(t) {
            this.Uu = t
        }
        transformEvent(t, s) {
            const i = this.Uu.getElementPath(t)
            return {
                iframePath: s.iframePath ? `${i}${xc}${s.iframePath}` : i,
                commands: s.commands,
            }
        }
    }
    class ca {
        constructor(t) {
            this.Uu = t
        }
        transformEvent(t, s) {
            if (0 === s.products.length) return s
            const i = this.Uu.getElementPath(t),
                e = csArray.prototype.map.call(s.products, (t) => ({
                    ...t,
                    targetPath: `${i}${xc}${t.targetPath}`,
                }))
            return { ...s, products: e }
        }
    }
    class aa {
        constructor(t) {
            ;(this.cs = t),
                (this.eE = { clientX: 2, clientY: 3 }),
                (this.nE = { clientX: 1, clientY: 2 }),
                (this.rE = [fs.POINTER_DOWN, fs.POINTER_MOVE, fs.POINTER_UP]),
                (this.hE = [fs.TOUCH_START, fs.TOUCH_MOVE, fs.TOUCH_END])
        }
        transformEvents(t, s) {
            if (!Oi.isConnected(t))
                return (
                    (s.events = csArray.prototype.filter.call(
                        s.events,
                        (t) => t.type !== fs.VISIBILITY_CHANGE
                    )),
                    0 === s.events.length ||
                        (Jt.warn(
                            `IframeRecordingEventsTransformer received event ${
                                Zt.RecordingEvent
                            }\n        from disconnected iframe, content:${csJSON.stringify(
                                s.events
                            )}`
                        ),
                        (s.events = [])),
                    s
                )
            const i = this.cs.getId(t)
            if (void 0 === i)
                return (
                    Jt.error(
                        `IframeRecordingEventsTransformer received event ${
                            Zt.RecordingEvent
                        }\n        from unidentified iframe, content:${csJSON.stringify(
                            s.events
                        )}`
                    ),
                    (s.events = []),
                    s
                )
            let e = null
            csArray.prototype.some.call(
                s.events,
                (t) => this.oE(t) || this.cE(t)
            ) && (e = t.getBoundingClientRect())
            for (const t of s.events)
                this.oE(t) ? this.aE(e, t) : this.cE(t) && this.uE(e, t),
                    (t.context =
                        t.context && t.context.length > 0
                            ? `${i}/${t.context}`
                            : `${i}`)
            return s
        }
        uE(t, s) {
            this.lE(this.nE, t, s)
        }
        aE(t, s) {
            this.lE(this.eE, t, s)
        }
        lE(t, s, i) {
            i.args &&
                ((i.args[t.clientX] = Math.round(s.left + i.args[t.clientX])),
                (i.args[t.clientY] = Math.round(s.top + i.args[t.clientY])))
        }
        oE(t) {
            return -1 !== csArray.prototype.indexOf.call(this.rE, t.type)
        }
        cE(t) {
            return -1 !== csArray.prototype.indexOf.call(this.hE, t.type)
        }
    }
    class ua {
        constructor(t) {
            this.dE = t
        }
        start() {
            this.dE.onEvent((t) => this.$e(t)), this.dE.start()
        }
        stop() {
            this.dE.stop()
        }
        $e(t) {
            const s = `Content Security Policy error. Violated directive: ${t.violatedDirective} - Source file: ${t.sourceFile}`
            Jt.warn(s)
        }
    }
    class la {
        constructor() {
            this.fE = {
                boundElement: document,
                type: "securitypolicyviolation",
                listener: (t) => this.securityPolicyViolationListener(t),
            }
        }
        start() {
            vs(this.fE)
        }
        stop() {
            _s(this.fE)
        }
        onEvent(t) {
            this.zs = t
        }
        wE(t) {
            if (!t) return !1
            const s = t.disposition
            return (
                _t(t.sourceFile) &&
                csArray.prototype.some.call(
                    la.pE,
                    (s) => csString.prototype.indexOf.call(t.sourceFile, s) > 0
                ) &&
                "report" !== s
            )
        }
        securityPolicyViolationListener(t) {
            this.wE(t) &&
                this.zs({
                    violatedDirective: t.violatedDirective,
                    sourceFile: t.sourceFile,
                })
        }
    }
    ;(la.pE = ["contentsquare", "cdnssl.clicktale.net"]),
        ss(
            [ts("Event handler type: securitypolicyviolation")],
            la.prototype,
            "securityPolicyViolationListener",
            null
        )
    class da {
        init() {
            ;(this.mE = new ua(new la())), this.mE.start()
        }
        onOptout() {
            this.mE.stop()
        }
    }
    class fa {
        constructor(t, s, i, e) {
            ;(this.$ = t), (this.tt = s), (this.M = i), (this.hr = e)
        }
        init() {
            let t,
                s,
                i,
                e,
                n,
                r,
                h,
                o,
                c,
                a,
                u,
                l,
                d,
                f,
                w,
                p,
                m,
                E,
                y,
                A,
                g,
                v,
                _,
                R,
                S,
                T,
                I,
                P,
                b,
                V,
                C,
                N,
                O
            this.hr.schedule(() => {
                ;(t = new Jo(this.hr)),
                    (s = new dt()),
                    (i = new na(s)),
                    (n = new kc(window.location, i)),
                    (e = new hs(this.$, n, this.tt)),
                    e.init()
            }),
                this.hr.schedule(() => {
                    ;(r = new jc()),
                        (h = new Gc()),
                        (E = new vc(window.location, e))
                    new da().init(), (y = qc.create(Jt.warn)), (m = new As(y))
                    const s = m.create(
                        `${this.$.getQuotaServiceUri()}/quota`,
                        !0
                    )
                    ;(a = new Lc(this.$, s, t, E, n)), a.init()
                }),
                this.hr.schedule(() => {
                    ;(o = new Go(this.$, e, r)), (c = new Wo(o, a))
                }),
                this.hr.schedule(() => {
                    ;(u = new ea(this.$, e, r)),
                        (l = new zo(this.$, u, c, t)),
                        this.M.setContext(l, c),
                        a.setVisitorService(l)
                }),
                this.hr.schedule(() => {
                    ;(O = new cc(this.$, new sc(this.$, e, h), t)),
                        (d = new Yo(l, c, O)),
                        (f = new fc(this.$, e, r)),
                        (w = new wc(window.location, f)),
                        (p = new pc(w)),
                        (A = new Ko(this.$, l, w))
                    const i = new _n()
                    ;(C = new ra(j, this.$)),
                        (T = new ha(C)),
                        (I = new oa(C)),
                        (P = new ca(C)),
                        (b = new aa(i)),
                        (V = new Mc(T, I, P, b)),
                        (S = new Vc([bc.UXA])),
                        (g = new Pc(S, V)),
                        (v = new Ec(n)),
                        (_ = new Ac(v, S))
                    const o = new Wc(this.$, e, r)
                    ;(N = new Jc(s, o)), (R = new ta(S, N))
                    new gs(l, c, w, N, this.$)
                }),
                this.hr.schedule(() => {
                    new Do(this.$, l, w, A, d, undefined, undefined, E).compute(
                        (r) => {
                            this.hr.schedule(() => {
                                g.init()
                                const o = new $c(),
                                    a = new oc(this.$, S, O, c, t),
                                    u = new Rc(this.$, e, h),
                                    d = new Sc(t, window.location, u),
                                    f = new Ic(S, d),
                                    w = new Nc(S, this.$)
                                const E = new Cc(this.$, l, c, undefined)
                                if (r) {
                                    t.emitInitTracking()
                                    new Mo(
                                        E,
                                        y,
                                        l,
                                        c,
                                        t,
                                        S,
                                        g,
                                        this.$,
                                        f,
                                        d,
                                        a,
                                        O,
                                        s,
                                        C,
                                        i,
                                        n,
                                        w,
                                        o,
                                        V,
                                        N,
                                        R,
                                        v,
                                        _,
                                        this.hr,
                                        m
                                    ).start()
                                } else {
                                    new ac(t, S, g, f, d, p, a).start()
                                }
                            })
                        }
                    )
                })
        }
    }
    var wa, pa
    !(function (t) {
        const s = "{domain}/tag/bridge.html?v={version}#{token}"
        let i
        const e = {
            loadBundle(t) {
                const o = t.source,
                    c = t.data
                if (r(c)) {
                    const r = () => {
                        !(function (t, s) {
                            const i = document.createElement("script")
                            ;(i.type = "text/javascript"),
                                (i.async = !0),
                                (i.src = t),
                                (i.onload = s),
                                (i.charset = "utf-8"),
                                document.head.appendChild(i)
                        })(n("{domain}/tag/tag.bundle.js?v={version}", c), () =>
                            o.postMessage("csBundleLoaded", t.origin)
                        )
                    }
                    ;(i = c.token),
                        u(e.loadBundle),
                        h(t.origin)
                            ? r()
                            : (function (t, i) {
                                  const e = n(s, t),
                                      r = (function (t) {
                                          const s = document.createElement(
                                              "iframe"
                                          )
                                          return (
                                              (s.src = t),
                                              (s.id = "content-square-bridge"),
                                              s.setAttribute(
                                                  "style",
                                                  "display: none !important; visibility: hidden !important;"
                                              ),
                                              s
                                          )
                                      })(e),
                                      h = (t) => {
                                          t.source === r.contentWindow &&
                                              "TOKEN_VALID" === t.data &&
                                              (u(h), r.remove(), i())
                                      }
                                  a(h), document.head.appendChild(r)
                              })(c, r)
                }
            },
        }
        function n(t, s) {
            return csString.prototype.replace.call(
                csString.prototype.replace.call(
                    csString.prototype.replace.call(t, "{version}", s.version),
                    "{token}",
                    s.token
                ),
                "{domain}",
                s.domain
            )
        }
        function r(t) {
            return (
                t &&
                "csBundleInjection" === t.type &&
                h(t.domain) &&
                c(t.version) &&
                o(t.token)
            )
        }
        function h(t) {
            return /^https?:\/\/[a-zA-Z0-9\.\-]+\.(content-square\.fr|contentsquare\.com|csq\.io)$/.test(
                t
            )
        }
        function o(t) {
            return /^[a-zA-Z0-9]+$/.test(t)
        }
        function c(t) {
            return /^[a-zA-Z0-9\.]+$/.test(t)
        }
        function a(t) {
            window.addEventListener("message", t, !1)
        }
        function u(t) {
            window.removeEventListener("message", t, !1)
        }
        ;(t.getToken = function () {
            return i
        }),
            (t.isAuthorizedIncomingMessage = r),
            (t.isAuthorizedDomain = h),
            (t.isAuthorizedToken = o),
            (t.isAuthorizedTagVersion = c),
            (t.isActivable = function () {
                const t = window.opener || window.parent
                return window !== t && window.addEventListener
            }),
            (t.waitForBundleInjection = function () {
                a(e.loadBundle)
            }),
            (t.listen = a),
            (t.removeListener = u)
    })(wa || (wa = {})),
        (function (t) {
            const s = window.opener || window.parent,
                i = [
                    /^https:\/\/app\.contentsquare\.com$/,
                    /^https:\/\/dev-app\.contentsquare\.com$/,
                    /^https:\/\/staging-app\.contentsquare\.com$/,
                    /^https:\/\/.*\.test\.contentsquare\.com$/,
                    /^https:\/\/app\.[a-z0-9-]+\.csiab\.[a-z0-9-]+\.csq\.io$/,
                ]
            let e
            const n = {
                ping(t) {
                    "ping" === t.data &&
                        r(t.origin) &&
                        ((e = t.origin),
                        c(n.ping),
                        o(n.insertMessageScript),
                        h(`${"utils.js"}?cb=${new csDate().getTime()}`))
                },
                insertMessageScript: a((t) => {
                    const s = t.data
                    "string" == typeof s &&
                        "ping" !== s &&
                        (c(n.insertMessageScript), h(s))
                }),
            }
            function r(t) {
                return csArray.prototype.some.call(i, (s) => s.test(t))
            }
            function h(t, s) {
                const i = document.createElement("script")
                ;(i.type = "text/javascript"), (i.async = !0)
                const n = csString.prototype.replace.call(e, /^https?:/, "")
                ;(i.src = `${n}/tag/${t}`),
                    (i.onload = s),
                    (i.charset = "utf-8"),
                    document.getElementsByTagName("head")[0].appendChild(i)
            }
            function o(t) {
                window.addEventListener("message", t, !1)
            }
            function c(t) {
                window.removeEventListener("message", t, !1)
            }
            function a(t) {
                return function (s) {
                    s.origin === e && t(s)
                }
            }
            ;(t.getToken = function () {
                return wa.getToken()
            }),
                (t.isActivable = function () {
                    return window !== s && window.addEventListener
                }),
                (t.isAuthorizedDomain = r),
                (t.waitForConnection = function () {
                    o(n.ping), wa.waitForBundleInjection()
                }),
                (t.listen = o),
                (t.removeListener = c),
                (t.secureListener = a),
                (t.post = function (t) {
                    e && s.postMessage(t, e)
                })
        })(pa || (pa = {}))
    const ma = window.CSFrameCommunication || pa
    class Ea {
        constructor(t, s, i) {
            ;(this.$ = t), (this.Et = s), (this.M = i)
        }
        start() {
            var t, s, i, e, n
            if (window.UXAnalytics) return
            const r = new Kh(
                    !!(null === (t = this.$.taskSchedulerOptions) ||
                    void 0 === t
                        ? void 0
                        : t.enabled),
                    null === (s = this.$.taskSchedulerOptions) || void 0 === s
                        ? void 0
                        : s.maxProcessingTime,
                    null === (i = this.$.taskSchedulerOptions) || void 0 === i
                        ? void 0
                        : i.waitDuration
                ),
                h = new cs(this.Et, this.$)
            h.init()
            const o = new as(this.$, h)
            if (this.Et.isTopWindowTracker() && o.canTrack()) {
                if (
                    ((null === (e = window.CSProtectnativeFunctionsLogs) ||
                    void 0 === e
                        ? void 0
                        : e.Warning) &&
                        Jt.warn(
                            `protectNativeFunctions failed: ${window.CSProtectnativeFunctionsLogs.Warning}`
                        ),
                    null === (n = window.CSProtectnativeFunctionsLogs) ||
                    void 0 === n
                        ? void 0
                        : n.Critical)
                )
                    return void Jt.error(
                        `protectNativeFunctions failed: ${window.CSProtectnativeFunctionsLogs.Critical}`
                    )
                new fa(this.$, h, this.M, r).init()
            } else 0
            ;(window.UXAnalytics = {}),
                !window.CSFrameCommunication &&
                    ma.isActivable() &&
                    ((window.CSFrameCommunication = ma), ma.waitForConnection())
        }
    }
    ss([$s("main.start"), ts("main.start")], Ea.prototype, "start", null)
    var ya
    !(function (t) {
        ;(t.isCSJavascriptBridgeDefined = function () {
            return (
                "object" == typeof window.CSJavascriptBridge &&
                "function" == typeof window.CSJavascriptBridge.optIn &&
                "function" == typeof window.CSJavascriptBridge.optOut &&
                "function" == typeof window.CSJavascriptBridge.sendEvent &&
                "function" == typeof window.CSJavascriptBridge.sendDynamicVar &&
                "function" == typeof window.CSJavascriptBridge.sendTransaction
            )
        }),
            (t.getBridgeVersion = function () {
                if ("function" == typeof window.CSJavascriptBridge.getVersion)
                    try {
                        const t = window.CSJavascriptBridge.getVersion()
                        if (gt(t)) return t
                    } catch (t) {
                        Jt.warn("an error occurred when calling getVersion")
                    }
                return null
            }),
            (t.notifyIsReadyForTracking = function () {
                "function" ==
                    typeof window.CSJavascriptBridge.onWebviewTrackingReady &&
                    window.CSJavascriptBridge.onWebviewTrackingReady()
            }),
            (t.sendAnalysisEvent = function (t) {
                window.CSJavascriptBridge.sendEvent(csJSON.stringify(t))
            }),
            (t.sendSREvent = function (t) {
                if (window.CSJavascriptBridge.sendSREvent)
                    for (const s of t.events)
                        window.CSJavascriptBridge.sendSREvent(
                            csJSON.stringify(s)
                        )
            }),
            (t.sendLog = function (t) {
                window.CSJavascriptBridge &&
                    window.CSJavascriptBridge.sendLog &&
                    window.CSJavascriptBridge.sendLog(csJSON.stringify(t))
            }),
            (t.sendOptIn = function () {
                window.CSJavascriptBridge.optIn()
            }),
            (t.sendOptOut = function () {
                window.CSJavascriptBridge.optOut()
            }),
            (t.sendDynamicVariable = function (t, s) {
                window.CSJavascriptBridge.sendDynamicVar(t, s)
            }),
            (t.sendTransaction = function (t, s, i) {
                window.CSJavascriptBridge.sendTransaction(t, s, i)
            }),
            (t.sendAssets = function (t, s) {
                if (window.CSJavascriptBridge.sendAssets) {
                    const i = csJSON.stringify(t)
                    window.CSJavascriptBridge.sendAssets(i, s || null)
                } else
                    window.CSJavascriptBridge.sendSRAssets &&
                        window.CSJavascriptBridge.sendSRAssets(
                            csArray.prototype.map.call(t, (t) => t.assetId)
                        )
            }),
            (t.sendNativeSREvent = function (t) {
                window.CSJavascriptBridge &&
                    window.CSJavascriptBridge.sendNativeSREvent &&
                    window.CSJavascriptBridge.sendNativeSREvent(
                        csJSON.stringify(t)
                    )
            })
    })(ya || (ya = {}))
    class Aa {
        constructor() {}
        send(t, s, i = st.warn) {
            const e = { message: t, errorCode: s, level: i }
            ya.sendLog(e)
        }
    }
    try {
        const t = new X(window.CS_CONF)
        ;(window._uxa = window._uxa || []),
            t.processOptionOverrides(window._uxa)
        const s = new tt(window, t)
        s.init()
        const i = new Yt()
        if (
            ((Xt = Jt),
            Jt.computeIsActive(t.validationRate),
            s.isTopWindowTracker())
        ) {
            const s = new kt(t, i)
            Jt.setStrategy(s)
        } else if (s.isInIframeContext()) {
            const s = new Kt(t)
            Jt.setStrategy(s)
        } else if (s.isInWebViewContext()) {
            const t = new Aa()
            Jt.setStrategy(t)
        }
        !(function (t = 50, s = 0.1) {
            ;(Ns =
                Jt.isPerfLoggingActive() &&
                (function () {
                    var t
                    if (
                        !(null === (t = window.performance) || void 0 === t
                            ? void 0
                            : t.mark)
                    )
                        return !1
                    const s = "isPerformanceMeasureSupported",
                        i = `${s}_a`
                    return (
                        performance.mark(i),
                        void 0 !== performance.measure(s, i)
                    )
                })()),
                Ns && ((Vs = t), (Cs = s))
        })()
        new Ea(t, s, i).start()
    } catch {}
})()
